[{"id":0,"href":"/posts/installingGCC/","title":"Installing GCC","section":"Resources","content":" Installing gcc # This tutorial will be a quick walkthrough on installing gcc on different OS. We recommend you try installing gcc on your own before the start of classes. If, for some reason, you are unable to install gcc, then we will help you in the first tutorial session. We also recommend you install some text editor (VS Code for example).\nWe recommend the usage of Linux as this would be advantageous for your future courses as well. linux Linux (Ubuntu 22.04) # For Linux-based systems, gcc usually comes installed by default.\nCheck if gcc is installed on Ubuntu by running the command: $ gcc --version\nIf running this shows a version (For eg 13.1 or say any other version) then you are good to go.\nOtherwise, if you see an error that reads “command not found” or something similar, run the following commands:\n$ sudo apt update\n$ sudo apt install build-essential\nAfter running this, check if gcc is installed by running:\n$ gcc --version\nmac MacOS # For Mac-based systems, first start with installing homebrew (if not installed).\n$ /bin/bash -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026quot;\nAfter installing homebrew, you simply have to run:\n$ brew install gcc\nAfter running this, check if gcc is installed by running:\n$ gcc --version\nThis should show the path in which gcc has been installed on your Mac.\nwindows Windows # In Windows, C programs can be compiled using the MinGW C compiler.\nFor installation details, refer: https://www.scaler.com/topics/c/c-compiler-for-windows/\nAlternatively, you can install WSL or a Virtual Machine to have a Linux-like environment.\n"},{"id":1,"href":"/posts/linux_tools_course/","title":"Linux Tools Course","section":"Resources","content":"To get familiar with Linux tools that are generally helpful for computer science, please go through the material here: https://missing.csail.mit.edu/\n"},{"id":2,"href":"/posts/video_lectures/","title":"Video Lectures from Elsewhere","section":"Resources","content":"You can find some video lectures on c programming from other universities bellow:\nUni. of Nebraska, Lincon Harvard\nhttps://cs50.harvard.edu/x/2023/\nhttps://www.youtube.com/watch?v=8mAITcNt710 "},{"id":3,"href":"/docs/course_material/assignments/assignment1/","title":"Assignment - 1","section":"Assignments","content":" Assignment 1 # Question 1 # Problem Description # Given an integer n as input, print its binary representation starting with the most significant bit, i.e. don\u0026rsquo;t print the 0\u0026rsquo;s before the first 1.\nLink to problem on OJ\nInput constraints # \\(0 \\le n \\le 2^{30}\\) Input format # The only line of input contains a single integer n\nOutput Format # Output a continous stream of bits of n starting from the most significant bit.\nSample input and output # Sample Input Sample Output 11 1011 0 0 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); if (x==0){ printf(\u0026#34;0\u0026#34;); return 0; } int mask = 1 \u0026lt;\u0026lt; 30; int flag_first_one = 0; while (mask) { if (x \u0026amp; mask) { printf(\u0026#34;1\u0026#34;); flag_first_one = 1; } else if (flag_first_one) { printf(\u0026#34;0\u0026#34;); } mask \u0026gt;\u0026gt;= 1; } return 0; } Question 2 # Problem Description # Given an integer n between 2 and 100 as input, print all prime numbers from 1 to n (including n) in ascending order.\nLink to problem on OJ\nInput constraints # \\(2 \\le n \\le 100\\) Input format # The only line of input contains a single integer n.\nOutput Format # Output all primes that are less than or equal n in ascending order separated by spaces\nSample input and output # Sample Input Sample Output 2 2 6 2 3 5 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 2; i \u0026lt;= n; i++) { if (i == 2 || i == 3 || i == 5 || i == 7) { printf(\u0026#34;%d \u0026#34;, i); } else if (i % 2 != 0 \u0026amp;\u0026amp; i % 3 != 0 \u0026amp;\u0026amp; i % 5 != 0 \u0026amp;\u0026amp; i % 7 != 0) { printf(\u0026#34;%d \u0026#34;, i); } } return 0; } Question 3 # Problem Description # You are given width and height of a rectangle and you need to print that rectangle.\nLook at samples for more clarity.\nThe corners are to be represented by 'o'.\nThe vertical sides are represented by '|'\nThe horizontal sides are represented by '-'\nThe 'o' counts towards both height and width.\nLink to problem on OJ\nInput constraints # \\(1\\leq width\\leq 1000, 1\\leq height\\leq1000\\) Input format # Two space separated integers, width and height.\nOutput Format # Print the rectangle with the given width and height.\nSample input and output # Sample Input Sample Output 4 5 o--o\n| |\n| |\n| |\no--o 1 1 o 1 3 o\n|\no 3 2 o-o\no-o Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int width, height; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;width, \u0026amp;height); for (int i = 1; i \u0026lt;= height; i++) { for (int j = 1; j \u0026lt;= width; j++) { if ((i == 1 \u0026amp;\u0026amp; (j == 1 || j == width)) || (i == height \u0026amp;\u0026amp; (j == 1 || j == width))) printf(\u0026#34;o\u0026#34;); else if (j == 1 || j == width) printf(\u0026#34;|\u0026#34;); else if (i == 1 || i == height) printf(\u0026#34;-\u0026#34;); else printf(\u0026#34; \u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } return 0; } Question 4 # Problem Description # You are given three integers n, x and y. You need to print the first n terms of the sequence S which starts with \\(S_1=x\\) and \\(S_2=y\\) and further terms are derived from the relation \\(S_i = S_{i-1} \u0026#43; S_{i-2}\\) .\nThe first n values of S are guaranteed to fit in int Link to problem on OJ\nInput constraints # \\(1 \\le n \u0026lt; 50\\) \\(0\\leq x,y\\leq 1e5\\) \\(\\) Input format # The only line of input contains 3 space separated integers n, x and y.\nOutput Format # Output one line containing n space-seperated integers, denoting the first n terms of the sequence S.\nSample input and output # Sample Input Sample Output 5 1 2 1 2 3 5 8 Solution # #include \u0026lt;stdio.h\u0026gt; int main(){ int n, x, y; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;n, \u0026amp;x, \u0026amp;y); for (int i = 1; i \u0026lt;= n; i++) { if(i == 1)printf(\u0026#34;%d \u0026#34;, x); else if(i == 2)printf(\u0026#34;%d \u0026#34;, y); else{ int z = x + y; printf(\u0026#34;%d \u0026#34;, z); x = y; y = z; } } return 0; } Question 5 # Problem Description # Kushagra is in love with pairs. He has a list of numbers where each number has a duplicate pair. Unfortunately, there is one number that does not have a pair. Help him figure out which number it is.\nLink to problem on OJ\nInput constraints # \\(3 \\le n \\le 10^{6}\\) \\(1 \\le A_i \\le 10^{9}\\) \\(\\) Input format # The first line contains an integer n denoting the numbers present in the list.\nThe second line contains n space-separated integers \\([A_0, A_1, A_2,... A_{n-1}]\\) .\nOutput Format # A single integer, the number in the array without a pair\nSample input and output # Sample Input Sample Output 5\n4 5 6 4 5 6 7\n3 3 3 3 3 2 2 3 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int ans = 0; for(int i = 1; i \u0026lt;= n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); ans ^= x; } printf(\u0026#34;%d\\n\u0026#34;, ans); } "},{"id":4,"href":"/docs/course_material/assignments/assignment2/","title":"Assignment - 2","section":"Assignments","content":" Assignment 2 # Question 1 - \u0026ldquo;Doubling Investments\u0026rdquo; # Problem Description # Mitansh is world’s best investor. Whatever the amount he has today, it doubles on the next day.\nInitially he starts, with amount zero. Each day in the morning, he can choose to invest \\(\\$x\\) more in addition to his previous amount \\(\\$y\\) . And on next day, his total amount becomes \\(\\$2(x\u0026#43;y)\\) .\nHowever, he wants to get exactly \\(\\$z\\) on some day.\nWhat is the minimum amount of money he needs to invest, in order to get \\(\\$z\\) at some moment?\nLink to problem on OJ\nInput Format # The first and only line of input contains a single integer \\(z\\) which denotes the desired amount.\nInput constraints # \\(0 \\le z \\le 10^9\\) Output Format # On a single line, output the minimum amount of money that needs to be invested, in order to get exactly \\(\\$z\\) on some day.\nSample inputs and outputs # Sample Input 1\n7 Sample Output 1\n3 Explanation: Mitansh will invest \\(\\$1\\) on the \\(1^{st}\\) , \\(2^{nd}\\) and \\(3^{rd}\\) days. At the beginning of the second day he has \\(\\$2\\) (thanks to the \\(\\$1\\) doubling). He invests \\(\\$1\\) again, leading to the amount being \\(\\$3 \\times 2 = \\$6\\) at the beginning of the third day. He again invests \\(\\$1\\) to obtain the desired amount of \\(\\$7\\) .\nSample Input 2\n16 Sample Output 2\n1 Explanation: Mitansh invests \\(\\$1\\) on the first day which doubles four times to obtain \\(\\$16\\) .\nSample Input 3\n0 Sample Output 3\n0 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n, count = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while(n != 0) { count += (n % 2); n /= 2; } printf(\u0026#34;%d\\n\u0026#34;, count); return 0; } Question 2 - \u0026ldquo;Rotate Edges\u0026rdquo; # Problem Description # Kitansh Mayathwal was thinking of an easy problem which he can apply MOSS on. He came up with this problem.\nYou are given a grid with \\(N\\) rows and \\(N\\) columns. An integer \\(A_{i,j}\\) is written on the square at the \\(i\\) -th row from the top and \\(j\\) -th column from the left. Here, it is guaranteed that \\(A_{i,j}\\) is either 0 or 1.\nAn integer \\(D\\) is also given as input. It is guaranteed that \\(D\\) is either 0 or 1.\nIf \\(D = 0\\) , shift the integers written on the outer squares anticlockwise by one square each, and print the resulting grid.\nIf \\(D = 1\\) . shift the integers written on the outer squares clockwise by one square each, and print the resulting grid.\nHere, the outer squares are those for which at least one of the following conditions is true:\nThe square is present on the first row The square is present on the \\(N\\) -th row The square is present on the first column The square is present on the \\(N\\) -th column Link to problem on OJ\nInput Format # The first line of input contains a single integer \\(N\\) that denotes the size of the grid. The next \\(N\\) lines describe the grid.\nThe \\(i^{th}\\) line describes the \\(i^{th}\\) row of the grid, \\(A_{i, 1}, A_{i, 2}, \\dots, A_{i, N}\\) .\nThe final line of input contains a single integer \\(D\\) which denotes the direction of rotation.\nIn other words, the input is in the following format\nN A_1,1 A_1,2 ... A_1,N A_2,1 A_2,2 ... A_2,N ... A_N,1 A_N,2 ... A_N,N D Input constraints # \\(2 \\le N \\le 100\\) \\(0 \\le A_{i, j} \\le 1 (1 \\le i, j \\le N)\\) \\(0 \\le D \\le 1\\) Output Format # Output the appropriately rotated grid \\(B\\) in the following format:\nB_1,1 B_1,2 ... B_1,N B_2,1 ... ... B_N,1 B_N,2 ... B_N,N Sample inputs and outputs # Sample Input 1\n3 1 1 1 0 1 0 1 0 1 1 Sample Output 1\n0 1 1 1 1 1 0 1 0 Sample Input 2\n3 1 1 1 0 1 0 1 0 1 0 Sample Output 2\n1 1 0 1 1 1 0 1 0 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int a[n][n]; for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; n; j++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); int d; scanf(\u0026#34;%d\u0026#34;, \u0026amp;d); int b[n][n]; if (d) { for (int j = 1; j \u0026lt; n; j++) b[0][j] = a[0][j - 1]; for (int i = 1; i \u0026lt; n; i++) b[i][n - 1] = a[i - 1][n - 1]; for (int j = 0; j \u0026lt; n - 1; j++) b[n - 1][j] = a[n - 1][j + 1]; for (int i = 0; i \u0026lt; n - 1; i++) b[i][0] = a[i + 1][0]; } else { for (int j = 0; j \u0026lt; n - 1; j++) b[0][j] = a[0][j + 1]; for (int i = 0; i \u0026lt; n - 1; i++) b[i][n - 1] = a[i + 1][n - 1]; for (int j = 1; j \u0026lt; n; j++) b[n - 1][j] = a[n - 1][j - 1]; for (int i = 1; i \u0026lt; n; i++) b[i][0] = a[i - 1][0]; } for (int i = 1; i \u0026lt;= n - 2; i++) for (int j = 1; j \u0026lt;= n - 2; j++) b[i][j] = a[i][j]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) printf(\u0026#34;%d \u0026#34;, b[i][j]); printf(\u0026#34;\\n\u0026#34;); } return 0; } Question 3 - \u0026ldquo;Open Doors\u0026rdquo; # Problem Description # Madhav is a very lazy boy. He doesn’t like to do sports. So our PEC instructor has assigned him a task which he should complete in an hour. There are \\(n\\) doors which are all closed initially. Madhav should perform \\(n\\) iterations. In the \\(i^\\text{th}\\) iteration he starts from \\(i^\\text{th}\\) door and goes to each multiple of \\(i\\) untill \\(n\\) i.e. \\((i, 2*i, 3*i…..)\\) and toggles the door. Here toggles means if the door is open, he will close it and if it is closed he will open it.\nAfter all \\(n\\) iterations he has to tell which all doors are still opened. As Madhav is smart, he tries to solve this task using some program. Can you help him with this task ?\nLink to problem on OJ\nInput Format # You will be given only one integer \\(n\\) which are the number of doors.\nInput constraints # \\(1 \\leq n \\leq 10^{10}\\) Subtask 1 : (45 points)\n\\(1 \\leq n \\leq 10^3\\) Subtask 2 : (55 points)\nOriginal Constraints\nOutput Format # Print the open door numbers in increasing order.\nSample inputs and outputs # Sample Input 1\n1 Sample Output 1\n1 Sample Input 2\n4 Sample Output 2\n1 4 Solution # #include\u0026lt;stdio.h\u0026gt; int main() { long long n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); for(int i = 1; 1ll * i * i \u0026lt;= n; i++) printf(\u0026#34;%lld \u0026#34;, i * i); printf(\u0026#34;\\n\u0026#34;); return 0; } Question 4 - \u0026ldquo;Count Palindromes\u0026rdquo; # Problem Description # Given an array \\(A\\) of length \\(N\\) , count the number of non-empty subarrays which are palindromes.\nNote that two subarrays are considered to be different if they either start at different indices or end at different indices. The actual elements in the two subarrays do not influence this.\nA subarray is a contiguous segment of the array which can be obtained be deleting one or more elements from the beginning or the end of the array.\nAn array is said to be a palindrome if it reads the same backwards and forwards. For example, \\([1, 2, 2, 1], [1], [1, 2, 1]\\) are all palindromic arrays.\nLink to problem on OJ\nInput Format # The first line of input contains a single integer \\(N\\) that denotes the size of the array.\nThe second line of input contains \\(N\\) space-separated integers \\(A_1, A_2, \\dots, A_N\\) that describe the array.\nInput constraints # \\(1 \\le N \\le 100\\) \\(0 \\le A_i \\le 10^9\\) Output Format # Output a single positive that denotes the count of the non-empty palindromic subarrays\nSample inputs and outputs # Sample Input 1\n4 1 2 2 1 Sample Output 1\n6 Explanation: The subarrays satisfying the given conditions are: \\([1], [2], [2], [1], [2, 2], [1, 2, 2, 1]\\) Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int a[n]; for (int i = 0; i \u0026lt; n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); int ans = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = i; j \u0026lt; n; j++) { int good = 1; int p = i, q = j; while (p \u0026lt; q) { if (a[p] != a[q]) { good = 0; break; } p++, q--; } ans += good; } } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } Question 5 - \u0026ldquo;PEC woes\u0026rdquo; # Problem Description # As you all know, no student in IIIT likes PEC because they make us do some strange things. Once, they assigned a task to Pratham. They spread some rectangles sheets on the football ground and asked Pratham to calculate the total area covered by the rectangular sheets.\nSo, the task is like you are given some rectangles which are parallel to X or Y axis. Specifically, the i-th sheet covers all points \\((x, y)\\) that satisfy \\(a_i≤x≤b_i\\) and \\(c_i≤y≤d_i\\) . You have to calculate the total area which is covered by the rectangular sheets.\nYou have to calculate the total area which is covered by the recatngular sheets. For more explanation, read the sample test case.\nLink to problem on OJ\nInput Format # First line contains an integer N which denotes the total number of rectangular sheets.\nThe following N lines contain : \\(a_i\\) \\(b_i\\) \\(c_i\\) \\(d_i\\) Input constraints # \\(1 \\leq N \\leq 100\\) \\(0 \\leq a_i \u0026lt; b_i \\leq 100\\) \\(0 \\leq c_i \u0026lt; d_i \\leq 100\\) Output Format # Output a single integer the area covered by rectangular sheets.\nSample inputs and outputs # Sample Input 1\n3 0 5 1 3 1 4 0 5 2 5 2 4 Sample Output 1\n20 Explanation: For an explanation of the sample input 1, refer to this link. We can count that the sheets cover 20 squares.\nSample Input 2\n3 0 1 0 1 0 3 0 5 5 10 0 10 Sample Output 2\n65 Solution # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); const int MAX_N = 101; int g[MAX_N][MAX_N]; memset(g, 0, sizeof(g)); while (n--) { int a, b, c, d; scanf(\u0026#34;%d %d %d %d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d); for (int i = c; i \u0026lt; d; i++) for (int j = a; j \u0026lt; b; j++) g[i][j] = 1; } int ans = 0; for (int i = 0; i \u0026lt;= 100; i++) for (int j = 0; j \u0026lt;= 100; j++) ans += g[i][j]; printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } "},{"id":5,"href":"/grading_scheme/","title":"Grading Scheme","section":"Introduction","content":" Grading Scheme # Assignments: 30% Quizzes: 20% (2 Quizzes worth 10% each) Mid-Semester Exam: 15% End-Semester Exam: 25% Labs: 10% Bonus*: 5% Note: Total score for a student would be capped at 100% (if the student\u0026rsquo;s score happens to exceed 100) "},{"id":6,"href":"/honor_code/","title":"Honor Code","section":"Introduction","content":" Honor Code # Any form of plagiarism in the Assignments or in the Lab Exams would be heavily penalised and would lead to a 0 score for both students, the student who copied and the one whose code was copied. It is solely your duty to ensure the safety of your code throughout the course .Thus, we will not be entertaining any requests after a student is found guilty of plagiarism.\n"},{"id":7,"href":"/docs/course_material/lectures/4_10/","title":"II.1 Typedef, Struct Initialization, Passing Pointers","section":"Lectures","content":" II.1 Typedef, Struct Initialization # Struct without Typedef # #include\u0026lt;stdio.h\u0026gt; struct rectangle { float length; float breadth; }; float compute_area(struct rectangle r) { return r.length * r.breadth; } void print_rectangle(struct rectangle r) { printf(\u0026#34;Rectangle with length %f and breadth %f\\n\u0026#34;, r.length, r.breadth); } int main() { struct rectangle rect = { 1.5, 3.2 }; // Initializer print_rectangle(rect); printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(rect) ); } Struct with Typedef # #include\u0026lt;stdio.h\u0026gt; typedef struct rectangle { float length; float breadth; } rectangle; float compute_area(rectangle r) { return r.length*r.breadth; } rectangle scale(rectangle r, float s) { r.length = r.length*s; r.breadth = r.breadth*s; return r; } int main() { rectangle rect = { .breadth = 1.0, .length = 3.0} /* {3.0, 1.0 }*/; // rect.length = 3.2; // rect.breadth = 1.2; printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(rect)); rectangle rp = scale(rect, 5); printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(*rp)); printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(rect)); } Passing using pointers # #include\u0026lt;stdio.h\u0026gt; typedef struct rectangle { float length; float breadth; } rectangle; float compute_area(rectangle r) { return r.length*r.breadth; } rectangle* scale(rectangle* r, float s) { r-\u0026gt;length = r-\u0026gt;length*s; r-\u0026gt;breadth = r-\u0026gt;breadth*s; return r; } int main() { rectangle rect = { .breadth = 1.0, .length = 3.0} /* {3.0, 1.0 }*/; // rect.length = 3.2; // rect.breadth = 1.2; printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(rect)); rectangle* rp = scale(\u0026amp;rect, 5); printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(*rp)); printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(rect)); } "},{"id":8,"href":"/docs/course_material/lectures/6_10/","title":"II.2 Strings and Enums","section":"Lectures","content":" II.2 Strings and Enums # Strings in C # as a pointer to char char *p = \u0026#34;abcde\u0026#34;; as an array of char char s[] = \u0026#34;abcde\u0026#34;; print(\u0026#34;%d %d\u0026#34;, sizeof(p), sizeof(s)); String Function Implementation # #include \u0026#34;stdio.h\u0026#34; int strlenB(char* s) { int i = 0; while (s[i] != \u0026#39;\\0\u0026#39;) { i++; } return i; } char* strcpyB(char *s, char *d) { int len_s = strlenB(s); for(int i = 0; i \u0026lt;= len_s;i++) { d[i] = s[i]; } return d; } char* str_rev(char *s, char *d) { int len_s = strlenB(s); for(int i = 0; i\u0026lt; len_s; i++) { d[i] = s[len_s - 1 - i]; } d[len_s] = \u0026#39;\\0\u0026#39;; return d; } int main() { char *p = \u0026#34;xyz\\0dsalkfjds\u0026#34;; char s[] = \u0026#34;abcde\\0kjdakfjsh\u0026#34;; // abcde\\0 // printf(\u0026#34;%d %d\\n\u0026#34;,sizeof(p),sizeof(s)); // printf(\u0026#34;%s %s\\n\u0026#34;,p, s); // printf(\u0026#34;%d %d\\n\u0026#34;, strlen(p), strlen(s)); // strcpy(s,p); printf(\u0026#34;%s\\n\u0026#34;,str_rev(p, s)); return 1; } String Functions # #include \u0026lt;string.h\u0026gt;\nint strlen(char *s): returns the length of the string pointed by s (ie lenth upto the first \\0 in memory). char* strcat(char* s1, char* s2): concatenates s1 with s2, stores it in s1 and returns s1. int strcmp(char *s1,char *s2): returns negative int if s1 is lex. smaller than s2, returns 0 if equal, returns positive int if s1 is lex. greater than s2. char* strcpy(char* s1, char* s2): copies s2 in to s1 and returns s1. Social Network # Name Age Rel Status Friends Alice 24 Single Diestel, Eve Bob 28 Maried Alice Charlie 20 Single Diestel Diestel 27 Not Mentioned Alice, Eve, Charlie Eve 25 Engaged Diestel, Alice Define a Person (Profile) # struct Person { char name[100]; int age; int rel_status; }; Implemeting Rel Status as int, requires us to keep in mind the mapping between Single, Maried, Not Mentioned, Engaged and integers.\nCan we specify this in code?? # Enums # typedef enum Weekday { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday } Weekday; Weekday today = Wednesday; printf(\u0026#34;Day %d\u0026#34;,today+1); printf(\u0026#34;Size of enum variable = %d bytes\u0026#34;, sizeof(today));\tEnums : Changing default values # typedef enum Weekday { Sunday = 1, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday } Weekday; Weekday today = Wednesday; printf(\u0026#34;Day %d\u0026#34;,today+1); Enums : interchangable with int # #include \u0026#34;stdio.h\u0026#34; typedef enum Weekday { Sunday = 5, Monday = 3, Tuesday, Wednesday = 2, Thursday, Friday, Saturday } Weekday; int main() { Weekday today = Wednesday;; printf(\u0026#34;Day %d\\n\u0026#34;,today+1); printf(\u0026#34;Size of enum variable = %d bytes\u0026#34;, sizeof(today));\treturn 0 ; } Define a Person (Profile) # enum RelStatus { NotMentioned, Single, Engaged, Married }; struct Person { char name[100]; int age; enum RelStatus status; }; Practice Problems # Implement str_rev in place. ie. it takes only one string (char *) as argument, reverses it. "},{"id":9,"href":"/docs/course_material/lectures/9_10/","title":"II.3 Macros, More Intializers in Social Nets","section":"Lectures","content":" II.3 Macros, More Intializers in Social Nets # Social Nets # typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Person { char name[100]; int age; RelStatus relstatus; struct Person* friends[5]; } Person; typedef struct SocialNet { Person members[100]; int size; } SocialNet; Social Nets with Macros # #define MAX_FRIENDS 5 #define MAX_MEMBERS 100 #define MAX_NAME_LEN 100 typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Person { char name[MAX_NAME_LEN]; int age; RelStatus relstatus; struct Person* friends[MAX_FRIENDS]; } Person; typedef struct SocialNet { Person members[MAX_MEMBERS]; int size; } SocialNet; Intitializer # Name Age Rel Status Alice 24 Not Mentioned Bob 28 Maried Charlie 20 Single int main() { SocialNet social_net = { .members = { { \u0026#34;Alice\u0026#34;, 24, NotMentioned}, { \u0026#34;Bob\u0026#34;, 28, Married}, { \u0026#34;Charlie\u0026#34;, 20, Single}, } , .size = 3 }; print_network(social_net); return 0; } Print Person # void print_person(struct Person p) { // TODO (solution at the end of page) } void print_network(SocialNet social_net) { printf( \u0026#34;----------------------------------------------\\n\u0026#34; \u0026#34;Name\\t\\tAge \\t Rel Status\\n\u0026#34; \u0026#34;----------------------------------------------\\n\u0026#34;); for (int i=0;i \u0026lt;social_net.size; i++) { print_person(social_net.members[i]); } printf(\u0026#34;----------------------------------------------\\n\u0026#34;); } Finding a person by name # Person* find_person(char* name1, SocialNet *sn) { // TODO (solution at the end of page) } HW: Check Mutual Friends by name # bool check_mutual_friends(char *name1, char *name2, SocialNet *sn) { // TODO p and q are mutual friends if q is in the friend list of p // and p is in the friend list of q } Full Code with Solutions # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Person { char name[100]; int age; RelStatus relstatus; int count_friends; struct Person *friends[5]; } Person; typedef struct SocialNet { Person members[80]; int size; } SocialNet; Person* find_person(char* name1, SocialNet *sn) { for(int i = 0; i \u0026lt; sn-\u0026gt;size; i++) { if ( strcmp(sn-\u0026gt;members[i].name, name1) == 0) { return \u0026amp;(sn-\u0026gt;members[i]); } } return NULL; } void print_person(Person p) { char status_string[][15] = { \u0026#34;Not Mentioned\u0026#34;, \u0026#34;Single\u0026#34;, \u0026#34;Married\u0026#34;, \u0026#34;Engaged\u0026#34; }; printf(\u0026#34;%s\\t\\t%d\\t%s\\n\u0026#34;, p.name, p.age, status_string[p.relstatus]); } void print_network(SocialNet social_net) { printf( \u0026#34;----------------------------------------------\\n\u0026#34; \u0026#34;Name\\t\\tAge \\t Rel Status\\n\u0026#34; \u0026#34;----------------------------------------------\\n\u0026#34;); for (int i=0;i \u0026lt;social_net.size; i++) { print_person(social_net.members[i]); } printf(\u0026#34;----------------------------------------------\\n\u0026#34;); } int main() { SocialNet social_net = { .members = { { \u0026#34;Alice\u0026#34;, 24, NotMentioned}, { \u0026#34;Bob\u0026#34;, 28, Married}, { \u0026#34;Charlie\u0026#34;, 20, Single}, } , .size = 3 }; print_network(social_net); print_person(*find_person(\u0026#34;Bob\u0026#34;, \u0026amp;social_net)); return 0; } "},{"id":10,"href":"/docs/course_material/lectures/11_10/","title":"II.4 Linked Lists","section":"Lectures","content":" II.4 Linked Lists # Problem: Large Arrays! # #define MAX_MEMBERS 100 typedef struct SocialNet { Person members[MAX_MEMBERS]; int size; } SocialNet; Linked List: A array that grows according to needs # Linked List: Code # typedef struct Node { Person data; struct Node* next; } Node; typedef Node* LinkedList; Node third = { {\u0026#34;Alice\u0026#34;, 22}, NULL }; Node second = { {\u0026#34;Bob\u0026#34;, 26}, \u0026amp;third }; Node first = { {\u0026#34;Charlie\u0026#34;, 20}, \u0026amp;second }; LinkedList L = \u0026amp;first; Size of a Liniked List # int size(LinkedList l) { int s = 0; while (l != NULL) { l = l-\u0026gt;next; s ++; } return s; } A recursive solution # int size(LinkedList l) { return l==NULL? 0: size(l-\u0026gt;next) + 1; } Printing elements of a linked list # void print_list(LinkedList l) { while (l != NULL) { printf(\u0026#34;%s\\t\\t%d\\n\u0026#34;,l-\u0026gt;data.name, l-\u0026gt;data.age); l = l-\u0026gt;next; } } Find the element at the ith position # Person* element_at(int pos, LinkedList l) { int s = 0; while (l != NULL) { if (s == pos) return \u0026amp;(l-\u0026gt;data); l = l-\u0026gt;next; s ++; } return NULL; } A recursive solution # Person* element_at_recursive(int pos, LinkedList l) { // TODO if (l==NULL) return NULL; if (pos == 0) {return \u0026amp;(l-\u0026gt;data);} else { return element_at(pos-1, l-\u0026gt;next); } // return pos == 0 ? \u0026amp;(l-\u0026gt;data): element_at(pos-1, l-\u0026gt;next); } Append element to end of the list # LinkedList append(Person p, LinkedList l) { // Node D = {{\u0026#34;Raj\u0026#34;, 18}, NULL}; Local Variable! Will not work. Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = NULL; if (l == NULL) return D; // if l is empty just return D. while (l-\u0026gt;next != NULL) { l = l-\u0026gt;next; } l-\u0026gt;next = D; return l; } Full code # #include \u0026#34;stdio.h\u0026#34; #include \u0026#34;stdlib.h\u0026#34; #define MAX_NAME_LEN 100 typedef struct Person { char name[MAX_NAME_LEN]; int age; } Person; typedef struct Node { Person data; struct Node* next; } Node; typedef Node* LinkedList; void print_list(LinkedList l) { printf(\u0026#34;-----------------------------------\\n\u0026#34;); while (l != NULL) { printf(\u0026#34;%s\\t\\t%d\\n\u0026#34;,l-\u0026gt;data.name, l-\u0026gt;data.age); l = l-\u0026gt;next; } printf(\u0026#34;-----------------------------------\\n\u0026#34;); } int size(LinkedList l) { int s = 0; while (l != NULL) { l = l-\u0026gt;next; s ++; } return s; // Simpler recursive solution // return l==NULL? 0: size(l-\u0026gt;next) + 1; } Person* element_at(int pos, LinkedList l) { int s = 0; while (l != NULL) { if (s == pos) return \u0026amp;(l-\u0026gt;data); l = l-\u0026gt;next; s ++; } return NULL; } Person* element_at_recursive(int pos, LinkedList l) { // TODO if (l==NULL) return NULL; if (pos == 0) {return \u0026amp;(l-\u0026gt;data);} else { return element_at(pos-1, l-\u0026gt;next); } // return pos == 0 ? \u0026amp;(l-\u0026gt;data): element_at(pos-1, l-\u0026gt;next); } LinkedList append(Person p, LinkedList l) { // Node D = {{\u0026#34;Raj\u0026#34;, 18}, NULL}; Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = NULL; if (l == NULL) return D; while (l-\u0026gt;next != NULL) { l = l-\u0026gt;next; } l-\u0026gt;next = D; return l; } int main() { Node third = { {\u0026#34;Alice\u0026#34;, 22}, NULL }; Node second = { {\u0026#34;Bob\u0026#34;, 26}, \u0026amp;third }; Node first = { {\u0026#34;Charlie\u0026#34;, 20}, \u0026amp;second }; Person D = {\u0026#34;Raj\u0026#34;, 18}; LinkedList l = \u0026amp;first; printf(\u0026#34;Size of the list is %d\\n\u0026#34;, size(l)); print_list(l); printf(\u0026#34;Element at 1st position: %s\\n\u0026#34;, element_at(1,l)-\u0026gt;name); printf(\u0026#34;Element at 2nd position: %s\\n\u0026#34;, element_at(2,l)-\u0026gt;name); append(D, l); printf(\u0026#34;List after appending\\n\u0026#34;); print_list(l); return 0; } HW: Insert element at a position in the list # LinkedList insert(Person p, int pos, LinkedList l) { // TODO } HW: Concatenate 2 lists # LinkedList concat(LinkedList l1, LinkedList l2) { // TODO } HW: Reverse a list # LinkedList reverse(LinkedList l) { // TODO } "},{"id":11,"href":"/docs/course_material/lectures/16_10/","title":"II.5 Linked Lists Problems","section":"Lectures","content":" II.5 Linked Lists Problems # Insert element at a position in the list # LinkedList insert(Person p, int pos, LinkedList l) { if (pos == 0) { Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = l; return D; } else { l-\u0026gt;next = insert(p, pos-1, l-\u0026gt;next); return l; } } Concatenate 2 lists # LinkedList concat(LinkedList l1, LinkedList l2) { if (l1 == NULL) { return l2; } else { l1-\u0026gt;next = concat(l1-\u0026gt;next, l2); return l1; } } Reverse a list # LinkedList reverse(LinkedList l) { int s = size(l); LinkedList l2 = NULL; for (int i = 0; i \u0026lt; s; i++) { l2 = insert(*element_at(s-i-1, l), i, l2); } return l2; } Full code # #include \u0026#34;stdio.h\u0026#34; #include \u0026#34;stdlib.h\u0026#34; #define MAX_NAME_LEN 100 typedef struct Person { char name[MAX_NAME_LEN]; int age; } Person; typedef struct Node { Person data; struct Node* next; } Node; typedef Node* LinkedList; void print_list(LinkedList l) { printf(\u0026#34;-----------------------------------\\n\u0026#34;); while (l != NULL) { printf(\u0026#34;%s\\t\\t%d\\n\u0026#34;,l-\u0026gt;data.name, l-\u0026gt;data.age); l = l-\u0026gt;next; } printf(\u0026#34;-----------------------------------\\n\u0026#34;); } int size(LinkedList l) { int s = 0; while (l != NULL) { l = l-\u0026gt;next; s ++; } // Single line recursive solution // return l == NULL? 0 ; 1 + size(l-\u0026gt;next); return s; } Person* element_at(int pos, LinkedList l) { int s = 0; while (l != NULL) { if (s == pos) return \u0026amp;(l-\u0026gt;data); l = l-\u0026gt;next; s ++; } return NULL; } LinkedList append(Person p, LinkedList l) { if (l == NULL) { // Node D = {{\u0026#34;Raj\u0026#34;, 18}, NULL}; Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = NULL; return D; } else { l-\u0026gt;next = append(p, l-\u0026gt;next); } return l; } LinkedList insert(Person p, int pos, LinkedList l) { if (pos == 0) { Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = l; return D; } else { l-\u0026gt;next = insert(p, pos-1, l-\u0026gt;next); return l; } } LinkedList concat(LinkedList l1, LinkedList l2) { if (l1 == NULL) { return l2; } else { l1-\u0026gt;next = concat(l1-\u0026gt;next, l2); return l1; } } LinkedList reverse(LinkedList l) { int s = size(l); LinkedList l2 = NULL; for (int i = 0; i \u0026lt; s; i++) { l2 = insert(*element_at(s-i-1, l), i, l2); } return l2; } int main() { Node third = { {\u0026#34;Alice\u0026#34;, 22}, NULL }; Node second = { {\u0026#34;Bob\u0026#34;, 26}, \u0026amp;third }; Node first = { {\u0026#34;Charlie\u0026#34;, 20}, \u0026amp;second }; Person D = {\u0026#34;Raj\u0026#34;, 18}; Node l2 = { D, NULL}; LinkedList l = \u0026amp;first; printf(\u0026#34;Size of the list is %d\\n\u0026#34;, size(l)); print_list(l); l = concat( \u0026amp;l2,l); print_list(l); print_list(reverse(l)); // print_list(insert(D,2,l)); // printf(\u0026#34;Element at 1st position: %s\\n\u0026#34;, element_at(1,l)-\u0026gt;name); // printf(\u0026#34;Element at 2nd position: %s\\n\u0026#34;, element_at(2,l)-\u0026gt;name); // append(D, l); // printf(\u0026#34;List after appending\\n\u0026#34;); // print_list(l); return 0; } HW: Reverse a LinkedList in place # void reverse_inplace(LinkedList l) { // If l is a-\u0026gt;b-\u0026gt;c-\u0026gt;d // after executing reverse_inplace(l) // l should become d-\u0026gt;c-\u0026gt;b-\u0026gt;a // the function also should not use another linkedlist or array } HW: Shuffle 2 lists # LinkedList shuffle(LinkedList l1, LinkedList l2) { // If l1 is a-\u0026gt;b-\u0026gt;c-\u0026gt;d and l2 is 1-\u0026gt;2-\u0026gt;3-\u0026gt;4 // shuffle(l1,l2) should return the list // a-\u0026gt;1-\u0026gt;b-\u0026gt;2-\u0026gt;c-\u0026gt;3-\u0026gt;d-\u0026gt;4 } Can you make the above function also in place? That is it should not use any additional array or linked list other than l1 and l2. # HW: Free memory in a LinkedList # void free(LinkedList l) { // free all memory used by a linked list l } HW: Sort a LinkedList # LinkedList sort(LinkedList l) { // sort the linked list l and return it. } HW: Write the social network program using LinkedList # Use a Linked list instead of array in the social network program to save memory. You can used a linked list instead of the members array in Social Net. Can we replace the friends array (in Person) also with a LinkedList?\ntypedef struct Person { char name[100]; int age; RelStatus relstatus; int count_friends; Person* friends[5]; } Person; typedef struct SocialNet { struct Person members[100]; int size; } SocialNet; Implement the check_mutual_friendship function from the last days homework with the social network made using linked lists.\nSolution: Shuffle in place # LinkedList shuffle_inplace(LinkedList l1, LinkedList l2) { Node* head = l1; Node* temp1; Node* temp2; while (l1 != NULL \u0026amp;\u0026amp; l2 != NULL) { temp1 = l1-\u0026gt;next; temp2 = l2-\u0026gt;next; l1-\u0026gt;next = l2; if (temp1 == NULL) { break; } l2-\u0026gt;next = temp1; l1 = temp1; l2 = temp2; } return head; } "},{"id":12,"href":"/docs/course_material/lectures/18_10/","title":"II.6 More Linked List Problems","section":"Lectures","content":" II.6 More Linked List Problems # Reverse a LinkedList in place # LinkedList node_append(Node* n, LinkedList l) { if (l == NULL) { return n; } else { l-\u0026gt;next = node_append(n, l-\u0026gt;next); return l; } } // Recursive Solution LinkedList reverse_in_place(LinkedList l) { if (l == NULL) { return l; } else { LinkedList rev = reverse_in_place(l-\u0026gt;next); l-\u0026gt;next = NULL; rev = node_append(l, rev); return rev; } } HW: Shuffle 2 lists # LinkedList shuffle(LinkedList l1, LinkedList l2) { // If l1 is a-\u0026gt;b-\u0026gt;c-\u0026gt;d and l2 is 1-\u0026gt;2-\u0026gt;3-\u0026gt;4 // shuffle(l1,l2) should return the list // a-\u0026gt;1-\u0026gt;b-\u0026gt;2-\u0026gt;c-\u0026gt;3-\u0026gt;d-\u0026gt;4 } Can you make the above function also in place? That is it should not use any additional array or linked list other than l1 and l2. # Free memory in a LinkedList # void free_linked_list(LinkedList l) { if (l == NULL) { return; } else { LinkedList tail = l-\u0026gt;next; free(l); free_linked_list(tail); } } Sort a LinkedList # // assuming a \u0026lt; b // swaping is done by copy the data field in Node LinkedList swap(LinkedList l, int a, int b) { LinkedList head = l; Person temp; Node* a_ptr; Node* b_ptr; // Find above while(a \u0026gt;= 1) { l = l-\u0026gt;next; a--; b--; } a_ptr = l; while(b \u0026gt;= 1) { l = l-\u0026gt;next; b--; } b_ptr = l; temp = a_ptr-\u0026gt;data; a_ptr-\u0026gt;data = b_ptr-\u0026gt;data; b_ptr-\u0026gt;data = temp; return head; } LinkedList sort(LinkedList l) { // sort the linked list l and return it. // use swap to implement sorting } Write the social network program using LinkedList # Use a Linked list instead of array in the social network program to save memory. You can used a linked list instead of the members array in Social Net. Can we replace the friends array (in Person) also with a LinkedList?\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Person { char name[100]; int age; RelStatus relstatus; int count_friends; struct Person* friends[5]; } Person; typedef struct Node { Person data; struct Node* next; } Node; typedef Node* LinkedList; typedef struct SocialNet { LinkedList members; int size; } SocialNet; void print_person(struct Person p) { char status_string[][20] = { \u0026#34;Not Mentioned\u0026#34;, \u0026#34;Single\u0026#34;, \u0026#34;Engaged\u0026#34;, \u0026#34;Married\u0026#34; }; printf(\u0026#34;%s\\t\\t%d\\t%s\\t\\t\\t\u0026#34;, p.name, p.age, status_string[p.relstatus]); for (int i = 0; i \u0026lt; p.count_friends; i++) { printf(\u0026#34;%s, \u0026#34;,p.friends[i]-\u0026gt;name); } printf(\u0026#34;\\n\u0026#34;); } void print_network(SocialNet social_net) { LinkedList l = social_net.members; printf( \u0026#34;-------------------------------------------------------------------\\n\u0026#34; \u0026#34;Name\\t\\tAge \\tRel Status\\t\\tFriends\\n\u0026#34; \u0026#34;-------------------------------------------------------------------\\n\u0026#34;); while (l!=NULL) { print_person(l-\u0026gt;data); l = l-\u0026gt;next; } printf( \u0026#34;-------------------------------------------------------------------\\n\u0026#34;); } Person* find_person(char* name, SocialNet *sn) { // TODO LinkedList l = sn-\u0026gt;members; while(l!= NULL) { if (strcmp(l-\u0026gt;data.name, name) == 0) { return \u0026amp;(l-\u0026gt;data); } l = l-\u0026gt;next; } return NULL; } bool check_mutual_friendship(char* name1, char* name2, SocialNet* sn) { Person* p = find_person(name1, sn); Person* q = find_person(name2, sn); bool q_in_fl_of_p = false; bool p_in_fl_of_q = false; for(int i =0; i\u0026lt; p-\u0026gt;count_friends; i++) { if (q == p-\u0026gt;friends[i]) { q_in_fl_of_p = true; } } for(int i =0; i\u0026lt; q-\u0026gt;count_friends; i++) { if (p == q-\u0026gt;friends[i]) { p_in_fl_of_q = true; } } if (p_in_fl_of_q \u0026amp;\u0026amp; q_in_fl_of_p) { return true; } else { return false; } } LinkedList append(Person p, LinkedList l) { if (l == NULL) { // Node D = {{\u0026#34;Raj\u0026#34;, 18}, NULL}; Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = NULL; return D; } else { l-\u0026gt;next = append(p, l-\u0026gt;next); } return l; } Person* element_at(int pos, LinkedList l) { int s = 0; while (l != NULL) { if (s == pos) return \u0026amp;(l-\u0026gt;data); l = l-\u0026gt;next; s ++; } return NULL; } int main() { SocialNet social_net = { .members=NULL, .size = 0 }; Person A = { \u0026#34;Alice\u0026#34;, 24, Single, 2 }; Person B = { \u0026#34;Bob\u0026#34;, 20, Engaged, 0 }; Person C = { \u0026#34;Charlie\u0026#34;, 26, Married, 1 }; social_net.members = append( A,social_net.members); social_net.members = append( B,social_net.members); social_net.members = append( C,social_net.members); //social_net.members[0].friends[0] = \u0026amp;(social_net.members[1]); // social_net.members[0].friends[1] = \u0026amp;(social_net.members[2]); social_net.members-\u0026gt;data.friends[0] = element_at(1, social_net.members); social_net.members-\u0026gt;data.friends[1] = element_at(2, social_net.members); // social_net.members[2].friends[0] = \u0026amp;(social_net.members[1]); element_at(2, social_net.members)-\u0026gt;friends[0] = element_at(0, social_net.members); print_network(social_net); print_person(*find_person(\u0026#34;Alice\u0026#34;, \u0026amp;social_net)); print_person(*find_person(\u0026#34;Bob\u0026#34;, \u0026amp;social_net)); print_person(*find_person(\u0026#34;Charlie\u0026#34;, \u0026amp;social_net)); printf(\u0026#34;Is Alice and Charlie mutual friends: %d\\n\u0026#34;,check_mutual_friendship(\u0026#34;Alice\u0026#34;, \u0026#34;Charlie\u0026#34;, \u0026amp;social_net)); printf(\u0026#34;Is Alice and Bob mutual friends: %d\\n\u0026#34;,check_mutual_friendship(\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026amp;social_net)); return 0; } Implement the check_mutual_friendship function from the last days homework with the social network made using linked lists.\nSolution: Shuffle in place # LinkedList shuffle_inplace(LinkedList l1, LinkedList l2) { Node* head = l1; Node* temp1; Node* temp2; while (l1 != NULL \u0026amp;\u0026amp; l2 != NULL) { temp1 = l1-\u0026gt;next; temp2 = l2-\u0026gt;next; l1-\u0026gt;next = l2; if (temp1 == NULL) { break; } l2-\u0026gt;next = temp1; l1 = temp1; l2 = temp2; } return head; } "},{"id":13,"href":"/docs/course_material/labs/lab1/","title":"Lab - 1","section":"Labs","content":" Lab 1 (Week of 14 August) # Question 1 - \u0026ldquo;The Last 3\u0026rdquo; # Problem Description # Given an integer n as input, print the last 3 bits of the number in its binary representation starting with the most significant bit among the three.\nNote: The last three bits are the bits corresponding to the,\n\\( 2^2, 2^1 \\) and \\( 2^0 \\) positions (in that order) Link to problem on OJ\nInput constraints # \\(0 \\le n \\le 2^{31}\\) Input format # The only line of input contains a single integer n\nOutput Format # Output three space-separated bits denoting the last three bits of the given number starting with the most significant bit among the three.\nSample input and output # Sample Input Sample Output 11 0 1 1 12 1 0 0 Solution # #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;%d %d %d\\n\u0026#34;, !!(n \u0026amp; 1), !!(n \u0026amp; 2), !!(n \u0026amp; 4)); return 0; } Question 2 - \u0026ldquo;Date Formats\u0026rdquo; # Problem Description # Given a date in DD-MM-YY format, output it in MM-DD-YY format.\nLink to problem on OJ\nInput format # The only line of input contains a valid date in DD-MM-YY format.\nOutput Format # Output the date in MM-DD-YY format with no space separation.\nSample input and output # Sample Input Sample Output 25-03-04 03-25-04 15-08-23 08-15-23 Solution # #include \u0026lt;stdio.h\u0026gt; int main(void) { int d, m, y; scanf(\u0026#34;%d-%d-%d\u0026#34;, \u0026amp;d, \u0026amp;m, \u0026amp;y); printf(\u0026#34;%02d-%02d-%02d\\n\u0026#34;, m, d, y); return 0; } "},{"id":14,"href":"/docs/course_material/labs/lab2/","title":"Lab - 2","section":"Labs","content":" Lab 2 (Week of 21 August) # Question 1 - \u0026ldquo;Divisibility By 3\u0026rdquo; # Problem Description # Given an integer which has n digits, print YES if it is divisible by 3, and NO otherwise.\nNote: The input number will not contain any leading zeroes. Link to problem on OJ\nInput constraints # \\(0 \\le n \\le 1000\\) Input format # The first line of input contains a single integer n denoting the number of digits.\nThe second line of input contains the integer which is n digit long.\nOutput Format # Output YES if the number is divisible by 3 and NO otherwise.\nSample input and output # Sample Input Sample Output 10 1234567890 YES 2 22 NO Solution # #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); char c; scanf(\u0026#34;%c\u0026#34;, \u0026amp;c); //Skips the initial new line character int sum = 0; while (n--) { scanf(\u0026#34;%c\u0026#34;, \u0026amp;c); sum += c - \u0026#39;0\u0026#39;; } if (sum % 3) printf(\u0026#34;NO\\n\u0026#34;); else printf(\u0026#34;YES\\n\u0026#34;); return 0; } Question 2 - \u0026ldquo;K-Swap\u0026rdquo; # Problem Description # You are given three non-negative integers x, y and k where \\(0 \\le k \\le 31\\) . Replace the first k bits (from the right) of x with the first k bits of y and print the new value of x. In other words, replace the k least significant bits of x with the corresponding bits from y.\nLink to problem on OJ\nInput constraints # \\(0 \\le x,y \\le 2^{31}\\) \\(0 \\le k \\le 31\\) Input format # The only line of input contains 3 space-separated integers x, y and k.\nOutput Format # Output a single integer denoting the new value of x\nSample input and output # Sample Input Sample Output 11 22 3 14 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int x, y, k; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;k); x \u0026amp;= (~0 \u0026lt;\u0026lt; k); y \u0026amp;= ~(~0 \u0026lt;\u0026lt; k); printf(\u0026#34;%d\\n\u0026#34;, x | y); return 0; } "},{"id":15,"href":"/docs/course_material/labs/lab3/","title":"Lab - 3","section":"Labs","content":" Lab 3 (Week of 4 September) # Question 1 - \u0026ldquo;Club Recruitments\u0026rdquo; # Problem Description # A new student club is organising a huge event this semester for silver jubilee celebrations. Initially, they don\u0026rsquo;t have enough members. So, they started recruiting new members in groups.\nMeanwhile, tasks keep coming up within the club. Each club member can work on only one task during the semester.\nIf there is no member available (isn\u0026rsquo;t occupied with a task) when a task arises, it will remain unattended regardless of whether new individuals are recruited later on.\nGiven the chronological order of task arrivals and club members’ recruitment, find the number of tasks that will remain unattended.\nIn the input, a -1 denotes the arrival of a task (which may or may not go unattended depending on whether or not there are currently any free members to take up the task). Similarly, a non-neagative number denotes the number of new recruits.\nNote that once an individual is recruited for the club, they\u0026rsquo;ll always be part of the club. When an individual takes up a task, they\u0026rsquo;ll be occupied with it for the rest of the semester.\nLink to problem on OJ\nInput constraints # \\(1 \\le N \\le 2 \\times 10^5\\) \\(A_i \\in [-1, 10]\\) Input format # The first line of input contains a single integer N that denotes the number of events (either task arrival or new recruitment).\nThe second line of input contains N space-separated integers \\(A_1, A_2, \\dots, A_N\\) that describe the N events as explained in the description.\nOutput Format # Output a single integer that denotes the number of unattended tasks.\nSample input and output # Sample Input Sample Output 3 -1 -1 -1 2 11 -1 -1 2 -1 -1 -1 -1 -1 -1 -1 -1 8 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int pref = 0, ans = 0; for (int i = 0; i \u0026lt; n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); pref += x; if (pref \u0026lt; 0) ans++, pref = 0; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } Question 2 - Current Max # Problem Description # You are given a sequence of N integers \\(A_1,A_2,...,A_N \\) and while looking at the sequence in order from left to right (that is, from index 1 to N), you start by crossing the first number, and you cross a subsequent number if it is strictly greater than every number you crossed before. You keep crossing until you reach the end of the sequence.\nOutput all the numbers you have crossed.\nLink to problem on OJ\nInput constraints # \\(1 \\le N \\le 2 \\times 10^5\\) \\(0 \\le A_i \\le 10^9\\) Input format # The first line of input contains a single integer N that denotes the size of the array.\nThe second line of input contains N space-separated integers \\(A_1,A_2,...,A_N \\) that describe the N elements.\nOutput Format # On the first line, output the count of numbers that you cross out, K. Note that this is a positive number since the first number is always crossed.\nOn the second line, output K space-separated integers denoting the numbers crossed out in the order in which they appear in the original array.\nSample input and output # Sample Input Sample Output 7\n1 1 3 2 4 10 9 4\n1 3 4 10 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int final[n]; int sz = 0; for (int i = 0; i \u0026lt; n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); if (!sz || final[sz - 1] \u0026lt; x) final[sz++] = x; } printf(\u0026#34;%d\\n\u0026#34;, sz); for (int i = 0; i \u0026lt; sz; i++) printf(\u0026#34;%d \u0026#34;, final[i]); printf(\u0026#34;\\n\u0026#34;); return 0; } "},{"id":16,"href":"/docs/course_material/quizzes/midLab1/","title":"Mid-Sem Lab Exam","section":"Quizzes","content":" Mid-Sem Lab Exam # Question 1 - \u0026ldquo;Voting\u0026rdquo; # Problem Description # The Elections for the new academic year are in full swing!\nThere are \\(N\\) students in the college and two candidates for the current elections (where \\(N\\) is guaranteed to be an odd number). The students cast their votes in the form of \\(0s\\) or \\(1s\\) where the \\(i^{th}\\) vote ( \\(1 \u0026lt;= i \u0026lt;= N\\) ) being \\(1\\) represents a vote to candidate A and it being \\(0\\) represents a vote for candidate B.\nA candidate wins the elections if they have the strict majority. That is, if the number of votes cast for them is strictly greater than the number of votes cast for the other candidate.\nOutput Yes if candidate A wins the elections and No otherwise.\nLink to problem on OJ\nInput constraints # \\( 1 \\le N \\le 99 \\) \\( N \\text{ is an odd number} \\) \\( V_i = \\{0, 1\\} \\) Input format # The first line of input contains \\(N\\) , the number of students. Then, \\(N\\) line follows.\nThe \\(i^{th}\\) line contains a single integer \\(V_i = \\{0, 1\\}\\) where \\(1\\) represents a vote for candidate A and \\(0\\) represents a vote for candidate B.\nOutput Format # Output Yes if candidate A wins the elections and No otherwise.\nSample input and output # Sample Input Sample Output 3 1 0 1 Yes Explanation: There are \\(2\\) votes for candidate A and \\(1\\) vote for candidate B. Therefore, candidate A has the majority and wins the elections.\nSample Input Sample Output 5 0 0 1 0 1 No Explanation: There are \\(2\\) votes for candidate A and \\(3\\) votes for candidate B. Therefore, candidate B has the majority and wins the elections.\nSolution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int a = 0, b = 0; for (int i = 0; i \u0026lt; n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); if (x) a++; else b++; } if (a \u0026gt; b) printf(\u0026#34;Yes\\n\u0026#34;); else printf(\u0026#34;No\\n\u0026#34;); return 0; } Question 2 - \u0026ldquo;Jump Back\u0026rdquo; # Problem Description # There are \\(N\\) trees in the forest, numbered Tree 1, Tree 2,\u0026hellip;, Tree \\(N\\) .\nTree 1, is a special tree which is home to the entire forest. Each tree \\(i\\) ( \\(2 \\le i \\le N\\) ), has a parent tree \\(T_i\\) from which it grew. It is guaranteed that \\(T_i \u0026lt; i\\) .\nYou are currently on tree \\(N\\) and want to reach tree \\(1\\) . However, from a given tree, you can only jump to its parent tree (unless you are already on tree \\(1\\) , in which case you have already reached the destination).\nFor example, consider the input \\([1 1 2 4]\\) which means, \\(T_2 = 1, T_3 = 1, T_4 = 2, T_5 = 4\\) (note that tree \\(1\\) has no parent tree). Starting from tree \\(5\\) , the only option is to jump to tree 4, its parent. Similarly, from tree 4, you jump to tree 2. Finally, from tree 2 you jump to tree 1, taking a total of 3 jumps to go from tree 5 to tree 1.\nFind the number of jumps that you need to make in order to reach tree \\(1\\) starting from tree \\(N\\) . It can be shown that you can reach it in a finite number of jumps.\nLink to problem on OJ\nInput constraints # \\(2 \\le N \\le 50\\) \\(1 \\le T_i \u0026lt; i\\) ( \\(2 \\le i \\le N\\) ) Input format # The first line of input contains a single integer \\(N\\) , the number of trees.\nThe following line contains \\(N - 1\\) space separated integers, \\(T_2, T_3, \\dots, T_N\\) where \\(T_i\\) denotes the parent of the \\(i^{th}\\) tree.\nOutput Format # Output a single integer denoting the number of jumps required to go from tree \\(N\\) to tree \\(1\\) .\nSample input and output # Sample Input Sample Output 3 1 2 2 Sample Input Sample Output 5 1 1 2 4 3 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int a[n]; a[0] = -1; for (int i = 1; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); a[i]--; } int curr = n - 1, ans = 0; while (curr != -1) { ans++; curr = a[curr]; } printf(\u0026#34;%d\\n\u0026#34;, ans - 1); return 0; } Question 3 - \u0026ldquo;Max AND\u0026rdquo; # Problem Description # In this problem, we use the symbol ^ to denote the bitwise AND operation, and the symbol v to denote the bitwise OR operation.\nGiven an array of integers \\(A\\) of length \\(N\\) , \\(A_1, A_2, \\dots, A_N\\) . Define a \u0026ldquo;set operation\u0026rdquo; as the following:\nSelect any index \\(i\\) where \\(1 \\le i \\le N\\) and set the \\(j^{th}\\) bit of \\(A_i\\) where \\(j\\) is any integer between \\(0\\) and \\(30\\) inclusive. In other words, replace \\(A_i\\) with \\(A_i\\) v \\(2^j\\) . You are also given a non-negative integer \\(K\\) . You can perform at most \\(K\\) operations on the given array. After doing so, output the maximum possible value of \\(A_1\\) ^ \\(A_2\\) ^ \\(\\dots\\) ^ \\(A_N\\) .\nLink to problem on OJ\nInput constraints # \\(1 \\le N \\le 2 \\times 10^5\\) \\(0 \\le K \\le 10^9\\) \\(0 \\le A_i \u0026lt; 2^{31}\\) Input format # The first line of input contains two space separated integers \\(N\\) and \\(K\\) , denoting the length of the array and the maximum number of operations that can be performed respectively.\nThe second line contains \\(N\\) space separated integers \\(A_1, A_2, \\dots, A_N\\) that denote the initial array.\nOutput Format # Output the maximum possible value of the bitwise AND of the entire array after performing at most \\(K\\) operations.\nSample input and output # Sample Input Sample Output 3 2 2 1 1 2 Explanation: We set the \\(j = 1\\) bit (that is, the bit corresponding to \\(2^1\\) ) for \\(A_2\\) and \\(A_3\\) . This requires \\(2 \\le K\\) operations. After doing so, the array now looks like \\([2, 3, 3]\\) , giving us a bitwise AND value of \\(2\\) which can be shown is the maximum possible value for the given input.\nSample Input Sample Output 7 0 4 6 6 28 6 6 12 4 Explanation: Here, \\(K = 0\\) . So, we cannot perform any operations. Hence, the bitwise AND of the initial array, \\(4\\) is our final answer.\nSolution # #include \u0026lt;stdio.h\u0026gt; int main() { int n, k; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;k); int cnt[31] = {0}; for (int i = 0; i \u0026lt; n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); for (int j = 0; j \u0026lt; 31; j++, x /= 2) { cnt[j] += (x \u0026amp; 1); } } int ans = 0; for (int i = 30; i \u0026gt;= 0; i--) { if (k \u0026gt;= n - cnt[i]) { ans |= (1 \u0026lt;\u0026lt; i); k -= (n - cnt[i]); } } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } "},{"id":17,"href":"/docs/course_material/quizzes/quiz1A/","title":"Quiz - 1 Section A","section":"Quizzes","content":" Quiz 1 # Section A Question 1 - 5 marks # Problem Description # Write a program to find the factorial of a number. Here n can be taken to be an input from the user.\nSolution # #include \u0026lt;stdio.h\u0026gt; int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); if(n\u0026lt;0){ printf(\u0026#34;Invalid Input!\u0026#34;); }else{ int ans=1; for(int i=1;i\u0026lt;=n;i++){ ans*=i; } printf(\u0026#34;%d\\n\u0026#34;,ans); } return 0; } Grading Scheme # 1 mark: For writing\n#include \u0026lt;stdio.h\u0026gt; 1 mark: For writing\nint main(){ return 0 } 3 marks: For correct logic, this includes correct initialization of ans=1, writing the correct for-loop and correct formula. Marks have been cut for compilation errors(Between 0.5 to 1 marks have been cut)\nNote: For approaches other than the standard for-loop approach, marks have been awarded according to correctness of the approach.\nFor eg, in case of a recursion based approach, marks have been awarded if the base-case is correct and the recursion works properly. Question 2 - 5 marks # Problem Description # What is type-casting? Explain the types of type casting in C.\nSolution # The idea of type-casting is to convert one data type into another.\nThere are two types of type conversions/castings:\n1) Implicit conversions: The idea here is to convert the data type of one variable without altering the actual value of the variable. The datatype can be both promoted and demoted by compiler. There can be various implicit conversions:\na) Arithmetic conversions: Happens when operands in arithmetic or logical expressions don’t have same type. Example: Addition of integer and float.\nint a = 10; float b = 20.0; float c = a + b; // type of (a+b) is float, so it is stored back in `float c` b) Conversion during assignment: Happens when type of expression on the right side of an assignment operator doesn’t match the type of the variable on the left side. Example: assigning an int to char.\nchar pi1 = 3; int pi2 = \u0026#39;a\u0026#39;; int pi3 = 3.14; // Results in loss of information float pi4 = 3; // 3 is an int, but assigned to float c) Others: In function argument; in return statement.\n2. Explicit type-casting: In this case, the datatype conversion is user-defined according to the program’s needs. It can be a lower or higher end data type. Example:\nfloat pi = (float)21/7; Grading Scheme # Definition of typecasting (1 mark).\nDefinition of implicit conversion (1 mark) and its example (1 mark). (Sub-types of implicit conversion are not required.) Definition of explicit typecasting (1 mark) and its example (1 mark). Writing extra details relevant to the topic can also result in extra marks. For example: Writing hierarchical order of promotion in arithmetic conversion. Marks have been deducted for conceptual or syntax errors.\nQuestion 3 - 5 marks # Problem Description # Write -35 in 2’s complement form (assume 8-bit representation).\nSolution \u0026amp; Grading Scheme # The number 35 in binary is given by: 00100011 (2 marks)\nIn 2 complement it is given by: 11011101. (3 marks)\nQuestion 4 - 5 marks # Problem Description # State True/False with justification: Given two positive integers x and y, it is not possible to calculate the minimum and maximum of the two numbers without using any conditions or loops.\nSolution # False (1 mark).\n#include\u0026lt;stdio.h\u0026gt; int main() { int x,y, min, max; min = y^((x^y)\u0026amp;-(x\u0026lt;y)); max = x^((x^y)\u0026amp;-(x\u0026lt;y)); printf(\u0026#34;min = %d,max = %d\\n\u0026#34;, min,max); return 0; } (4 marks).\nGrading Scheme # 1 mark for writing False or even if have have wrote True but your Explanation points out to be correct marks have been awarded giving benefit of reading the question wrong . Such cases have been marked Lucky and are instructed to not do it from next time.\n1/2 mark if there’s a contradictory statements for the explanation and answer\n3/2 for writing the formula for minimum number expression here the formula using Absolute value concept and other correct equivalent bitwise expressions have also been taken into account.\nAgain, 3/2 for writing the correct way to find out the maximum value . Note:- Using the terms like maximum can be found out logically, naturally etc. from minimum have been given 0 marks for the same 1 mark for writing the above expressions with the whole of code structure.\nQuestion 5 - 10 marks # Problem Description # Write a program to print the following pattern of the Pascal’s triangle.\n1 1 1 1 2 1 1 3 3 1 Solution # #include\u0026lt;stdio.h\u0026gt; int main() { int rows=4, num= 1, space, i, j; for(i=0; i \u0026lt; rows; i++) { for(space=1; space \u0026lt;= rows-i; space++) printf(\u0026#34; \u0026#34;); for(j=0; j \u0026lt;= i; j++) { if (j==0 || i==0) num= 1; else num = num*(i-j+1)/j; printf(\u0026#34; %d\u0026#34;, num); } printf(\u0026#34;\\n\\n\u0026#34;); } return 0; } Grading Scheme # Header files: (1 mark - awarded if the syntax is strictly correct) Initialising variables using the right syntax: (1 mark - awarded if the syntax is strictly correct) Using the variables that were declared correctly: (1 mark - awarded with some leniency depending on the mistake) Using printf correctly for printing spaces: 2 marks are awarded if spaces are printed properly with correct generalised logic. 1 mark is awarded if just the syntax is correct. Using for or while loop: 2 marks are awarded if numbers are printed properly with correct generalised logic. 1 mark is awarded if just the syntax is correct Correct logic for generalised output - 2 marks Correct final output (brute or general) - 1 mark Question 6 - 20 marks # Problem Description # What is output of the following programs with proper justification ?\ni) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { int x = 5, y, z; y = x++; z = x--; printf(\u0026#34;%d %d %d\\n\u0026#34;, x, y, z); return 0; } Solution \u0026amp; Grading Scheme # Output: 5 5 6\nJustification:\ny = x++; // y = 5, x = 6 z = x--; // z = 6, x = 5 x = 5 (post-increment operator) (2 marks) y = 5 (post-increment operator) (2 marks) z = 6 (post-decrement operator) (1 mark) ii) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { int a = 3; a = (a++) + ~ (++a); printf(\u0026#34;%d\u0026#34;, a); return 0; } Solution \u0026amp; Grading Scheme # Output: -3 (2 marks)\nJustification:\na = 3; a = (a++) + ~ (++a) a = 3 + ~(5) [1 marks for post-increment, 1 marks for pre-increment]\na = 3 + (-6) [1 marks for writing ~(5) = -6]\na = -3\niii) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { int i = 21 \u0026gt; 5 \u0026gt; 3 \u0026lt; 4; printf(\u0026#34;%d\u0026#34;, i); return 0; } Solution \u0026amp; Grading Scheme # Output: 1 (2 marks, only 1 mark if justification is incorrect)\nJustification: The expression gets evaluated from left to right\nint i = (((21 \u0026gt; 5) \u0026gt; 3) \u0026gt; 4) 21 \u0026gt; 5 is true, so it gets evaluated to 1. (1 mark)\n1 \u0026gt; 3 is false, so it gets evaluated to 0. (1 mark)\n0 \u0026lt; 4 is true, so it gets evaluated to 1. (1 mark)\niv) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { int y; printf(\u0026#34;%d\u0026#34;, scanf(\u0026#34;%d\u0026#34;, \u0026amp;y)); /* Suppose that input value given for above scanf is 2023*/ return 0; } Solution \u0026amp; Grading Scheme # Output: 1\nJustification: Scanf returns the number of objects that are input, in this case the number of object is 1 (an integer y) so Scanf will return 1 and it will be printed.\n2 marks for output and 3 marks for justification\n"},{"id":18,"href":"/docs/course_material/quizzes/quiz1B/","title":"Quiz - 1 Section B","section":"Quizzes","content":" Quiz 1 # Section B Question 1 - 5 marks # Problem Description # Write a program to find the sum of first n even numbers. Here n can be taken to be an input from the user.\nSolution # Both Codes are considered to be valid.\n#include\u0026lt;stdio.h\u0026gt; int main() { int i, ans = 0,n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(i=0; i \u0026lt; n; i ++) { ans = ans + 2*i; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } #include\u0026lt;stdio.h\u0026gt; int main() { int i, ans = 0,n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int ans = n*(n-1); // n*(n+1) is also given as correct ans. printf(\u0026#34;%d\\n\u0026#34;,ans); return 0; } Grading Scheme # 1 mark: For writing\n#include \u0026lt;stdio.h\u0026gt; 1 mark: For writing\nint main(){ return 0 } 3 marks: For correctness of the code\nQuestion 2 - 5 marks # Problem Description # Explain the control flow between the RAM, Hard disk and the CPU after a program is written.\nSolution \u0026amp; Grading Scheme # There are a few different interpretations to the question. The question expects you to explain what happens when a program is run.\nThe OS-kernel loads the program from the Hard disk into the RAM. (1 mark) It is then transmitted to the CPU through the memory bus. (1 mark) The CPU performs the following cycle: (2 marks)\nFetch Decode Execute After this the output is written back to the RAM through the memory bus. (1 mark) Other interpretations include:\nWhat happens when the program is written in the editor and saved? What happens when the program is compiled? Marks have been given to these interpretations if points similar to what we were looking for in the intended solution are given but according to the different interpretations.\nQuestion 3 - 5 marks # Problem Description # Write -15 in 1’s complement form (assume 8-bit representation)\nSolution \u0026amp; Grading Scheme # The number 15 in binary is given by: 00001111 (2 marks)\nIn 1\u0026rsquo;s complement it is given by: 11110000. (3 marks)\nQuestion 4 - 5 marks # Problem Description # State True/False with justification: Given two numbers x and y, the expression y ^ ((x ^ y)\u0026amp; − (x \u0026lt; y)) calculates the minimum of the two numbers.\nSolution # True, This expression does calculate the minimum of the two numbers (1 Mark)\nJustification:\nIf x \u0026lt; y (2 Marks) (x \u0026lt; y) = 1 -(x\u0026lt;y) = -1 -(x\u0026lt;y) = (1111...1) (Due to one’s compliment representation of negative numbers in binary) (x ^ y) \u0026amp; (1111...1)_2 = (x ^ y) (As 1 is the identity for AND operation) y^(( x ^ y) \u0026amp; - (x \u0026lt; y) = y ^ (x ^ y) = x y ^ (x ^ y) = y ^ x ^ y ( ^ (Bitwise xor) is associative ) y ^ x ^ y = x ^ y ^ y ( ^ (Bitwise xor) is commutative ) x ^ y ^ y = x ^ 0 ( inverse of a number for bitwise xor is the number itself ) x ^ 0 = x (0 is the identity for XOR operation) Hence if x \u0026lt; y, y ^ ((x ^ y) \u0026amp; -(x \u0026lt; y)) = x If x \u0026gt;= y (2 Marks) (x \u0026lt; y) = 0 -(x\u0026lt;y) = 0 (x ^ y) \u0026amp; 0 = 0 (As any number AND 0 is 0) y ^ (( x ^ y) \u0026amp; - (x \u0026lt; y) = y ^ 0 y ^ (( x ^ y) \u0026amp; - (x \u0026lt; y) = y (0 is the identity for XOR operation) Hence if x \u0026gt;= y, y ^ ((x ^ y) \u0026amp; -(x \u0026lt; y)) = y Therefore, this expression calculates the minimum of the two numbers\nGrading Scheme # 0 marks awarded for wrong option (False) with any justification 1 mark awarded for correct option (True) without correct justification. 1.5 marks awarded for correct option (True) and justifying it by correctly evaluating it for an example, incorrect evaluation of an example have been given 1. 3 marks awarded for correct option (True) and when only one case’s justification is correct. 5 marks awarded for correct option (True) and correct justification by proving for both the cases. Question 5 - 10 marks # Problem Description # Write a program to print the following pattern.\n1 2 3 4 5 6 7 8 9 10 Solution # #include\u0026lt;stdio.h\u0026gt; int main() { int rows = 4, num = 1, space, i, j; for(i = 1; i \u0026lt;= rows; i++){ for(space = 1; space \u0026lt;= rows - i; space++) printf(\u0026#34; \u0026#34;); for(j = i*(i-1)/2; j \u0026lt; i*(i+1)/2; j++){ num = j + 1; printf(\u0026#34;%d \u0026#34;, num); } printf(\u0026#34;\\n\u0026#34;); } } Grading Scheme # Header files: (1 mark - awarded if the syntax is strictly correct) Initialising variables using the right syntax: (1 mark - awarded if the syntax is strictly correct) Using the variables that were declared correctly: (1 mark - awarded with some leniency depending on the mistake) Using printf correctly for printing spaces: 2 marks are awarded if spaces are printed properly with correct generalised logic. 1 mark is awarded if just the syntax is correct. Using for or while loop: 2 marks are awarded if numbers are printed properly with correct generalised logic. 1 mark is awarded if just the syntax is correct Correct logic for generalised output - 2 marks Correct final output (brute or general) - 1 mark Question 6 - 20 marks # Problem Description # What is output of the following programs with proper justification ?\ni) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { int x = 7, y, z; y = --x; z = x++; printf(\u0026#34;%d %d %d\\n\u0026#34;, x, y, z); return 0; } Solution \u0026amp; Grading Scheme # Output: 7 6 6\nJustification:\ny = --x; // y = 6, x = 6 z = x++; // z = 6, x = 7 x = 7 (post-increment operator) (2 marks) y = 6 (pre-decrement operator) (2 marks) z = 6 (post-increment operator) (1 mark) ii) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { int i; for(i = 9 ; i != 0 ; i--) printf(\u0026#34;%d\\n\u0026#34;, i--); return 0; } Solution \u0026amp; Grading Scheme # Output: Infinite loop of odd numbers starting from 9, 7, 5, .... (2 marks) i-- happens twice: once in the printf statement and once in the for loop. The condition i != 0 is never reached. So there is infinite loop. (3 marks)\niii) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { int x = 4, y = 4, z = 4; if (x == y == z) { printf(\u0026#34;YES\u0026#34;); } else { printf(\u0026#34;NO\u0026#34;); } return 0; } Solution \u0026amp; Grading Scheme # Output: NO (2 marks, only 1 mark if justification is incorrect)\nExpression gets evaluated from left to right ((x==y)==z)\nx == y is true, so it gets evaluated to 1. (1 mark)\n1 == z is false, so it gets evaluated to 0. (1 mark)\nTherefore “NO” is printed. (1 mark)\niv) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;%d\u0026#34;, printf(\u0026#34;Hello World\u0026#34;)); return 0; } Solution \u0026amp; Grading Scheme # Output: Hello World11\nJustification: printf outputs the text Hello World. Printf with %d returns the number of characters in the word (11). Therefore, the output is Hello World11\n2 marks for output and 3 marks for justification\n"},{"id":19,"href":"/references/","title":"References","section":"Introduction","content":" References from the web # Dive into C Textbook\nC Programing Textbook\nVariables, functions, arrays, strings\nC Structs and Pointers\nThe C Book by Banahan, Brady, Doran\nC and Unix Documentation from the Stanford CS Education Library\nA C programming course by Steve Summit, online course material\nProgramming in C by A.D. Marshall, notes and examples\n"},{"id":20,"href":"/tas/","title":"Teaching Assistants","section":"Introduction","content":" Teaching Assistants # Pramod Rao | pramod.b@research.iiit.ac.in Shreeya Singh | shreeya.singh@students.iiit.ac.in Aditya Malhotra | aditya.malhotra@students.iiit.ac.in Anushka Agrawal | anushka.agrawal@students.iiit.ac.in Ayan Datta | ayan.datta@research.iiit.ac.in Bhargav Srinivas | bhargav.srinivas@students.iiit.ac.in Dheeraja Rajreddygari | dheeraja.rajreddygari@students.iiit.ac.in Harshvardhan | harshvardhan.sv@research.iiit.ac.in Keval Jain | keval.jain@research.iiit.ac.in Kriti Gupta | kriti.gupta@research.iiit.ac.in Kushagra Kharbanda | kushagra.kharbanda@students.iiit.ac.in Kyrylo Shyvam Kumar | kyrylo.shyvam@students.iiit.ac.in Manav Shah | shah.devendrakumar@students.iiit.ac.in Mihika Sanghi | mihika.sanghi@research.iiit.ac.in Mitansh Kayathwal | mitansh.kayathwal@students.iiit.ac.in Sriteja Pashya | sriteja.pashya@research.iiit.ac.in Ujjwal Shekhar | ujjwal.shekhar@research.iiit.ac.in "},{"id":21,"href":"/docs/course_material/template/","title":"Template","section":"Course Material","content":" Course material template # Question 1 # The question body would go here\nText # Linked list can be defined as either a node structure doing nothing or one that is pointing to another linked list\nLinks # See linked: Recursion\nButton # Get Home Contribute Columns # Left Content Lorem markdownum insigne\u0026hellip; Mid Content Lorem markdownum insigne\u0026hellip; Right Content Lorem markdownum insigne\u0026hellip; Expand # Expand ↕ Markdown content # Lorem markdownum insigne\u0026hellip; Hint # Warning: Make sure to always free up memory! KaTeX # \\(f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\\) Tabs # MacOS MacOS Content # Linux Linux Content # Windows Windows Content # Code # typedef struct node { struct node* nxt; // will point to the next node in the linked list if any int val; // store whatever else you might need } Node; int main() { // Code here } "},{"id":22,"href":"/docs/course_material/tutorials/week1/","title":"Tutorial - 1","section":"Tutorials","content":" Tutorial 1 (Week of 14 August) # Theory # Introduction to how compilation works in C # We all know that computer is incapable of reading and understanding the code we write in its native form. This means that the code needs to be converted in a form which the machine can understand. The machine only understands Binary code. Thus, there should be a process by which the code we write can be converted to Binary form. This process is known as compilation. You can think of compilation to be similar to translation (For eg: Let’s say you know English but you are with someone who only understands French. This situation would require a translator! This is exactly what a compiler does. It acts as a translator!).\nThere are various stages in which the code is converted from C-language into binary for the computer to understand it:\nPreprocessing: All headers files starting with “#include” are processed in this phase. (Several other forms of processing including the removal of comments also happen at this stage). This generates a .i file Compiling: For now, assume it to be an intermediate process of conversion from .i to .s file. The .s file (known as an assembly file) is a set of commands which our machine knows to execute. Assembly: Code is converted into machine-understandable code by the assembler. The file output is a .o or .obj file. Linking: links library files(eg: stdio.h, math.h etc) to the object file to produce the a.out file, which is a binary executable of the program that was supplied as input. Finally, we execute the a.out file to get the desired output.\nNote: At this stage of the course, it is fine if the process is not entirely clear. It would become more clear in future courses (CSO for CXX students for example). The previous section just acts as a glimpse into compilation as a process being a series of smaller sub-processes. Return values of scanf and printf function # scanf() and printf() are both part of the standard I/O library in C. They are used for taking input from the user, printing output etc. It\u0026rsquo;s important to notice that these functions have a certain return value.\nscanf() function returns the number of inputs that have been read.\nExample:\nint a; int rval = scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); printf(\u0026#34;%d\u0026#34;, rval); The above snippet of code would print 1 as its output. This is because it\u0026rsquo;s reading only 1 argument. If the number of arguments increases, then the return value would change similarly.\nSimilarly, printf() function returns the number of characters written.\nint rval = printf(\u0026#34;Hello world!\u0026#34;); printf(\u0026#34;%d\u0026#34;, rval); The above snippet would print 12 as its output.\n"},{"id":23,"href":"/docs/course_material/practice_problems/week1/","title":"Week - 1","section":"Practice Problems","content":" Practice problems for week - 1 (Week of 14 August) # None of the following problems require a knowledge of loops, conditional statements etc.\nQuestion 1 # Problem Description # Keval has forgotten the password to his I-Pad. The password is a 4-digit number where each digit takes a value from 0 to 9. The good thing is that Keval remembers that his password had exactly two unique digits, and each of these digits appeared exactly twice in the password. Keval also remembers that n digits (where, \\( 0 \\le n \\le 10 \\) ) from 0-9 were definitely not used in the password.\nFind the number of different possible passwords Keval could have.\nNote that the password can start with the digit 0 Input constraints # \\(0 \\le n \\le 10\\) Input format # The only line of input contains a single integer n, the number of digits which were not used in the password\nOutput Format # Output a single integer that denotes the number of possible password sequences.\nSample input and output # Sample Input Sample Output 1 216 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int ans = ((10-n)*(10-n-1))/2 * 6; // (10-n)C2 * 4C2 printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } Question 2 # Problem Description # You are given two integers x and y. Output the minimum integer z, such that x | z = y. Here, \u0026ldquo;|\u0026rdquo; denotes the bitwise-OR operator\nInput constraints # \\(1 \\le x, y \\le 10^9\\) Input format # The only line of input contains two space-separated integers x and y\nOutput Format # Output a single integer that denotes z as described in the problem statement\nSample input and output # Sample Input Sample Output 1 3 2 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int x, y; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;x, \u0026amp;y); int z = x ^ y; printf(\u0026#34;%d\u0026#34;, z); return 0; } Question 3 # Problem Description # Reverse a 4-digit number using the modulo operator.\nInput constraints # The input would be a valid 4-digit number (i.e. no leading zeroes would be present)\nInput format # The only line of input contains a single integer n\nOutput Format # Output a single integer which denotes the reverse of the n. Note that the output may have leading zeroes.\nSample input and output # Sample Input Sample Output 3214 4123 5600 0065 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n, reversed = 0; // Input a 4-digit number printf(\u0026#34;Enter a 4-digit number: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); // Reverse the number using modulo operator reversed = (n % 10) * 1000 + ((n / 10) % 10) * 100 + ((n / 100) % 10) * 10 + (n / 1000); // Output the reversed number printf(\u0026#34;Reversed number: %d\\n\u0026#34;, reversed); return 0; } Question 4 # Problem Description # Given a time as input in hh:mm:ss format, print the total number of minutes which have passed in the day.\nInput format # The only line of input would contain the time in hh:mm:ss format (24-hour clock)\nOutput Format # Output the total number of minutes that have passed. Note that this may not be an integer.\nSample input and output # Sample Input Sample Output 13:40:30 820.5 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { // Declare three variables that will be used to store the hours, minutes, // and seconds, respectively int h, m, s; // Take input in the specified format scanf(\u0026#34;%d:%d:%d\u0026#34;, \u0026amp;h, \u0026amp;m, \u0026amp;s); /** * Calculate the total minutes * Total minutes = hours * 60 + minutes + seconds / 60 * However, to ensure that float division is done, we typecast the seconds * to float */ float minutes = 60 * h + m + (float)s / 60; // Output the total minutes as a floating point number printf(\u0026#34;%f\u0026#34;, minutes); } Question 5 # Problem Description # Kishore is a very strange boy. He keeps solving weird problems and is now stuck on one such question. Please help him solve it.\nGiven an integer n, you need to find the number of ordered pairs of integers (a, b) such that, \\( 1 \\le a \\le b \\le n \\) and\n\\(\\frac{lcm(a, b)}{gcd(a, b)} \\le 3\\) In this problem, gcd(a, b) denotes the greatest common divisor of the numbers a and b, and lcm(a, b) denotes their lowest common multiple.\nInput constraints # \\(1 \\le n \\le 10^8\\) Input format # The only line of input contains a single integer n\nOutput Format # Output a single integer that denotes the number of pairs (a, b) that satisfy the given constraints\nSample input and output # Sample Input Sample Output 5 11 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int ans = n + 2 * ((n / 2) + (n / 3)); printf(\u0026#34;%d\u0026#34;, n); return 0; } "},{"id":24,"href":"/docs/course_material/practice_problems/week2/","title":"Week - 2","section":"Practice Problems","content":" Practice problems for week - 2 (Week of 21 August) # Question 1 # Problem Description # You are given a 3 x 3 grid filled with integers 1 to 9, in the following way:\n1 2 3 4 5 6 7 8 9 You will be given two natural numbers A and B, both between 1 and 9. Your task is to find out if the two small squares with A and B written on them are horizontally adjacent.\nInput constraints # A and B are natural numbers and \\(1 \\le A,B \\le 9\\) \\(A \\le B\\) Input format # The only line of input contains two space-separated natural numbers A and B\nOutput Format # Print YES if the two squares are horizontally adjacent, and NO otherwise.\nSample input and output # Sample Input Sample Output 5 6 YES 6 7 NO Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int A, B; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;A, \u0026amp;B); if ((A - 1) % 3 == (B - 1) % 3) printf(\u0026#34;YES\\n\u0026#34;); else printf(\u0026#34;NO\\n\u0026#34;); return 0; } Question 2 # Problem Description # Shiven was given a problem to solve as assignment. In the problem, he was given two numbers n and s. He was asked to create a sequence of n non-negative integers such that the median of the sequence is as large as possible and that sum of all numbers of the sequence is s. Can you help Shiven find the maximum possible median of such a sequence?\nNote: The definition of the median is the \\( \\left\\lceil \\frac{n}{2}\\right\\rceil^{th} \\) element of a sequence noted in the ascending order\nInput constraints # \\(1 \\le n \\le 10^{8}\\) Input format # The only line of input contains two space-separated integers n and s\nOutput Format # Output a single integer that is the maximum median of such a sequence.\nSample input and output # Sample Input Sample Output 7 17 4 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n, s; printf(\u0026#34;Enter two numbers: \u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;s); int m = n / 2 + 1; int ans = s / m; printf(\u0026#34;The maximum value of median is: %d\\n\u0026#34;, ans); return 0; } "},{"id":25,"href":"/docs/course_material/practice_problems/week4/","title":"Week - 4","section":"Practice Problems","content":" Practice problems for week 4 # Question 1 - \u0026ldquo;Divisibility by 11\u0026rdquo; # Problem Description # Given an integer which has \\(n\\) digits, print YES if it is divisible by \\(11\\) and NO otherwise.\nNote that the input number may contain leading zeroes.\nNote that a number is divisible by \\(11\\) if and only if the difference of the sum of digits at odd positions and sum of digits at even positions in a number is divisible by 11.\nLink to problem on OJ\nInput Format # The first line of input contains a single integer \\(n\\) denoting the number of digits.\nThe second line of input contains a positive integer which is \\(n\\) digit long.\nInput constraints # \\(1 \\le n \\le 10000\\) Output Format # Output YES if the number is divisible by 11 and NO otherwise.\nSample inputs and outputs # Sample Input 1\n4 2548 Sample Output 1\nNO Sample Input 2\n2 22 Sample Output 2\nYES Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\\n\u0026#34;, \u0026amp;n); int cnt[] = {0, 0}; for (int i = 0; i \u0026lt; n; i++) { char c; scanf(\u0026#34;%c\u0026#34;, \u0026amp;c); cnt[i % 2] += (c - \u0026#39;0\u0026#39;); } cnt[0] %= 11, cnt[1] %= 11; if ((cnt[0] - cnt[1] + 11) % 11) printf(\u0026#34;NO\\n\u0026#34;); else printf(\u0026#34;YES\\n\u0026#34;); return 0; } Question 2 - \u0026ldquo;Reversed\u0026rdquo; (Modified) # Problem Description # Given an integer input, print the number obtained by reversing its digits. If the reverse contains leading zeroes, do not output them\nInput Format # The first and only line of input contains a positive integer \\(N\\) .\nInput constraints # \\(1 \\le N \\le 10^{18}\\) Output Format # Output a single integer which denotes the integer obtained by reversing the digits of \\(N\\) , without any leading zeroes.\nSample inputs and outputs # Sample Input 1\n348 Sample Output 1\n843 Sample Input 2\n23813900 Sample Output 2\n931832 Solution # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(void) { long long int n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); const int MAX_DIGITS = 20; int final[MAX_DIGITS]; memset(final, 0, sizeof(final)); int end = 0; while (n) { final[end++] = (n % 10); n /= 10; } int st = 0; while (!final[st]) st++; //would break if n = 0 was part of the input for (; st \u0026lt; end; st++) printf(\u0026#34;%d\u0026#34;, final[st]); printf(\u0026#34;\\n\u0026#34;); return 0; } "},{"id":26,"href":"/docs/course_material/practice_problems/week6/","title":"Week - 6","section":"Practice Problems","content":" Practice problems for week 6 # Question 1 - \u0026ldquo;Non-Fancy Trains\u0026rdquo; # Problem Description # There are \\(n\\) stations numbered \\(1, 2, ... n\\) . Stations \\(i\\) and \\(j\\) are connected via a train ( \\(1 \\le i, j \\le n\\) ) iff \\(|i - j| \\le 2\\) . The price of such a train would be \\(|a_i - a_{j}|\\) where \\(a_i\\) is an input array denoting the ratings of stations. If you travel optimally, find the minimum cost to travel form station \\(1\\) to station \\(n\\) .\nInput Format # The first line of input contains a single integer \\(n\\) denoting the number of stations.\nThe second line contains \\(n\\) space-seperated integers, \\(a_i\\) .\nInput constraints # \\(2 \\le n \\le 10^5\\) \\(1 \\le a_i \\le 10^4\\) Output Format # Print one integer, the minimum cost to travel from station \\(1\\) to station \\(n\\) .\nSample Input 1 # 4 10 30 40 20 Sample Output 1 # 30 Sample Explanation # One valid path is to go through the stations \\(1 \\rightarrow 2 \\rightarrow 4\\) , which incurs the cost \\(|10 - 30| \u0026#43; |30 - 20| = 30\\) **Sample Input 2 **\n2 10 10 Sample Output 2\n0 Question 2 - \u0026ldquo;String Palindrome Check\u0026rdquo; # Problem Description # Given a string \\(S\\) , check if it is a palindrome using recursion.\nInput Format # The first line of input contains a single integer \\(2T\\) that denotes the number of test-cases. Then, \\(2T\\) lines follow. The first line of each test-case contains a single integer \\(N\\) denoting the length of the string. The second line of each test-case contains a string \\(S\\) of length \\(N\\) .\nInput constraints # \\(1 \\le T \\le 2 \\times 10^5\\) \\(1 \\le N \\le 2 \\times 10^5\\) \\(|S| = N\\) \\(S\\) consists of only lowercase English alphabets The sum of \\(N\\) over all test-cases does not exceed \\(2 \\times 10^5\\) Output Format # For each test-case, on a single line, output YES if the string is a palindrome and NO if not\nSample inputs and outputs # Sample Input 1\n2 addd sss Sample Output 1\nNO YES Sample Input 2\n3 addfdfdda a addfdffdda Sample Output 2\nYES YES NO "}]