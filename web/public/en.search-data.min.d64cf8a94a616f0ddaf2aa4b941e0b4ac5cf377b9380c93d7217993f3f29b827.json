[{"id":0,"href":"/posts/installingGCC/","title":"Installing GCC","section":"Resources","content":" Installing gcc # This tutorial will be a quick walkthrough on installing gcc on different OS. We recommend you try installing gcc on your own before the start of classes. If, for some reason, you are unable to install gcc, then we will help you in the first tutorial session. We also recommend you install some text editor (VS Code for example).\nWe recommend the usage of Linux as this would be advantageous for your future courses as well. linux Linux (Ubuntu 22.04) # For Linux-based systems, gcc usually comes installed by default.\nCheck if gcc is installed on Ubuntu by running the command: $ gcc --version\nIf running this shows a version (For eg 13.1 or say any other version) then you are good to go.\nOtherwise, if you see an error that reads “command not found” or something similar, run the following commands:\n$ sudo apt update\n$ sudo apt install build-essential\nAfter running this, check if gcc is installed by running:\n$ gcc --version\nmac MacOS # For Mac-based systems, first start with installing homebrew (if not installed).\n$ /bin/bash -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026quot;\nAfter installing homebrew, you simply have to run:\n$ brew install gcc\nAfter running this, check if gcc is installed by running:\n$ gcc --version\nThis should show the path in which gcc has been installed on your Mac.\nwindows Windows # In Windows, C programs can be compiled using the MinGW C compiler.\nFor installation details, refer: https://www.scaler.com/topics/c/c-compiler-for-windows/\nAlternatively, you can install WSL or a Virtual Machine to have a Linux-like environment.\n"},{"id":1,"href":"/posts/linux_tools_course/","title":"Linux Tools Course","section":"Resources","content":"To get familiar with Linux tools that are generally helpful for computer science, please go through the material here: https://missing.csail.mit.edu/\n"},{"id":2,"href":"/posts/video_lectures/","title":"Video Lectures from Elsewhere","section":"Resources","content":"You can find some video lectures on c programming from other universities bellow:\nUni. of Nebraska, Lincon Harvard\nhttps://cs50.harvard.edu/x/2023/\nhttps://www.youtube.com/watch?v=8mAITcNt710 "},{"id":3,"href":"/docs/course_material/assignments/assignment1/","title":"Assignment - 1","section":"Assignments","content":" Assignment 1 # Question 1 # Problem Description # Given an integer n as input, print its binary representation starting with the most significant bit, i.e. don\u0026rsquo;t print the 0\u0026rsquo;s before the first 1.\nLink to problem on OJ\nInput constraints # \\(0 \\le n \\le 2^{30}\\) Input format # The only line of input contains a single integer n\nOutput Format # Output a continous stream of bits of n starting from the most significant bit.\nSample input and output # Sample Input Sample Output 11 1011 0 0 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); if (x==0){ printf(\u0026#34;0\u0026#34;); return 0; } int mask = 1 \u0026lt;\u0026lt; 30; int flag_first_one = 0; while (mask) { if (x \u0026amp; mask) { printf(\u0026#34;1\u0026#34;); flag_first_one = 1; } else if (flag_first_one) { printf(\u0026#34;0\u0026#34;); } mask \u0026gt;\u0026gt;= 1; } return 0; } Question 2 # Problem Description # Given an integer n between 2 and 100 as input, print all prime numbers from 1 to n (including n) in ascending order.\nLink to problem on OJ\nInput constraints # \\(2 \\le n \\le 100\\) Input format # The only line of input contains a single integer n.\nOutput Format # Output all primes that are less than or equal n in ascending order separated by spaces\nSample input and output # Sample Input Sample Output 2 2 6 2 3 5 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 2; i \u0026lt;= n; i++) { if (i == 2 || i == 3 || i == 5 || i == 7) { printf(\u0026#34;%d \u0026#34;, i); } else if (i % 2 != 0 \u0026amp;\u0026amp; i % 3 != 0 \u0026amp;\u0026amp; i % 5 != 0 \u0026amp;\u0026amp; i % 7 != 0) { printf(\u0026#34;%d \u0026#34;, i); } } return 0; } Question 3 # Problem Description # You are given width and height of a rectangle and you need to print that rectangle.\nLook at samples for more clarity.\nThe corners are to be represented by 'o'.\nThe vertical sides are represented by '|'\nThe horizontal sides are represented by '-'\nThe 'o' counts towards both height and width.\nLink to problem on OJ\nInput constraints # \\(1\\leq width\\leq 1000, 1\\leq height\\leq1000\\) Input format # Two space separated integers, width and height.\nOutput Format # Print the rectangle with the given width and height.\nSample input and output # Sample Input Sample Output 4 5 o--o\n| |\n| |\n| |\no--o 1 1 o 1 3 o\n|\no 3 2 o-o\no-o Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int width, height; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;width, \u0026amp;height); for (int i = 1; i \u0026lt;= height; i++) { for (int j = 1; j \u0026lt;= width; j++) { if ((i == 1 \u0026amp;\u0026amp; (j == 1 || j == width)) || (i == height \u0026amp;\u0026amp; (j == 1 || j == width))) printf(\u0026#34;o\u0026#34;); else if (j == 1 || j == width) printf(\u0026#34;|\u0026#34;); else if (i == 1 || i == height) printf(\u0026#34;-\u0026#34;); else printf(\u0026#34; \u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } return 0; } Question 4 # Problem Description # You are given three integers n, x and y. You need to print the first n terms of the sequence S which starts with \\(S_1=x\\) and \\(S_2=y\\) and further terms are derived from the relation \\(S_i = S_{i-1} \u0026#43; S_{i-2}\\) .\nThe first n values of S are guaranteed to fit in int Link to problem on OJ\nInput constraints # \\(1 \\le n \u0026lt; 50\\) \\(0\\leq x,y\\leq 1e5\\) \\(\\) Input format # The only line of input contains 3 space separated integers n, x and y.\nOutput Format # Output one line containing n space-seperated integers, denoting the first n terms of the sequence S.\nSample input and output # Sample Input Sample Output 5 1 2 1 2 3 5 8 Solution # #include \u0026lt;stdio.h\u0026gt; int main(){ int n, x, y; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;n, \u0026amp;x, \u0026amp;y); for (int i = 1; i \u0026lt;= n; i++) { if(i == 1)printf(\u0026#34;%d \u0026#34;, x); else if(i == 2)printf(\u0026#34;%d \u0026#34;, y); else{ int z = x + y; printf(\u0026#34;%d \u0026#34;, z); x = y; y = z; } } return 0; } Question 5 # Problem Description # Kushagra is in love with pairs. He has a list of numbers where each number has a duplicate pair. Unfortunately, there is one number that does not have a pair. Help him figure out which number it is.\nLink to problem on OJ\nInput constraints # \\(3 \\le n \\le 10^{6}\\) \\(1 \\le A_i \\le 10^{9}\\) \\(\\) Input format # The first line contains an integer n denoting the numbers present in the list.\nThe second line contains n space-separated integers \\([A_0, A_1, A_2,... A_{n-1}]\\) .\nOutput Format # A single integer, the number in the array without a pair\nSample input and output # Sample Input Sample Output 5\n4 5 6 4 5 6 7\n3 3 3 3 3 2 2 3 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int ans = 0; for(int i = 1; i \u0026lt;= n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); ans ^= x; } printf(\u0026#34;%d\\n\u0026#34;, ans); } "},{"id":4,"href":"/grading_scheme/","title":"Grading Scheme","section":"Introduction","content":" Grading Scheme # Assignments: 30% Quizzes: 20% (2 Quizzes worth 10% each) Mid-Semester Exam: 15% End-Semester Exam: 25% Labs: 10% Bonus*: 5% Note: Total score for a student would be capped at 100% (if the student\u0026rsquo;s score happens to exceed 100) "},{"id":5,"href":"/honor_code/","title":"Honor Code","section":"Introduction","content":" Honor Code # Any form of plagiarism in the Assignments or in the Lab Exams would be heavily penalised and would lead to a 0 score for both students, the student who copied and the one whose code was copied. It is solely your duty to ensure the safety of your code throughout the course .Thus, we will not be entertaining any requests after a student is found guilty of plagiarism.\n"},{"id":6,"href":"/docs/course_material/lectures/4_10/","title":"II.1 Typedef, Struct Initialization, Passing Pointers","section":"Lectures","content":" II.1 Typedef, Struct Initialization # Struct without Typedef # #include\u0026lt;stdio.h\u0026gt; struct rectangle { float length; float breadth; }; float compute_area(struct rectangle r) { return r.length * r.breadth; } void print_rectangle(struct rectangle r) { printf(\u0026#34;Rectangle with length %f and breadth %f\\n\u0026#34;, r.length, r.breadth); } int main() { struct rectangle rect = { 1.5, 3.2 }; // Initializer print_rectangle(rect); printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(rect) ); } Struct with Typedef # #include\u0026lt;stdio.h\u0026gt; typedef struct rectangle { float length; float breadth; } rectangle; float compute_area(rectangle r) { return r.length*r.breadth; } rectangle scale(rectangle r, float s) { r.length = r.length*s; r.breadth = r.breadth*s; return r; } int main() { rectangle rect = { .breadth = 1.0, .length = 3.0} /* {3.0, 1.0 }*/; // rect.length = 3.2; // rect.breadth = 1.2; printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(rect)); rectangle rp = scale(rect, 5); printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(*rp)); printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(rect)); } Passing using pointers # #include\u0026lt;stdio.h\u0026gt; typedef struct rectangle { float length; float breadth; } rectangle; float compute_area(rectangle r) { return r.length*r.breadth; } rectangle* scale(rectangle* r, float s) { r-\u0026gt;length = r-\u0026gt;length*s; r-\u0026gt;breadth = r-\u0026gt;breadth*s; return r; } int main() { rectangle rect = { .breadth = 1.0, .length = 3.0} /* {3.0, 1.0 }*/; // rect.length = 3.2; // rect.breadth = 1.2; printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(rect)); rectangle* rp = scale(\u0026amp;rect, 5); printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(*rp)); printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(rect)); } "},{"id":7,"href":"/docs/course_material/lectures/6_10/","title":"II.2 Strings and Enums","section":"Lectures","content":" II.2 Strings and Enums # Strings in C # as a pointer to char char *p = \u0026#34;abcde\u0026#34;; as an array of char char s[] = \u0026#34;abcde\u0026#34;; print(\u0026#34;%d %d\u0026#34;, sizeof(p), sizeof(s)); String Function Implementation # #include \u0026#34;stdio.h\u0026#34; int strlenB(char* s) { int i = 0; while (s[i] != \u0026#39;\\0\u0026#39;) { i++; } return i; } char* strcpyB(char *s, char *d) { int len_s = strlenB(s); for(int i = 0; i \u0026lt;= len_s;i++) { d[i] = s[i]; } return d; } char* str_rev(char *s, char *d) { int len_s = strlenB(s); for(int i = 0; i\u0026lt; len_s; i++) { d[i] = s[len_s - 1 - i]; } d[len_s] = \u0026#39;\\0\u0026#39;; return d; } int main() { char *p = \u0026#34;xyz\\0dsalkfjds\u0026#34;; char s[] = \u0026#34;abcde\\0kjdakfjsh\u0026#34;; // abcde\\0 // printf(\u0026#34;%d %d\\n\u0026#34;,sizeof(p),sizeof(s)); // printf(\u0026#34;%s %s\\n\u0026#34;,p, s); // printf(\u0026#34;%d %d\\n\u0026#34;, strlen(p), strlen(s)); // strcpy(s,p); printf(\u0026#34;%s\\n\u0026#34;,str_rev(p, s)); return 1; } String Functions # #include \u0026lt;string.h\u0026gt;\nint strlen(char *s): returns the length of the string pointed by s (ie lenth upto the first \\0 in memory). char* strcat(char* s1, char* s2): concatenates s1 with s2, stores it in s1 and returns s1. int strcmp(char *s1,char *s2): returns negative int if s1 is lex. smaller than s2, returns 0 if equal, returns positive int if s1 is lex. greater than s2. char* strcpy(char* s1, char* s2): copies s2 in to s1 and returns s1. Social Network # Name Age Rel Status Friends Alice 24 Single Diestel, Eve Bob 28 Maried Alice Charlie 20 Single Diestel Diestel 27 Not Mentioned Alice, Eve, Charlie Eve 25 Engaged Diestel, Alice Define a Person (Profile) # struct Person { char name[100]; int age; int rel_status; }; Implemeting Rel Status as int, requires us to keep in mind the mapping between Single, Maried, Not Mentioned, Engaged and integers.\nCan we specify this in code?? # Enums # typedef enum Weekday { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday } Weekday; Weekday today = Wednesday; printf(\u0026#34;Day %d\u0026#34;,today+1); printf(\u0026#34;Size of enum variable = %d bytes\u0026#34;, sizeof(today));\tEnums : Changing default values # typedef enum Weekday { Sunday = 1, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday } Weekday; Weekday today = Wednesday; printf(\u0026#34;Day %d\u0026#34;,today+1); Enums : interchangable with int # #include \u0026#34;stdio.h\u0026#34; typedef enum Weekday { Sunday = 5, Monday = 3, Tuesday, Wednesday = 2, Thursday, Friday, Saturday } Weekday; int main() { Weekday today = Wednesday;; printf(\u0026#34;Day %d\\n\u0026#34;,today+1); printf(\u0026#34;Size of enum variable = %d bytes\u0026#34;, sizeof(today));\treturn 0 ; } Define a Person (Profile) # enum RelStatus { NotMentioned, Single, Engaged, Married }; struct Person { char name[100]; int age; enum RelStatus status; }; Practice Problems # Implement str_rev in place. ie. it takes only one string (char *) as argument, reverses it. "},{"id":8,"href":"/docs/course_material/lectures/9_10/","title":"II.3 Macros, More Intializers in Social Nets","section":"Lectures","content":" II.3 Macros, More Intializers in Social Nets # Social Nets # typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Person { char name[100]; int age; RelStatus relstatus; Person* friends[5]; } Person; typedef struct SocialNet { Person members[100]; int size; } SocialNet; Social Nets with Macros # #define MAX_FRIENDS 5 #define MAX_MEMBERS 100 #define MAX_NAME_LEN 100 typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Person { char name[MAX_NAME_LEN]; int age; RelStatus relstatus; Person* friends[MAX_FRIENDS]; } Person; typedef struct SocialNet { Person members[MAX_MEMBERS]; int size; } SocialNet; Intitializer # Name Age Rel Status Alice 24 Not Mentioned Bob 28 Maried Charlie 20 Single int main() { SocialNet social_net = { .members = { { \u0026#34;Alice\u0026#34;, 24, NotMentioned}, { \u0026#34;Bob\u0026#34;, 28, Married}, { \u0026#34;Charlie\u0026#34;, 20, Single}, } , .size = 3 }; print_network(social_net); return 0; } Print Person # void print_person(struct Person p) { // TODO (solution at the end of page) } void print_network(SocialNet social_net) { printf( \u0026#34;----------------------------------------------\\n\u0026#34; \u0026#34;Name\\t\\tAge \\t Rel Status\\n\u0026#34; \u0026#34;----------------------------------------------\\n\u0026#34;); for (int i=0;i \u0026lt;social_net.size; i++) { print_person(social_net.members[i]); } printf(\u0026#34;----------------------------------------------\\n\u0026#34;); } Finding a person by name # Person* find_person(char* name1, SocialNet *sn) { // TODO (solution at the end of page) } HW: Check Mutual Friends by name # bool check_mutual_friends(char *name1, char *name2, SocialNet *sn) { // TODO p and q are mutual friends if q is in the friend list of p // and p is in the friend list of q } Full Code with Solutions # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Person { char name[100]; int age; RelStatus relstatus; int count_friends; struct Person *friends[5]; } Person; typedef struct SocialNet { Person members[80]; int size; } SocialNet; Person* find_person(char* name1, SocialNet *sn) { for(int i = 0; i \u0026lt; sn-\u0026gt;size; i++) { if ( strcmp(sn-\u0026gt;members[i].name, name1) == 0) { return \u0026amp;(sn-\u0026gt;members[i]); } } return NULL; } void print_person(Person p) { char status_string[][15] = { \u0026#34;Not Mentioned\u0026#34;, \u0026#34;Single\u0026#34;, \u0026#34;Married\u0026#34;, \u0026#34;Engaged\u0026#34; }; printf(\u0026#34;%s\\t\\t%d\\t%s\\n\u0026#34;, p.name, p.age, status_string[p.relstatus]); } void print_network(SocialNet social_net) { printf( \u0026#34;----------------------------------------------\\n\u0026#34; \u0026#34;Name\\t\\tAge \\t Rel Status\\n\u0026#34; \u0026#34;----------------------------------------------\\n\u0026#34;); for (int i=0;i \u0026lt;social_net.size; i++) { print_person(social_net.members[i]); } printf(\u0026#34;----------------------------------------------\\n\u0026#34;); } int main() { SocialNet social_net = { .members = { { \u0026#34;Alice\u0026#34;, 24, NotMentioned}, { \u0026#34;Bob\u0026#34;, 28, Married}, { \u0026#34;Charlie\u0026#34;, 20, Single}, } , .size = 3 }; print_network(social_net); print_person(*find_person(\u0026#34;Bob\u0026#34;, \u0026amp;social_net)); return 0; } "},{"id":9,"href":"/docs/course_material/lectures/11_10/","title":"II.4 Linked Lists","section":"Lectures","content":" II.4 Linked Lists # Problem: Large Arrays! # #define MAX_MEMBERS 100 typedef struct SocialNet { Person members[MAX_MEMBERS]; int size; } SocialNet; Linked List: A array that grows according to needs # Linked List: Code # typedef struct Node { Person data; struct Node* next; } Node; typedef Node* LinkedList; Node third = { {\u0026#34;Alice\u0026#34;, 22}, NULL }; Node second = { {\u0026#34;Bob\u0026#34;, 26}, \u0026amp;third }; Node first = { {\u0026#34;Charlie\u0026#34;, 20}, \u0026amp;second }; LinkedList L = \u0026amp;first; Size of a Liniked List # int size(LinkedList l) { int s = 0; while (l != NULL) { l = l-\u0026gt;next; s ++; } return s; } A recursive solution # int size(LinkedList l) { return l==NULL? 0: size(l-\u0026gt;next) + 1; } Printing elements of a linked list # void print_list(LinkedList l) { while (l != NULL) { printf(\u0026#34;%s\\t\\t%d\\n\u0026#34;,l-\u0026gt;data.name, l-\u0026gt;data.age); l = l-\u0026gt;next; } } Find the element at the ith position # Person* element_at(int pos, LinkedList l) { int s = 0; while (l != NULL) { if (s == pos) return \u0026amp;(l-\u0026gt;data); l = l-\u0026gt;next; s ++; } return NULL; } A recursive solution # Person* element_at_recursive(int pos, LinkedList l) { // TODO if (l==NULL) return NULL; if (pos == 0) {return \u0026amp;(l-\u0026gt;data);} else { return element_at(pos-1, l-\u0026gt;next); } // return pos == 0 ? \u0026amp;(l-\u0026gt;data): element_at(pos-1, l-\u0026gt;next); } Append element to end of the list # LinkedList append(Person p, LinkedList l) { // Node D = {{\u0026#34;Raj\u0026#34;, 18}, NULL}; Local Variable! Will not work. Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = NULL; if (l == NULL) return D; // if l is empty just return D. while (l-\u0026gt;next != NULL) { l = l-\u0026gt;next; } l-\u0026gt;next = D; return l; } Full code # #include \u0026#34;stdio.h\u0026#34; #include \u0026#34;stdlib.h\u0026#34; #define MAX_NAME_LEN 100 typedef struct Person { char name[MAX_NAME_LEN]; int age; } Person; typedef struct Node { Person data; struct Node* next; } Node; typedef Node* LinkedList; void print_list(LinkedList l) { printf(\u0026#34;-----------------------------------\\n\u0026#34;); while (l != NULL) { printf(\u0026#34;%s\\t\\t%d\\n\u0026#34;,l-\u0026gt;data.name, l-\u0026gt;data.age); l = l-\u0026gt;next; } printf(\u0026#34;-----------------------------------\\n\u0026#34;); } int size(LinkedList l) { int s = 0; while (l != NULL) { l = l-\u0026gt;next; s ++; } return s; // Simpler recursive solution // return l==NULL? 0: size(l-\u0026gt;next) + 1; } Person* element_at(int pos, LinkedList l) { int s = 0; while (l != NULL) { if (s == pos) return \u0026amp;(l-\u0026gt;data); l = l-\u0026gt;next; s ++; } return NULL; } Person* element_at_recursive(int pos, LinkedList l) { // TODO if (l==NULL) return NULL; if (pos == 0) {return \u0026amp;(l-\u0026gt;data);} else { return element_at(pos-1, l-\u0026gt;next); } // return pos == 0 ? \u0026amp;(l-\u0026gt;data): element_at(pos-1, l-\u0026gt;next); } LinkedList append(Person p, LinkedList l) { // Node D = {{\u0026#34;Raj\u0026#34;, 18}, NULL}; Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = NULL; if (l == NULL) return D; while (l-\u0026gt;next != NULL) { l = l-\u0026gt;next; } l-\u0026gt;next = D; return l; } int main() { Node third = { {\u0026#34;Alice\u0026#34;, 22}, NULL }; Node second = { {\u0026#34;Bob\u0026#34;, 26}, \u0026amp;third }; Node first = { {\u0026#34;Charlie\u0026#34;, 20}, \u0026amp;second }; Person D = {\u0026#34;Raj\u0026#34;, 18}; LinkedList l = \u0026amp;first; printf(\u0026#34;Size of the list is %d\\n\u0026#34;, size(l)); print_list(l); printf(\u0026#34;Element at 1st position: %s\\n\u0026#34;, element_at(1,l)-\u0026gt;name); printf(\u0026#34;Element at 2nd position: %s\\n\u0026#34;, element_at(2,l)-\u0026gt;name); append(D, l); printf(\u0026#34;List after appending\\n\u0026#34;); print_list(l); return 0; } HW: Insert element at a position in the list # LinkedList insert(Person p, int pos, LinkedList l) { // TODO } HW: Concatenate 2 lists # LinkedList concat(LinkedList l1, LinkedList l2) { // TODO } HW: Reverse a list # LinkedList reverse(LinkedList l) { // TODO } "},{"id":10,"href":"/docs/course_material/labs/lab1/","title":"Lab - 1","section":"Labs","content":" Lab 1 (Week of 14 August) # Question 1 # Problem Description # Given an integer n as input, print the last 3 bits of the number in its binary representation starting with the most significant bit among the three.\nNote: The last three bits are the bits corresponding to the,\n\\( 2^2, 2^1 \\) and \\( 2^0 \\) positions (in that order) Link to problem on OJ\nInput constraints # \\(0 \\le n \\le 2^{31}\\) Input format # The only line of input contains a single integer n\nOutput Format # Output three space-separated bits denoting the last three bits of the given number starting with the most significant bit among the three.\nSample input and output # Sample Input Sample Output 11 0 1 1 12 1 0 0 Question 2 # Problem Description # Given a date in DD-MM-YY format, output it in MM-DD-YY format.\nLink to problem on OJ\nInput format # The only line of input contains a valid date in DD-MM-YY format.\nOutput Format # Output the date in MM-DD-YY format with no space separation.\nSample input and output # Sample Input Sample Output 25-03-04 03-25-04 15-08-23 08-15-23 "},{"id":11,"href":"/docs/course_material/labs/lab2/","title":"Lab - 2","section":"Labs","content":" Lab 2 (Week of 21 August) # Question 1 # Problem Description # Given an integer which has n digits, print YES if it is divisible by 3, and NO otherwise.\nNote: The input number will not contain any leading zeroes. Link to problem on OJ\nInput constraints # \\(0 \\le n \\le 1000\\) Input format # The first line of input contains a single integer n denoting the number of digits.\nThe second line of input contains the integer which is n digit long.\nOutput Format # Output YES if the number is divisible by 3 and NO otherwise.\nSample input and output # Sample Input Sample Output 10 1234567890 YES 2 22 NO Question 2 # Problem Description # You are given three non-negative integers x, y and k where \\(0 \\le k \\le 31\\) . Replace the first k bits (from the right) of x with the first k bits of y and print the new value of x. In other words, replace the k least significant bits of x with the corresponding bits from y.\nLink to problem on OJ\nInput constraints # \\(0 \\le x,y \\le 2^{31}\\) \\(0 \\le k \\le 31\\) Input format # The only line of input contains 3 space-separated integers x, y and k.\nOutput Format # Output a single integer denoting the new value of x\nSample input and output # Sample Input Sample Output 11 22 3 14 "},{"id":12,"href":"/docs/course_material/labs/lab3/","title":"Lab - 3","section":"Labs","content":" Lab 3 (Week of 4 September) # Question 1 # Problem Description # A new student club is organising a huge event this semester for silver jubilee celebrations. Initially, they don\u0026rsquo;t have enough members. So, they started recruiting new members in groups.\nMeanwhile, tasks keep coming up within the club. Each club member can work on only one task during the semester.\nIf there is no member available (isn\u0026rsquo;t occupied with a task) when a task arises, it will remain unattended regardless of whether new individuals are recruited later on.\nGiven the chronological order of task arrivals and club members’ recruitment, find the number of tasks that will remain unattended.\nIn the input, a -1 denotes the arrival of a task (which may or may not go unattended depending on whether or not there are currently any free members to take up the task). Similarly, a non-neagative number denotes the number of new recruits.\nNote that once an individual is recruited for the club, they\u0026rsquo;ll always be part of the club. When an individual takes up a task, they\u0026rsquo;ll be occupied with it for the rest of the semester.\nLink to problem on OJ\nInput constraints # \\(1 \\le N \\le 2 \\times 10^5\\) \\(A_i \\in [-1, 10]\\) Input format # The first line of input contains a single integer N that denotes the number of events (either task arrival or new recruitment).\nThe second line of input contains N space-separated integers \\(A_1, A_2, \\dots, A_N\\) that describe the N events as explained in the description.\nOutput Format # Output a single integer that denotes the number of unattended tasks.\nSample input and output # Sample Input Sample Output 3 -1 -1 -1 2 11 -1 -1 2 -1 -1 -1 -1 -1 -1 -1 -1 8 Question 2 # Problem Description # You are given a sequence of N integers \\(A_1,A_2,...,A_N \\) and while looking at the sequence in order from left to right (that is, from index 1 to N), you start by crossing the first number, and you cross a subsequent number if it is strictly greater than every number you crossed before. You keep crossing until you reach the end of the sequence.\nOutput all the numbers you have crossed.\nLink to problem on OJ\nInput constraints # \\(1 \\le N \\le 2 \\times 10^5\\) \\(0 \\le A_i \\le 10^9\\) Input format # The first line of input contains a single integer N that denotes the size of the array.\nThe second line of input contains N space-separated integers \\(A_1,A_2,...,A_N \\) that describe the N elements.\nOutput Format # On the first line, output the count of numbers that you cross out, K. Note that this is a positive number since the first number is always crossed.\nOn the second line, output K space-separated integers denoting the numbers crossed out in the order in which they appear in the original array.\nSample input and output # Sample Input Sample Output 7\n1 1 3 2 4 10 9 4\n1 3 4 10 "},{"id":13,"href":"/docs/course_material/quizzes/quiz1A/","title":"Quiz - 1 Section A","section":"Quizzes","content":" Quiz 1 # Section A Question 1 - 5 marks # Problem Description # Write a program to find the factorial of a number. Here n can be taken to be an input from the user.\nSolution # #include \u0026lt;stdio.h\u0026gt; int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); if(n\u0026lt;0){ printf(\u0026#34;Invalid Input!\u0026#34;); }else{ int ans=1; for(int i=1;i\u0026lt;=n;i++){ ans*=i; } printf(\u0026#34;%d\\n\u0026#34;,ans); } return 0; } Grading Scheme # 1 mark: For writing\n#include \u0026lt;stdio.h\u0026gt; 1 mark: For writing\nint main(){ return 0 } 3 marks: For correct logic, this includes correct initialization of ans=1, writing the correct for-loop and correct formula. Marks have been cut for compilation errors(Between 0.5 to 1 marks have been cut)\nNote: For approaches other than the standard for-loop approach, marks have been awarded according to correctness of the approach.\nFor eg, in case of a recursion based approach, marks have been awarded if the base-case is correct and the recursion works properly. Question 2 - 5 marks # Problem Description # What is type-casting? Explain the types of type casting in C.\nSolution # The idea of type-casting is to convert one data type into another.\nThere are two types of type conversions/castings:\n1) Implicit conversions: The idea here is to convert the data type of one variable without altering the actual value of the variable. The datatype can be both promoted and demoted by compiler. There can be various implicit conversions:\na) Arithmetic conversions: Happens when operands in arithmetic or logical expressions don’t have same type. Example: Addition of integer and float.\nint a = 10; float b = 20.0; float c = a + b; // type of (a+b) is float, so it is stored back in `float c` b) Conversion during assignment: Happens when type of expression on the right side of an assignment operator doesn’t match the type of the variable on the left side. Example: assigning an int to char.\nchar pi1 = 3; int pi2 = \u0026#39;a\u0026#39;; int pi3 = 3.14; // Results in loss of information float pi4 = 3; // 3 is an int, but assigned to float c) Others: In function argument; in return statement.\n2. Explicit type-casting: In this case, the datatype conversion is user-defined according to the program’s needs. It can be a lower or higher end data type. Example:\nfloat pi = (float)21/7; Grading Scheme # Definition of typecasting (1 mark).\nDefinition of implicit conversion (1 mark) and its example (1 mark). (Sub-types of implicit conversion are not required.) Definition of explicit typecasting (1 mark) and its example (1 mark). Writing extra details relevant to the topic can also result in extra marks. For example: Writing hierarchical order of promotion in arithmetic conversion. Marks have been deducted for conceptual or syntax errors.\nQuestion 3 - 5 marks # Problem Description # Write -35 in 2’s complement form (assume 8-bit representation).\nSolution \u0026amp; Grading Scheme # The number 35 in binary is given by: 00100011 (2 marks)\nIn 2 complement it is given by: 11011101. (3 marks)\nQuestion 4 - 5 marks # Problem Description # State True/False with justification: Given two positive integers x and y, it is not possible to calculate the minimum and maximum of the two numbers without using any conditions or loops.\nSolution # False (1 mark).\n#include\u0026lt;stdio.h\u0026gt; int main() { int x,y, min, max; min = y^((x^y)\u0026amp;-(x\u0026lt;y)); max = x^((x^y)\u0026amp;-(x\u0026lt;y)); printf(\u0026#34;min = %d,max = %d\\n\u0026#34;, min,max); return 0; } (4 marks).\nGrading Scheme # 1 mark for writing False or even if have have wrote True but your Explanation points out to be correct marks have been awarded giving benefit of reading the question wrong . Such cases have been marked Lucky and are instructed to not do it from next time.\n1/2 mark if there’s a contradictory statements for the explanation and answer\n3/2 for writing the formula for minimum number expression here the formula using Absolute value concept and other correct equivalent bitwise expressions have also been taken into account.\nAgain, 3/2 for writing the correct way to find out the maximum value . Note:- Using the terms like maximum can be found out logically, naturally etc. from minimum have been given 0 marks for the same 1 mark for writing the above expressions with the whole of code structure.\nQuestion 5 - 10 marks # Problem Description # Write a program to print the following pattern of the Pascal’s triangle.\n1 1 1 1 2 1 1 3 3 1 Solution # #include\u0026lt;stdio.h\u0026gt; int main() { int rows=4, num= 1, space, i, j; for(i=0; i \u0026lt; rows; i++) { for(space=1; space \u0026lt;= rows-i; space++) printf(\u0026#34; \u0026#34;); for(j=0; j \u0026lt;= i; j++) { if (j==0 || i==0) num= 1; else num = num*(i-j+1)/j; printf(\u0026#34; %d\u0026#34;, num); } printf(\u0026#34;\\n\\n\u0026#34;); } return 0; } Grading Scheme # Header files: (1 mark - awarded if the syntax is strictly correct) Initialising variables using the right syntax: (1 mark - awarded if the syntax is strictly correct) Using the variables that were declared correctly: (1 mark - awarded with some leniency depending on the mistake) Using printf correctly for printing spaces: 2 marks are awarded if spaces are printed properly with correct generalised logic. 1 mark is awarded if just the syntax is correct. Using for or while loop: 2 marks are awarded if numbers are printed properly with correct generalised logic. 1 mark is awarded if just the syntax is correct Correct logic for generalised output - 2 marks Correct final output (brute or general) - 1 mark Question 6 - 20 marks # Problem Description # What is output of the following programs with proper justification ?\ni) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { int x = 5, y, z; y = x++; z = x--; printf(\u0026#34;%d %d %d\\n\u0026#34;, x, y, z); return 0; } Solution \u0026amp; Grading Scheme # Output: 5 5 6\nJustification:\ny = x++; // y = 5, x = 6 z = x--; // z = 6, x = 5 x = 5 (post-increment operator) (2 marks) y = 5 (post-increment operator) (2 marks) z = 6 (post-decrement operator) (1 mark) ii) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { int a = 3; a = (a++) + ~ (++a); printf(\u0026#34;%d\u0026#34;, a); return 0; } Solution \u0026amp; Grading Scheme # Output: -3 (2 marks)\nJustification:\na = 3; a = (a++) + ~ (++a) a = 3 + ~(5) [1 marks for post-increment, 1 marks for pre-increment]\na = 3 + (-6) [1 marks for writing ~(5) = -6]\na = -3\niii) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { int i = 21 \u0026gt; 5 \u0026gt; 3 \u0026lt; 4; printf(\u0026#34;%d\u0026#34;, i); return 0; } Solution \u0026amp; Grading Scheme # Output: 1 (2 marks, only 1 mark if justification is incorrect)\nJustification: The expression gets evaluated from left to right\nint i = (((21 \u0026gt; 5) \u0026gt; 3) \u0026gt; 4) 21 \u0026gt; 5 is true, so it gets evaluated to 1. (1 mark)\n1 \u0026gt; 3 is false, so it gets evaluated to 0. (1 mark)\n0 \u0026lt; 4 is true, so it gets evaluated to 1. (1 mark)\niv) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { int y; printf(\u0026#34;%d\u0026#34;, scanf(\u0026#34;%d\u0026#34;, \u0026amp;y)); /* Suppose that input value given for above scanf is 2023*/ return 0; } Solution \u0026amp; Grading Scheme # Output: 1\nJustification: Scanf returns the number of objects that are input, in this case the number of object is 1 (an integer y) so Scanf will return 1 and it will be printed.\n2 marks for output and 3 marks for justification\n"},{"id":14,"href":"/docs/course_material/quizzes/quiz1B/","title":"Quiz - 1 Section B","section":"Quizzes","content":" Quiz 1 # Section B Question 1 - 5 marks # Problem Description # Write a program to find the sum of first n even numbers. Here n can be taken to be an input from the user.\nSolution # Both Codes are considered to be valid.\n#include\u0026lt;stdio.h\u0026gt; int main() { int i, ans = 0,n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(i=0; i \u0026lt; n; i ++) { ans = ans + 2*i; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } #include\u0026lt;stdio.h\u0026gt; int main() { int i, ans = 0,n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int ans = n*(n-1); // n*(n+1) is also given as correct ans. printf(\u0026#34;%d\\n\u0026#34;,ans); return 0; } Grading Scheme # 1 mark: For writing\n#include \u0026lt;stdio.h\u0026gt; 1 mark: For writing\nint main(){ return 0 } 3 marks: For correctness of the code\nQuestion 2 - 5 marks # Problem Description # Explain the control flow between the RAM, Hard disk and the CPU after a program is written.\nSolution \u0026amp; Grading Scheme # There are a few different interpretations to the question. The question expects you to explain what happens when a program is run.\nThe OS-kernel loads the program from the Hard disk into the RAM. (1 mark) It is then transmitted to the CPU through the memory bus. (1 mark) The CPU performs the following cycle: (2 marks)\nFetch Decode Execute After this the output is written back to the RAM through the memory bus. (1 mark) Other interpretations include:\nWhat happens when the program is written in the editor and saved? What happens when the program is compiled? Marks have been given to these interpretations if points similar to what we were looking for in the intended solution are given but according to the different interpretations.\nQuestion 3 - 5 marks # Problem Description # Write -15 in 1’s complement form (assume 8-bit representation)\nSolution \u0026amp; Grading Scheme # The number 15 in binary is given by: 00001111 (2 marks)\nIn 1\u0026rsquo;s complement it is given by: 11110000. (3 marks)\nQuestion 4 - 5 marks # Problem Description # State True/False with justification: Given two numbers x and y, the expression y ^ ((x ^ y)\u0026amp; − (x \u0026lt; y)) calculates the minimum of the two numbers.\nSolution # True, This expression does calculate the minimum of the two numbers (1 Mark)\nJustification:\nIf x \u0026lt; y (2 Marks) (x \u0026lt; y) = 1 -(x\u0026lt;y) = -1 -(x\u0026lt;y) = (1111...1) (Due to one’s compliment representation of negative numbers in binary) (x ^ y) \u0026amp; (1111...1)_2 = (x ^ y) (As 1 is the identity for AND operation) y^(( x ^ y) \u0026amp; - (x \u0026lt; y) = y ^ (x ^ y) = x y ^ (x ^ y) = y ^ x ^ y ( ^ (Bitwise xor) is associative ) y ^ x ^ y = x ^ y ^ y ( ^ (Bitwise xor) is commutative ) x ^ y ^ y = x ^ 0 ( inverse of a number for bitwise xor is the number itself ) x ^ 0 = x (0 is the identity for XOR operation) Hence if x \u0026lt; y, y ^ ((x ^ y) \u0026amp; -(x \u0026lt; y)) = x If x \u0026gt;= y (2 Marks) (x \u0026lt; y) = 0 -(x\u0026lt;y) = 0 (x ^ y) \u0026amp; 0 = 0 (As any number AND 0 is 0) y ^ (( x ^ y) \u0026amp; - (x \u0026lt; y) = y ^ 0 y ^ (( x ^ y) \u0026amp; - (x \u0026lt; y) = y (0 is the identity for XOR operation) Hence if x \u0026gt;= y, y ^ ((x ^ y) \u0026amp; -(x \u0026lt; y)) = y Therefore, this expression calculates the minimum of the two numbers\nGrading Scheme # 0 marks awarded for wrong option (False) with any justification 1 mark awarded for correct option (True) without correct justification. 1.5 marks awarded for correct option (True) and justifying it by correctly evaluating it for an example, incorrect evaluation of an example have been given 1. 3 marks awarded for correct option (True) and when only one case’s justification is correct. 5 marks awarded for correct option (True) and correct justification by proving for both the cases. Question 5 - 10 marks # Problem Description # Write a program to print the following pattern.\n1 2 3 4 5 6 7 8 9 10 Solution # #include\u0026lt;stdio.h\u0026gt; int main() { int rows = 4, num = 1, space, i, j; for(i = 1; i \u0026lt;= rows; i++){ for(space = 1; space \u0026lt;= rows - i; space++) printf(\u0026#34; \u0026#34;); for(j = i*(i-1)/2; j \u0026lt; i*(i+1)/2; j++){ num = j + 1; printf(\u0026#34;%d \u0026#34;, num); } printf(\u0026#34;\\n\u0026#34;); } } Grading Scheme # Header files: (1 mark - awarded if the syntax is strictly correct) Initialising variables using the right syntax: (1 mark - awarded if the syntax is strictly correct) Using the variables that were declared correctly: (1 mark - awarded with some leniency depending on the mistake) Using printf correctly for printing spaces: 2 marks are awarded if spaces are printed properly with correct generalised logic. 1 mark is awarded if just the syntax is correct. Using for or while loop: 2 marks are awarded if numbers are printed properly with correct generalised logic. 1 mark is awarded if just the syntax is correct Correct logic for generalised output - 2 marks Correct final output (brute or general) - 1 mark Question 6 - 20 marks # Problem Description # What is output of the following programs with proper justification ?\ni) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { int x = 7, y, z; y = --x; z = x++; printf(\u0026#34;%d %d %d\\n\u0026#34;, x, y, z); return 0; } Solution \u0026amp; Grading Scheme # Output: 7 6 6\nJustification:\ny = --x; // y = 6, x = 6 z = x++; // z = 6, x = 7 x = 7 (post-increment operator) (2 marks) y = 6 (pre-decrement operator) (2 marks) z = 6 (post-increment operator) (1 mark) ii) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { int i; for(i = 9 ; i != 0 ; i--) printf(\u0026#34;%d\\n\u0026#34;, i--); return 0; } Solution \u0026amp; Grading Scheme # Output: Infinite loop of odd numbers starting from 9, 7, 5, .... (2 marks) i-- happens twice: once in the printf statement and once in the for loop. The condition i != 0 is never reached. So there is infinite loop. (3 marks)\niii) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { int x = 4, y = 4, z = 4; if (x == y == z) { printf(\u0026#34;YES\u0026#34;); } else { printf(\u0026#34;NO\u0026#34;); } return 0; } Solution \u0026amp; Grading Scheme # Output: NO (2 marks, only 1 mark if justification is incorrect)\nExpression gets evaluated from left to right ((x==y)==z)\nx == y is true, so it gets evaluated to 1. (1 mark)\n1 == z is false, so it gets evaluated to 0. (1 mark)\nTherefore “NO” is printed. (1 mark)\niv) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;%d\u0026#34;, printf(\u0026#34;Hello World\u0026#34;)); return 0; } Solution \u0026amp; Grading Scheme # Output: Hello World11\nJustification: printf outputs the text Hello World. Printf with %d returns the number of characters in the word (11). Therefore, the output is Hello World11\n2 marks for output and 3 marks for justification\n"},{"id":15,"href":"/tas/","title":"Teaching Assistants","section":"Introduction","content":" Teaching Assistants # Pramod Rao | pramod.b@research.iiit.ac.in Shreeya Singh | shreeya.singh@students.iiit.ac.in Aditya Malhotra | aditya.malhotra@students.iiit.ac.in Anushka Agrawal | anushka.agrawal@students.iiit.ac.in Ayan Datta | ayan.datta@research.iiit.ac.in Bhargav Srinivas | bhargav.srinivas@students.iiit.ac.in Dheeraja Rajreddygari | dheeraja.rajreddygari@students.iiit.ac.in Harshvardhan | harshvardhan.sv@research.iiit.ac.in Keval Jain | keval.jain@research.iiit.ac.in Kriti Gupta | kriti.gupta@research.iiit.ac.in Kushagra Kharbanda | kushagra.kharbanda@students.iiit.ac.in Kyrylo Shyvam Kumar | kyrylo.shyvam@students.iiit.ac.in Manav Shah | shah.devendrakumar@students.iiit.ac.in Mihika Sanghi | mihika.sanghi@research.iiit.ac.in Mitansh Kayathwal | mitansh.kayathwal@students.iiit.ac.in Sriteja Pashya | sriteja.pashya@research.iiit.ac.in Ujjwal Shekhar | ujjwal.shekhar@research.iiit.ac.in "},{"id":16,"href":"/docs/course_material/template/","title":"Template","section":"Course Material","content":" Course material template # Question 1 # The question body would go here\nText # Linked list can be defined as either a node structure doing nothing or one that is pointing to another linked list\nLinks # See linked: Recursion\nButton # Get Home Contribute Columns # Left Content Lorem markdownum insigne\u0026hellip; Mid Content Lorem markdownum insigne\u0026hellip; Right Content Lorem markdownum insigne\u0026hellip; Expand # Expand ↕ Markdown content # Lorem markdownum insigne\u0026hellip; Hint # Warning: Make sure to always free up memory! KaTeX # \\(f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\\) Tabs # MacOS MacOS Content # Linux Linux Content # Windows Windows Content # Code # typedef struct node { struct node* nxt; // will point to the next node in the linked list if any int val; // store whatever else you might need } Node; int main() { // Code here } "},{"id":17,"href":"/docs/course_material/tutorials/week1/","title":"Tutorial - 1","section":"Tutorials","content":" Tutorial 1 (Week of 14 August) # Theory # Introduction to how compilation works in C # We all know that computer is incapable of reading and understanding the code we write in its native form. This means that the code needs to be converted in a form which the machine can understand. The machine only understands Binary code. Thus, there should be a process by which the code we write can be converted to Binary form. This process is known as compilation. You can think of compilation to be similar to translation (For eg: Let’s say you know English but you are with someone who only understands French. This situation would require a translator! This is exactly what a compiler does. It acts as a translator!).\nThere are various stages in which the code is converted from C-language into binary for the computer to understand it:\nPreprocessing: All headers files starting with “#include” are processed in this phase. (Several other forms of processing including the removal of comments also happen at this stage). This generates a .i file Compiling: For now, assume it to be an intermediate process of conversion from .i to .s file. The .s file (known as an assembly file) is a set of commands which our machine knows to execute. Assembly: Code is converted into machine-understandable code by the assembler. The file output is a .o or .obj file. Linking: links library files(eg: stdio.h, math.h etc) to the object file to produce the a.out file, which is a binary executable of the program that was supplied as input. Finally, we execute the a.out file to get the desired output.\nNote: At this stage of the course, it is fine if the process is not entirely clear. It would become more clear in future courses (CSO for CXX students for example). The previous section just acts as a glimpse into compilation as a process being a series of smaller sub-processes. Return values of scanf and printf function # scanf() and printf() are both part of the standard I/O library in C. They are used for taking input from the user, printing output etc. It\u0026rsquo;s important to notice that these functions have a certain return value.\nscanf() function returns the number of inputs that have been read.\nExample:\nint a; int rval = scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); printf(\u0026#34;%d\u0026#34;, rval); The above snippet of code would print 1 as its output. This is because it\u0026rsquo;s reading only 1 argument. If the number of arguments increases, then the return value would change similarly.\nSimilarly, printf() function returns the number of characters written.\nint rval = printf(\u0026#34;Hello world!\u0026#34;); printf(\u0026#34;%d\u0026#34;, rval); The above snippet would print 12 as its output.\n"},{"id":18,"href":"/docs/course_material/practice_problems/week1/","title":"Week - 1","section":"Practice Problems","content":" Practice problems for week - 1 (Week of 14 August) # None of the following problems require a knowledge of loops, conditional statements etc.\nQuestion 1 # Problem Description # Keval has forgotten the password to his I-Pad. The password is a 4-digit number where each digit takes a value from 0 to 9. The good thing is that Keval remembers that his password had exactly two unique digits, and each of these digits appeared exactly twice in the password. Keval also remembers that n digits (where, \\( 0 \\le n \\le 10 \\) ) from 0-9 were definitely not used in the password.\nFind the number of different possible passwords Keval could have.\nNote that the password can start with the digit 0 Input constraints # \\(0 \\le n \\le 10\\) Input format # The only line of input contains a single integer n, the number of digits which were not used in the password\nOutput Format # Output a single integer that denotes the number of possible password sequences.\nSample input and output # Sample Input Sample Output 1 216 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int ans = ((10-n)*(10-n-1))/2 * 6; // (10-n)C2 * 4C2 printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } Question 2 # Problem Description # You are given two integers x and y. Output the minimum integer z, such that x | z = y. Here, \u0026ldquo;|\u0026rdquo; denotes the bitwise-OR operator\nInput constraints # \\(1 \\le x, y \\le 10^9\\) Input format # The only line of input contains two space-separated integers x and y\nOutput Format # Output a single integer that denotes z as described in the problem statement\nSample input and output # Sample Input Sample Output 1 3 2 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int x, y; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;x, \u0026amp;y); int z = x ^ y; printf(\u0026#34;%d\u0026#34;, z); return 0; } Question 3 # Problem Description # Reverse a 4-digit number using the modulo operator.\nInput constraints # The input would be a valid 4-digit number (i.e. no leading zeroes would be present)\nInput format # The only line of input contains a single integer n\nOutput Format # Output a single integer which denotes the reverse of the n. Note that the output may have leading zeroes.\nSample input and output # Sample Input Sample Output 3214 4123 5600 0065 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n, reversed = 0; // Input a 4-digit number printf(\u0026#34;Enter a 4-digit number: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); // Reverse the number using modulo operator reversed = (n % 10) * 1000 + ((n / 10) % 10) * 100 + ((n / 100) % 10) * 10 + (n / 1000); // Output the reversed number printf(\u0026#34;Reversed number: %d\\n\u0026#34;, reversed); return 0; } Question 4 # Problem Description # Given a time as input in hh:mm:ss format, print the total number of minutes which have passed in the day.\nInput format # The only line of input would contain the time in hh:mm:ss format (24-hour clock)\nOutput Format # Output the total number of minutes that have passed. Note that this may not be an integer.\nSample input and output # Sample Input Sample Output 13:40:30 820.5 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { // Declare three variables that will be used to store the hours, minutes, // and seconds, respectively int h, m, s; // Take input in the specified format scanf(\u0026#34;%d:%d:%d\u0026#34;, \u0026amp;h, \u0026amp;m, \u0026amp;s); /** * Calculate the total minutes * Total minutes = hours * 60 + minutes + seconds / 60 * However, to ensure that float division is done, we typecast the seconds * to float */ float minutes = 60 * h + m + (float)s / 60; // Output the total minutes as a floating point number printf(\u0026#34;%f\u0026#34;, minutes); } Question 5 # Problem Description # Kishore is a very strange boy. He keeps solving weird problems and is now stuck on one such question. Please help him solve it.\nGiven an integer n, you need to find the number of ordered pairs of integers (a, b) such that, \\( 1 \\le a \\le b \\le n \\) and\n\\(\\frac{lcm(a, b)}{gcd(a, b)} \\le 3\\) In this problem, gcd(a, b) denotes the greatest common divisor of the numbers a and b, and lcm(a, b) denotes their lowest common multiple.\nInput constraints # \\(1 \\le n \\le 10^8\\) Input format # The only line of input contains a single integer n\nOutput Format # Output a single integer that denotes the number of pairs (a, b) that satisfy the given constraints\nSample input and output # Sample Input Sample Output 5 11 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int ans = n + 2 * ((n / 2) + (n / 3)); printf(\u0026#34;%d\u0026#34;, n); return 0; } "},{"id":19,"href":"/docs/course_material/practice_problems/week2/","title":"Week - 2","section":"Practice Problems","content":" Practice problems for week - 2 (Week of 21 August) # Question 1 # Problem Description # You are given a 3 x 3 grid filled with integers 1 to 9, in the following way:\n1 2 3 4 5 6 7 8 9 You will be given two natural numbers A and B, both between 1 and 9. Your task is to find out if the two small squares with A and B written on them are horizontally adjacent.\nInput constraints # A and B are natural numbers and \\(1 \\le A,B \\le 9\\) \\(A \\le B\\) Input format # The only line of input contains two space-separated natural numbers A and B\nOutput Format # Print YES if the two squares are horizontally adjacent, and NO otherwise.\nSample input and output # Sample Input Sample Output 5 6 YES 6 7 NO Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int A, B; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;A, \u0026amp;B); if ((A - 1) % 3 == (B - 1) % 3) printf(\u0026#34;YES\\n\u0026#34;); else printf(\u0026#34;NO\\n\u0026#34;); return 0; } Question 2 # Problem Description # Shiven was given a problem to solve as assignment. In the problem, he was given two numbers n and s. He was asked to create a sequence of n non-negative integers such that the median of the sequence is as large as possible and that sum of all numbers of the sequence is s. Can you help Shiven find the maximum possible median of such a sequence?\nNote: The definition of the median is the \\( \\left\\lceil \\frac{n}{2}\\right\\rceil^{th} \\) element of a sequence noted in the ascending order\nInput constraints # \\(1 \\le n \\le 10^{8}\\) Input format # The only line of input contains two space-separated integers n and s\nOutput Format # Output a single integer that is the maximum median of such a sequence.\nSample input and output # Sample Input Sample Output 7 17 4 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n, s; printf(\u0026#34;Enter two numbers: \u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;s); int m = n / 2 + 1; int ans = s / m; printf(\u0026#34;The maximum value of median is: %d\\n\u0026#34;, ans); return 0; } "}]