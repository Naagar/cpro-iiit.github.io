[{"id":0,"href":"/posts/installingGCC/","title":"Installing GCC","section":"Resources","content":" Installing gcc # This tutorial will be a quick walkthrough on installing gcc on different OS. We recommend you try installing gcc on your own before the start of classes. If, for some reason, you are unable to install gcc, then we will help you in the first tutorial session. We also recommend you install some text editor (VS Code for example).\nWe recommend the usage of Linux as this would be advantageous for your future courses as well. linux Linux (Ubuntu 22.04) # For Linux-based systems, gcc usually comes installed by default.\nCheck if gcc is installed on Ubuntu by running the command: $ gcc --version\nIf running this shows a version (For eg 13.1 or say any other version) then you are good to go.\nOtherwise, if you see an error that reads “command not found” or something similar, run the following commands:\n$ sudo apt update\n$ sudo apt install build-essential\nAfter running this, check if gcc is installed by running:\n$ gcc --version\nmac MacOS # For Mac-based systems, first start with installing homebrew (if not installed).\n$ /bin/bash -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026quot;\nAfter installing homebrew, you simply have to run:\n$ brew install gcc\nAfter running this, check if gcc is installed by running:\n$ gcc --version\nThis should show the path in which gcc has been installed on your Mac.\nwindows Windows # In Windows, C programs can be compiled using the MinGW C compiler.\nFor installation details, refer: https://www.scaler.com/topics/c/c-compiler-for-windows/\nAlternatively, you can install WSL or a Virtual Machine to have a Linux-like environment.\n"},{"id":1,"href":"/docs/course_material/project/","title":"Project","section":"Course Material","content":" Project (Optional) # In the project, you will use all the features of C language and a few more new tools (git, make) to build a game. You will be given some basic code, with tasks for implementing certain functions. The project will help you build your confidence in large-scale programming with 1000+ lines of code. We will provide reference material for learning useful tools like git/make. You must learn some of these yourself (TAs could volunteer to help).\nProject Repositories: All documentation regarding the project will be available at the repositories bellow. Students not registered for bonus marks, can clone the repository, try to solve the problem and test it in their local computer. Registered students will have to push their changes to their assigned repos in github.\nHello C Snake Game Project Grading: As mentioned the project is optional and you can score 100% marks in this course without doing it. The project is mainly to do something fun with programming. We will also provide 5% bonus marks which will be evaluated based on a viva after the endsem. If a student doing the project gets a total of more than 100, we will round it down to 100. We will release the problem statements/code for the project for everyone and you are encoraged to try it out even if you have not opted for bonus marks.\nHonour Code: The grading is based on viva and if we find that you don\u0026rsquo;t understand your code, then there will be a negative marking!. We will also have intermediate evaluations to test wheather you are regularly solving the problem. Failing intermediate evals, will result in negative marking and loss of eligibility for bonus marks.\nOther Requirements: You will need to create a GitHub account (https://github.com/). This is only because they provide some tools which allow us to grade and give feedback easily.\n"},{"id":2,"href":"/posts/linux_tools_course/","title":"Linux Tools Course","section":"Resources","content":"To get familiar with Linux tools that are generally helpful for computer science, please go through the material here: https://missing.csail.mit.edu/\n"},{"id":3,"href":"/posts/linear_algebra_in_c/","title":"Linear Algebra in C","section":"Resources","content":"See implementation of a linear algebra library in C here: https://www.andreinc.net/2021/01/20/writing-your-own-linear-algebra-matrix-library-in-c\n"},{"id":4,"href":"/posts/video_lectures/","title":"Video Lectures from Elsewhere","section":"Resources","content":"You can find some video lectures on c programming from other universities bellow:\nUni. of Nebraska, Lincon Harvard\nhttps://cs50.harvard.edu/x/2023/\nhttps://www.youtube.com/watch?v=8mAITcNt710 "},{"id":5,"href":"/docs/course_material/lectures/4_10/","title":"01 Typedef, Struct Initialization, Passing Pointers","section":"Lectures","content":" 01 Typedef, Struct Initialization # Struct without Typedef # #include\u0026lt;stdio.h\u0026gt; struct rectangle { float length; float breadth; }; float compute_area(struct rectangle r) { return r.length * r.breadth; } void print_rectangle(struct rectangle r) { printf(\u0026#34;Rectangle with length %f and breadth %f\\n\u0026#34;, r.length, r.breadth); } int main() { struct rectangle rect = { 1.5, 3.2 }; // Initializer print_rectangle(rect); printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(rect) ); } Struct with Typedef # #include\u0026lt;stdio.h\u0026gt; typedef struct rectangle { float length; float breadth; } rectangle; float compute_area(rectangle r) { return r.length*r.breadth; } rectangle scale(rectangle r, float s) { r.length = r.length*s; r.breadth = r.breadth*s; return r; } int main() { rectangle rect = { .breadth = 1.0, .length = 3.0} /* {3.0, 1.0 }*/; // rect.length = 3.2; // rect.breadth = 1.2; printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(rect)); rectangle rp = scale(rect, 5); printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(*rp)); printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(rect)); } Passing using pointers # #include\u0026lt;stdio.h\u0026gt; typedef struct rectangle { float length; float breadth; } rectangle; float compute_area(rectangle r) { return r.length*r.breadth; } rectangle* scale(rectangle* r, float s) { r-\u0026gt;length = r-\u0026gt;length*s; r-\u0026gt;breadth = r-\u0026gt;breadth*s; return r; } int main() { rectangle rect = { .breadth = 1.0, .length = 3.0} /* {3.0, 1.0 }*/; // rect.length = 3.2; // rect.breadth = 1.2; printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(rect)); rectangle* rp = scale(\u0026amp;rect, 5); printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(*rp)); printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(rect)); } "},{"id":6,"href":"/docs/course_material/lectures/6_10/","title":"02 Strings and Enums","section":"Lectures","content":" 02 Strings and Enums # Strings in C # as a pointer to char char *p = \u0026#34;abcde\u0026#34;; as an array of char char s[] = \u0026#34;abcde\u0026#34;; print(\u0026#34;%d %d\u0026#34;, sizeof(p), sizeof(s)); String Function Implementation # #include \u0026#34;stdio.h\u0026#34; int strlenB(char* s) { int i = 0; while (s[i] != \u0026#39;\\0\u0026#39;) { i++; } return i; } char* strcpyB(char *s, char *d) { int len_s = strlenB(s); for(int i = 0; i \u0026lt;= len_s;i++) { d[i] = s[i]; } return d; } char* str_rev(char *s, char *d) { int len_s = strlenB(s); for(int i = 0; i\u0026lt; len_s; i++) { d[i] = s[len_s - 1 - i]; } d[len_s] = \u0026#39;\\0\u0026#39;; return d; } int main() { char *p = \u0026#34;xyz\\0dsalkfjds\u0026#34;; char s[] = \u0026#34;abcde\\0kjdakfjsh\u0026#34;; // abcde\\0 // printf(\u0026#34;%d %d\\n\u0026#34;,sizeof(p),sizeof(s)); // printf(\u0026#34;%s %s\\n\u0026#34;,p, s); // printf(\u0026#34;%d %d\\n\u0026#34;, strlen(p), strlen(s)); // strcpy(s,p); printf(\u0026#34;%s\\n\u0026#34;,str_rev(p, s)); return 1; } String Functions # #include \u0026lt;string.h\u0026gt;\nint strlen(char *s): returns the length of the string pointed by s (ie lenth upto the first \\0 in memory). char* strcat(char* s1, char* s2): concatenates s1 with s2, stores it in s1 and returns s1. int strcmp(char *s1,char *s2): returns negative int if s1 is lex. smaller than s2, returns 0 if equal, returns positive int if s1 is lex. greater than s2. char* strcpy(char* s1, char* s2): copies s2 in to s1 and returns s1. Social Network # Name Age Rel Status Friends Alice 24 Single Diestel, Eve Bob 28 Maried Alice Charlie 20 Single Diestel Diestel 27 Not Mentioned Alice, Eve, Charlie Eve 25 Engaged Diestel, Alice Define a Person (Profile) # struct Person { char name[100]; int age; int rel_status; }; Implemeting Rel Status as int, requires us to keep in mind the mapping between Single, Maried, Not Mentioned, Engaged and integers.\nCan we specify this in code?? # Enums # typedef enum Weekday { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday } Weekday; Weekday today = Wednesday; printf(\u0026#34;Day %d\u0026#34;,today+1); printf(\u0026#34;Size of enum variable = %d bytes\u0026#34;, sizeof(today));\tEnums : Changing default values # typedef enum Weekday { Sunday = 1, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday } Weekday; Weekday today = Wednesday; printf(\u0026#34;Day %d\u0026#34;,today+1); Enums : interchangable with int # #include \u0026#34;stdio.h\u0026#34; typedef enum Weekday { Sunday = 5, Monday = 3, Tuesday, Wednesday = 2, Thursday, Friday, Saturday } Weekday; int main() { Weekday today = Wednesday;; printf(\u0026#34;Day %d\\n\u0026#34;,today+1); printf(\u0026#34;Size of enum variable = %d bytes\u0026#34;, sizeof(today));\treturn 0 ; } Define a Person (Profile) # enum RelStatus { NotMentioned, Single, Engaged, Married }; struct Person { char name[100]; int age; enum RelStatus status; }; Practice Problems # Implement str_rev in place. ie. it takes only one string (char *) as argument, reverses it. "},{"id":7,"href":"/docs/course_material/lectures/9_10/","title":"03 Macros, More Intializers in Social Nets","section":"Lectures","content":" 03 Macros, More Intializers in Social Nets # Social Nets # typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Person { char name[100]; int age; RelStatus relstatus; struct Person* friends[5]; } Person; typedef struct SocialNet { Person members[100]; int size; } SocialNet; Social Nets with Macros # #define MAX_FRIENDS 5 #define MAX_MEMBERS 100 #define MAX_NAME_LEN 100 typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Person { char name[MAX_NAME_LEN]; int age; RelStatus relstatus; struct Person* friends[MAX_FRIENDS]; } Person; typedef struct SocialNet { Person members[MAX_MEMBERS]; int size; } SocialNet; Intitializer # Name Age Rel Status Alice 24 Not Mentioned Bob 28 Maried Charlie 20 Single int main() { SocialNet social_net = { .members = { { \u0026#34;Alice\u0026#34;, 24, NotMentioned}, { \u0026#34;Bob\u0026#34;, 28, Married}, { \u0026#34;Charlie\u0026#34;, 20, Single}, } , .size = 3 }; print_network(social_net); return 0; } Print Person # void print_person(struct Person p) { // TODO (solution at the end of page) } void print_network(SocialNet social_net) { printf( \u0026#34;----------------------------------------------\\n\u0026#34; \u0026#34;Name\\t\\tAge \\t Rel Status\\n\u0026#34; \u0026#34;----------------------------------------------\\n\u0026#34;); for (int i=0;i \u0026lt;social_net.size; i++) { print_person(social_net.members[i]); } printf(\u0026#34;----------------------------------------------\\n\u0026#34;); } Finding a person by name # Person* find_person(char* name1, SocialNet *sn) { // TODO (solution at the end of page) } HW: Check Mutual Friends by name # bool check_mutual_friends(char *name1, char *name2, SocialNet *sn) { // TODO p and q are mutual friends if q is in the friend list of p // and p is in the friend list of q } Full Code with Solutions # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Person { char name[100]; int age; RelStatus relstatus; int count_friends; struct Person *friends[5]; } Person; typedef struct SocialNet { Person members[80]; int size; } SocialNet; Person* find_person(char* name1, SocialNet *sn) { for(int i = 0; i \u0026lt; sn-\u0026gt;size; i++) { if ( strcmp(sn-\u0026gt;members[i].name, name1) == 0) { return \u0026amp;(sn-\u0026gt;members[i]); } } return NULL; } void print_person(Person p) { char status_string[][15] = { \u0026#34;Not Mentioned\u0026#34;, \u0026#34;Single\u0026#34;, \u0026#34;Married\u0026#34;, \u0026#34;Engaged\u0026#34; }; printf(\u0026#34;%s\\t\\t%d\\t%s\\n\u0026#34;, p.name, p.age, status_string[p.relstatus]); } void print_network(SocialNet social_net) { printf( \u0026#34;----------------------------------------------\\n\u0026#34; \u0026#34;Name\\t\\tAge \\t Rel Status\\n\u0026#34; \u0026#34;----------------------------------------------\\n\u0026#34;); for (int i=0;i \u0026lt;social_net.size; i++) { print_person(social_net.members[i]); } printf(\u0026#34;----------------------------------------------\\n\u0026#34;); } int main() { SocialNet social_net = { .members = { { \u0026#34;Alice\u0026#34;, 24, NotMentioned}, { \u0026#34;Bob\u0026#34;, 28, Married}, { \u0026#34;Charlie\u0026#34;, 20, Single}, } , .size = 3 }; print_network(social_net); print_person(*find_person(\u0026#34;Bob\u0026#34;, \u0026amp;social_net)); return 0; } "},{"id":8,"href":"/docs/course_material/lectures/11_10/","title":"04 Linked Lists","section":"Lectures","content":" 04 Linked Lists # Problem: Large Arrays! # #define MAX_MEMBERS 100 typedef struct SocialNet { Person members[MAX_MEMBERS]; int size; } SocialNet; Linked List: A array that grows according to needs # Linked List: Code # typedef struct Node { Person data; struct Node* next; } Node; typedef Node* LinkedList; Node third = { {\u0026#34;Alice\u0026#34;, 22}, NULL }; Node second = { {\u0026#34;Bob\u0026#34;, 26}, \u0026amp;third }; Node first = { {\u0026#34;Charlie\u0026#34;, 20}, \u0026amp;second }; LinkedList L = \u0026amp;first; Size of a Liniked List # int size(LinkedList l) { int s = 0; while (l != NULL) { l = l-\u0026gt;next; s ++; } return s; } A recursive solution # int size(LinkedList l) { return l==NULL? 0: size(l-\u0026gt;next) + 1; } Printing elements of a linked list # void print_list(LinkedList l) { while (l != NULL) { printf(\u0026#34;%s\\t\\t%d\\n\u0026#34;,l-\u0026gt;data.name, l-\u0026gt;data.age); l = l-\u0026gt;next; } } Find the element at the ith position # Person* element_at(int pos, LinkedList l) { int s = 0; while (l != NULL) { if (s == pos) return \u0026amp;(l-\u0026gt;data); l = l-\u0026gt;next; s ++; } return NULL; } A recursive solution # Person* element_at_recursive(int pos, LinkedList l) { // TODO if (l==NULL) return NULL; if (pos == 0) {return \u0026amp;(l-\u0026gt;data);} else { return element_at(pos-1, l-\u0026gt;next); } // return pos == 0 ? \u0026amp;(l-\u0026gt;data): element_at(pos-1, l-\u0026gt;next); } Append element to end of the list # LinkedList append(Person p, LinkedList l) { // Node D = {{\u0026#34;Raj\u0026#34;, 18}, NULL}; Local Variable! Will not work. Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = NULL; if (l == NULL) return D; // if l is empty just return D. while (l-\u0026gt;next != NULL) { l = l-\u0026gt;next; } l-\u0026gt;next = D; return l; } Full code # #include \u0026#34;stdio.h\u0026#34; #include \u0026#34;stdlib.h\u0026#34; #define MAX_NAME_LEN 100 typedef struct Person { char name[MAX_NAME_LEN]; int age; } Person; typedef struct Node { Person data; struct Node* next; } Node; typedef Node* LinkedList; void print_list(LinkedList l) { printf(\u0026#34;-----------------------------------\\n\u0026#34;); while (l != NULL) { printf(\u0026#34;%s\\t\\t%d\\n\u0026#34;,l-\u0026gt;data.name, l-\u0026gt;data.age); l = l-\u0026gt;next; } printf(\u0026#34;-----------------------------------\\n\u0026#34;); } int size(LinkedList l) { int s = 0; while (l != NULL) { l = l-\u0026gt;next; s ++; } return s; // Simpler recursive solution // return l==NULL? 0: size(l-\u0026gt;next) + 1; } Person* element_at(int pos, LinkedList l) { int s = 0; while (l != NULL) { if (s == pos) return \u0026amp;(l-\u0026gt;data); l = l-\u0026gt;next; s ++; } return NULL; } Person* element_at_recursive(int pos, LinkedList l) { // TODO if (l==NULL) return NULL; if (pos == 0) {return \u0026amp;(l-\u0026gt;data);} else { return element_at(pos-1, l-\u0026gt;next); } // return pos == 0 ? \u0026amp;(l-\u0026gt;data): element_at(pos-1, l-\u0026gt;next); } LinkedList append(Person p, LinkedList l) { // Node D = {{\u0026#34;Raj\u0026#34;, 18}, NULL}; Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = NULL; if (l == NULL) return D; while (l-\u0026gt;next != NULL) { l = l-\u0026gt;next; } l-\u0026gt;next = D; return l; } int main() { Node third = { {\u0026#34;Alice\u0026#34;, 22}, NULL }; Node second = { {\u0026#34;Bob\u0026#34;, 26}, \u0026amp;third }; Node first = { {\u0026#34;Charlie\u0026#34;, 20}, \u0026amp;second }; Person D = {\u0026#34;Raj\u0026#34;, 18}; LinkedList l = \u0026amp;first; printf(\u0026#34;Size of the list is %d\\n\u0026#34;, size(l)); print_list(l); printf(\u0026#34;Element at 1st position: %s\\n\u0026#34;, element_at(1,l)-\u0026gt;name); printf(\u0026#34;Element at 2nd position: %s\\n\u0026#34;, element_at(2,l)-\u0026gt;name); append(D, l); printf(\u0026#34;List after appending\\n\u0026#34;); print_list(l); return 0; } HW: Insert element at a position in the list # LinkedList insert(Person p, int pos, LinkedList l) { // TODO } HW: Concatenate 2 lists # LinkedList concat(LinkedList l1, LinkedList l2) { // TODO } HW: Reverse a list # LinkedList reverse(LinkedList l) { // TODO } "},{"id":9,"href":"/docs/course_material/lectures/16_10/","title":"05 Linked Lists Problems","section":"Lectures","content":" 05 Linked Lists Problems # Insert element at a position in the list # LinkedList insert(Person p, int pos, LinkedList l) { if (pos == 0) { Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = l; return D; } else { l-\u0026gt;next = insert(p, pos-1, l-\u0026gt;next); return l; } } Concatenate 2 lists # LinkedList concat(LinkedList l1, LinkedList l2) { if (l1 == NULL) { return l2; } else { l1-\u0026gt;next = concat(l1-\u0026gt;next, l2); return l1; } } Reverse a list # LinkedList reverse(LinkedList l) { int s = size(l); LinkedList l2 = NULL; for (int i = 0; i \u0026lt; s; i++) { l2 = insert(*element_at(s-i-1, l), i, l2); } return l2; } Full code # #include \u0026#34;stdio.h\u0026#34; #include \u0026#34;stdlib.h\u0026#34; #define MAX_NAME_LEN 100 typedef struct Person { char name[MAX_NAME_LEN]; int age; } Person; typedef struct Node { Person data; struct Node* next; } Node; typedef Node* LinkedList; void print_list(LinkedList l) { printf(\u0026#34;-----------------------------------\\n\u0026#34;); while (l != NULL) { printf(\u0026#34;%s\\t\\t%d\\n\u0026#34;,l-\u0026gt;data.name, l-\u0026gt;data.age); l = l-\u0026gt;next; } printf(\u0026#34;-----------------------------------\\n\u0026#34;); } int size(LinkedList l) { int s = 0; while (l != NULL) { l = l-\u0026gt;next; s ++; } // Single line recursive solution // return l == NULL? 0 ; 1 + size(l-\u0026gt;next); return s; } Person* element_at(int pos, LinkedList l) { int s = 0; while (l != NULL) { if (s == pos) return \u0026amp;(l-\u0026gt;data); l = l-\u0026gt;next; s ++; } return NULL; } LinkedList append(Person p, LinkedList l) { if (l == NULL) { // Node D = {{\u0026#34;Raj\u0026#34;, 18}, NULL}; Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = NULL; return D; } else { l-\u0026gt;next = append(p, l-\u0026gt;next); } return l; } LinkedList insert(Person p, int pos, LinkedList l) { if (pos == 0) { Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = l; return D; } else { l-\u0026gt;next = insert(p, pos-1, l-\u0026gt;next); return l; } } LinkedList concat(LinkedList l1, LinkedList l2) { if (l1 == NULL) { return l2; } else { l1-\u0026gt;next = concat(l1-\u0026gt;next, l2); return l1; } } LinkedList reverse(LinkedList l) { int s = size(l); LinkedList l2 = NULL; for (int i = 0; i \u0026lt; s; i++) { l2 = insert(*element_at(s-i-1, l), i, l2); } return l2; } int main() { Node third = { {\u0026#34;Alice\u0026#34;, 22}, NULL }; Node second = { {\u0026#34;Bob\u0026#34;, 26}, \u0026amp;third }; Node first = { {\u0026#34;Charlie\u0026#34;, 20}, \u0026amp;second }; Person D = {\u0026#34;Raj\u0026#34;, 18}; Node l2 = { D, NULL}; LinkedList l = \u0026amp;first; printf(\u0026#34;Size of the list is %d\\n\u0026#34;, size(l)); print_list(l); l = concat( \u0026amp;l2,l); print_list(l); print_list(reverse(l)); // print_list(insert(D,2,l)); // printf(\u0026#34;Element at 1st position: %s\\n\u0026#34;, element_at(1,l)-\u0026gt;name); // printf(\u0026#34;Element at 2nd position: %s\\n\u0026#34;, element_at(2,l)-\u0026gt;name); // append(D, l); // printf(\u0026#34;List after appending\\n\u0026#34;); // print_list(l); return 0; } HW: Reverse a LinkedList in place # void reverse_inplace(LinkedList l) { // If l is a-\u0026gt;b-\u0026gt;c-\u0026gt;d // after executing reverse_inplace(l) // l should become d-\u0026gt;c-\u0026gt;b-\u0026gt;a // the function also should not use another linkedlist or array } HW: Shuffle 2 lists # LinkedList shuffle(LinkedList l1, LinkedList l2) { // If l1 is a-\u0026gt;b-\u0026gt;c-\u0026gt;d and l2 is 1-\u0026gt;2-\u0026gt;3-\u0026gt;4 // shuffle(l1,l2) should return the list // a-\u0026gt;1-\u0026gt;b-\u0026gt;2-\u0026gt;c-\u0026gt;3-\u0026gt;d-\u0026gt;4 } Can you make the above function also in place? That is it should not use any additional array or linked list other than l1 and l2. # HW: Free memory in a LinkedList # void free(LinkedList l) { // free all memory used by a linked list l } HW: Sort a LinkedList # LinkedList sort(LinkedList l) { // sort the linked list l and return it. } HW: Write the social network program using LinkedList # Use a Linked list instead of array in the social network program to save memory. You can used a linked list instead of the members array in Social Net. Can we replace the friends array (in Person) also with a LinkedList?\ntypedef struct Person { char name[100]; int age; RelStatus relstatus; int count_friends; Person* friends[5]; } Person; typedef struct SocialNet { struct Person members[100]; int size; } SocialNet; Implement the check_mutual_friendship function from the last days homework with the social network made using linked lists.\nSolution: Shuffle in place # LinkedList shuffle_inplace(LinkedList l1, LinkedList l2) { Node* head = l1; Node* temp1; Node* temp2; while (l1 != NULL \u0026amp;\u0026amp; l2 != NULL) { temp1 = l1-\u0026gt;next; temp2 = l2-\u0026gt;next; l1-\u0026gt;next = l2; if (temp1 == NULL) { break; } l2-\u0026gt;next = temp1; l1 = temp1; l2 = temp2; } return head; } "},{"id":10,"href":"/docs/course_material/lectures/18_10/","title":"06 More Linked List Problems","section":"Lectures","content":" 06 More Linked List Problems # Reverse a LinkedList in place # LinkedList node_append(Node* n, LinkedList l) { if (l == NULL) { return n; } else { l-\u0026gt;next = node_append(n, l-\u0026gt;next); return l; } } // Recursive Solution LinkedList reverse_in_place(LinkedList l) { if (l == NULL) { return l; } else { LinkedList rev = reverse_in_place(l-\u0026gt;next); l-\u0026gt;next = NULL; rev = node_append(l, rev); return rev; } } Free memory in a LinkedList # void free_linked_list(LinkedList l) { if (l == NULL) { return; } else { LinkedList tail = l-\u0026gt;next; free(l); free_linked_list(tail); } } Sort a LinkedList # // assuming a \u0026lt; b // swaping is done by copy the data field in Node LinkedList swap(LinkedList l, int a, int b) { LinkedList head = l; Person temp; Node* a_ptr; Node* b_ptr; // Find above while(a \u0026gt;= 1) { l = l-\u0026gt;next; a--; b--; } a_ptr = l; while(b \u0026gt;= 1) { l = l-\u0026gt;next; b--; } b_ptr = l; temp = a_ptr-\u0026gt;data; a_ptr-\u0026gt;data = b_ptr-\u0026gt;data; b_ptr-\u0026gt;data = temp; return head; } LinkedList sort(LinkedList l) { // sort the linked list l and return it. // use swap to implement sorting } Write the social network program using LinkedList # Use a Linked list instead of array in the social network program to save memory. You can used a linked list instead of the members array in Social Net. Can we replace the friends array (in Person) also with a LinkedList?\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Person { char name[100]; int age; RelStatus relstatus; int count_friends; struct Person* friends[5]; } Person; typedef struct Node { Person data; struct Node* next; } Node; typedef Node* LinkedList; typedef struct SocialNet { LinkedList members; int size; } SocialNet; void print_person(struct Person p) { char status_string[][20] = { \u0026#34;Not Mentioned\u0026#34;, \u0026#34;Single\u0026#34;, \u0026#34;Engaged\u0026#34;, \u0026#34;Married\u0026#34; }; printf(\u0026#34;%s\\t\\t%d\\t%s\\t\\t\\t\u0026#34;, p.name, p.age, status_string[p.relstatus]); for (int i = 0; i \u0026lt; p.count_friends; i++) { printf(\u0026#34;%s, \u0026#34;,p.friends[i]-\u0026gt;name); } printf(\u0026#34;\\n\u0026#34;); } void print_network(SocialNet social_net) { LinkedList l = social_net.members; printf( \u0026#34;-------------------------------------------------------------------\\n\u0026#34; \u0026#34;Name\\t\\tAge \\tRel Status\\t\\tFriends\\n\u0026#34; \u0026#34;-------------------------------------------------------------------\\n\u0026#34;); while (l!=NULL) { print_person(l-\u0026gt;data); l = l-\u0026gt;next; } printf( \u0026#34;-------------------------------------------------------------------\\n\u0026#34;); } Person* find_person(char* name, SocialNet *sn) { // TODO LinkedList l = sn-\u0026gt;members; while(l!= NULL) { if (strcmp(l-\u0026gt;data.name, name) == 0) { return \u0026amp;(l-\u0026gt;data); } l = l-\u0026gt;next; } return NULL; } bool check_mutual_friendship(char* name1, char* name2, SocialNet* sn) { Person* p = find_person(name1, sn); Person* q = find_person(name2, sn); bool q_in_fl_of_p = false; bool p_in_fl_of_q = false; for(int i =0; i\u0026lt; p-\u0026gt;count_friends; i++) { if (q == p-\u0026gt;friends[i]) { q_in_fl_of_p = true; } } for(int i =0; i\u0026lt; q-\u0026gt;count_friends; i++) { if (p == q-\u0026gt;friends[i]) { p_in_fl_of_q = true; } } if (p_in_fl_of_q \u0026amp;\u0026amp; q_in_fl_of_p) { return true; } else { return false; } } LinkedList append(Person p, LinkedList l) { if (l == NULL) { // Node D = {{\u0026#34;Raj\u0026#34;, 18}, NULL}; Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = NULL; return D; } else { l-\u0026gt;next = append(p, l-\u0026gt;next); } return l; } Person* element_at(int pos, LinkedList l) { int s = 0; while (l != NULL) { if (s == pos) return \u0026amp;(l-\u0026gt;data); l = l-\u0026gt;next; s ++; } return NULL; } int main() { SocialNet social_net = { .members=NULL, .size = 0}; Person A = { \u0026#34;Alice\u0026#34;, 24, Single, 2}; Person B = { \u0026#34;Bob\u0026#34;, 20, Engaged, 0}; Person C = { \u0026#34;Charlie\u0026#34;, 26, Married, 1}; social_net.members = append( A,social_net.members); social_net.members = append( B,social_net.members); social_net.members = append( C,social_net.members); //social_net.members[0].friends[0] = \u0026amp;(social_net.members[1]); // social_net.members[0].friends[1] = \u0026amp;(social_net.members[2]); social_net.members-\u0026gt;data.friends[0] = element_at(1, social_net.members); social_net.members-\u0026gt;data.friends[1] = element_at(2, social_net.members); // social_net.members[2].friends[0] = \u0026amp;(social_net.members[1]); element_at(2, social_net.members)-\u0026gt;friends[0] = element_at(0, social_net.members); print_network(social_net); print_person(*find_person(\u0026#34;Alice\u0026#34;, \u0026amp;social_net)); print_person(*find_person(\u0026#34;Bob\u0026#34;, \u0026amp;social_net)); print_person(*find_person(\u0026#34;Charlie\u0026#34;, \u0026amp;social_net)); printf(\u0026#34;Is Alice and Charlie mutual friends: %d\\n\u0026#34;, check_mutual_friendship(\u0026#34;Alice\u0026#34;, \u0026#34;Charlie\u0026#34;, \u0026amp;social_net)); printf(\u0026#34;Is Alice and Bob mutual friends: %d\\n\u0026#34;, check_mutual_friendship(\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026amp;social_net)); return 0; } Implement the check_mutual_friendship function from the last days homework with the social network made using linked lists.\nShuffle in place # // If l1 is a-\u0026gt;b-\u0026gt;c-\u0026gt;d and l2 is 1-\u0026gt;2-\u0026gt;3-\u0026gt;4 // shuffle(l1,l2) should return the list // a-\u0026gt;1-\u0026gt;b-\u0026gt;2-\u0026gt;c-\u0026gt;3-\u0026gt;d-\u0026gt;4 LinkedList shuffle_inplace(LinkedList l1, LinkedList l2) { Node* head = l1; Node* temp1; Node* temp2; while (l1 != NULL \u0026amp;\u0026amp; l2 != NULL) { temp1 = l1-\u0026gt;next; temp2 = l2-\u0026gt;next; l1-\u0026gt;next = l2; if (temp1 == NULL) { break; } l2-\u0026gt;next = temp1; l1 = temp1; l2 = temp2; } return head; } "},{"id":11,"href":"/docs/course_material/lectures/27_10/","title":"07 Commandline Args \u0026 Multifile Programming","section":"Lectures","content":" 07 Commandline Args \u0026amp; Multifile Programming # Commandline Argument # #include \u0026#34;stdio.h\u0026#34; int main(int argc, char* argv[]) { printf(\u0026#34;The number of arguments is %d\\n\u0026#34;, argc); for (int i = 0; i \u0026lt; argc; i++) { printf(\u0026#34;%d Argument: %s\\n\u0026#34;, i, argv[i]); } return 0; } Write a program that takes the First Name Last Name Age as commandline arguments and prints it as follows First Name: Last name : Age : /// Command Line Arguments // Write a program that takes the First Name Last Name Age // as commandline arguments and prints it as follows // First Name: \u0026lt;first arg\u0026gt; // Last name : \u0026lt;sec arg\u0026gt; // Age : \u0026lt;third arg\u0026gt; #include \u0026#34;stdio.h\u0026#34; int main(int argc, char* argv[]) { if (argc != 4) { printf(\u0026#34;Incorrect number of arguments provided.\\n\u0026#34;); return 0; } printf(\u0026#34;First Name:\\t%s\\n\u0026#34;, argv[1]); printf(\u0026#34;Last Name :\\t%s\\n\u0026#34;, argv[2]); printf(\u0026#34;Age :\\t%s\\n\u0026#34;, argv[3]); return 0; } Multifile Programming # Code listed bellow also available at https://github.com/cpro-iiit/cpro-iiit.github.io/tree/main/lecs/multifile_progs/sample.\nProgram need to be compiled with the command:\ngcc main.c linked_list.c social_net.c linked_list.h # typedef struct Node Node; typedef Node* LinkedList; typedef struct Person Person; struct Node { struct Person* data; struct Node* next; }; LinkedList append(Person* p, LinkedList l); int size(LinkedList l); linked_list.c # #include \u0026#34;linked_list.h\u0026#34; #include \u0026#34;stdlib.h\u0026#34; int size(LinkedList l) { return l == NULL? 0: 1+size(l-\u0026gt;next); } LinkedList append(Person* p, LinkedList l) { if (l == NULL) { Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = NULL; return D; } else { l-\u0026gt;next = append(p, l-\u0026gt;next); } return l; } social_net.h # #include \u0026#34;linked_list.h\u0026#34; #include \u0026#34;stdbool.h\u0026#34; typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Person { char name[100]; int age; RelStatus relstatus; LinkedList friends; } Person; typedef struct SocialNet { LinkedList members; } SocialNet; void print_person(Person* p); void print_network(LinkedList m); Person* find_person(char* name, LinkedList l); char* person_with_most_friends(LinkedList l); int popularity(char* name, LinkedList l); LinkedList delete_by_name(char* name, LinkedList l); LinkedList filterby_age(LinkedList l, int lower, int upper); bool friends_triangle(LinkedList members); bool transitive_friendship(LinkedList members) ; social_net.c # #include \u0026#34;social_net.h\u0026#34; #include \u0026#34;stdio.h\u0026#34; #include \u0026#34;stdlib.h\u0026#34; #include \u0026#34;string.h\u0026#34; void print_person(Person* p) { char status_string[][15] = { \u0026#34;Not Mentioned\u0026#34;,\u0026#34;Single\u0026#34;, \u0026#34;Married\u0026#34;, \u0026#34;Engaged\u0026#34; }; printf(\u0026#34;%s\\t\\t%d\\t%s\\t\\t\\t\u0026#34;, p-\u0026gt;name, p-\u0026gt;age, status_string[p-\u0026gt;relstatus]); LinkedList f = p-\u0026gt;friends; while (f != NULL) { printf(\u0026#34;%s, \u0026#34;, f-\u0026gt;data-\u0026gt;name); f = f-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); } void print_network(LinkedList m) { printf( \u0026#34;------------------------------------------------------\\n\u0026#34; \u0026#34;Name\\t\\tAge\\tStatus\\t\\t\\tFriends\\n\u0026#34; \u0026#34;------------------------------------------------------\\n\u0026#34;); while (m != NULL) { print_person(m-\u0026gt;data); m = m-\u0026gt;next; } printf(\u0026#34;------------------------------------------------------\\n\u0026#34;); } Person* find_person(char* name, LinkedList l) { // Either find the person with a particular name // if not found return NULL while(l!= NULL) { if (strcmp(l-\u0026gt;data-\u0026gt;name, name) == 0) { return l-\u0026gt;data; } l = l-\u0026gt;next; } return NULL; } char* person_with_most_friends(LinkedList l) { // Q A1: Return the name of the person with most friends // (3 marks) int d = 0; Node* n = NULL; while(l != NULL) { int e = size(l-\u0026gt;data-\u0026gt;friends); if (e \u0026gt; d) { d = e; n = l; } l = l-\u0026gt;next; } return n==NULL? \u0026#34;\u0026#34; : n-\u0026gt;data-\u0026gt;name; } int popularity(char* name, LinkedList l) { // Q B1: Return the number of people who has the person // named `name` amoung their friends. (3 marks) int count = 0; while ( l!= NULL) { if (find_person(name, l-\u0026gt;data-\u0026gt;friends) != NULL) { count++; } } return count; } LinkedList delete_by_name(char* name, LinkedList l) { // Q A2: Delete the person named `name` from l (3 marks) if (l == NULL) { return NULL; } else if (strcmp(name, l-\u0026gt;data-\u0026gt;name) == 0) { Node* tail = l-\u0026gt;next; free(l); return tail; } else { l-\u0026gt;next = delete_by_name(name, l-\u0026gt;next); return l; } } LinkedList filterby_age(LinkedList l, int lower, int upper) { // Q B2: Return the link list of people in l with age // between lower and upper (3 marks) LinkedList l2 = NULL; while(l != NULL) { if (l-\u0026gt;data-\u0026gt;age \u0026gt;= lower \u0026amp;\u0026amp; l-\u0026gt;data-\u0026gt;age \u0026lt;= upper) { l2 = append(l-\u0026gt;data, l2); } l = l-\u0026gt;next; } return l2; } bool friends_triangle(LinkedList members) { // Q A3: Check if there is a triangle of friends // ie there exists X, Y, Z such that // Y is a friend of X, Z is a friend of Y, X is a friend of Z // ALso print all such triplets (4 marks) LinkedList f = members; printf( \u0026#34;-----------------------------\\n\u0026#34; \u0026#34;Friend Triangles\\n\u0026#34; \u0026#34;-----------------------------\\n\u0026#34;); bool found = false; while(f != NULL) { LinkedList s = f-\u0026gt;data-\u0026gt;friends; while (s != NULL) { LinkedList t = s-\u0026gt;data-\u0026gt;friends; while (t != NULL) { LinkedList l = t-\u0026gt;data-\u0026gt;friends; while (l != NULL) { if (strcmp(l-\u0026gt;data-\u0026gt;name, f-\u0026gt;data-\u0026gt;name)==0) { printf(\u0026#34;%s-\u0026gt;%s-\u0026gt;%s-\u0026gt;%s\\n\u0026#34;, f-\u0026gt;data-\u0026gt;name, s-\u0026gt;data-\u0026gt;name, t-\u0026gt;data-\u0026gt;name, f-\u0026gt;data-\u0026gt;name); found = true; } l = l-\u0026gt;next; } t = t-\u0026gt;next; } s = s-\u0026gt;next; } f = f-\u0026gt;next; } printf(\u0026#34;-------------------------\\n\u0026#34;); return found; } bool transitive_friendship(LinkedList members) { // Q B3: check if the friendship relation is transitive // ie for any X,Y, Z, if Y is a friend of X and // Z is a friend of Y then Z is a friend of X // Also print all the links that violates transitivity // (4 marks) LinkedList f = members; printf( \u0026#34;-----------------------------\\n\u0026#34; \u0026#34;Links that are not Transitive\\n\u0026#34; \u0026#34;-----------------------------\\n\u0026#34;); bool found = false; while(f != NULL) { LinkedList s = f-\u0026gt;data-\u0026gt;friends; while (s != NULL) { LinkedList t = s-\u0026gt;data-\u0026gt;friends; while (t != NULL) { if (find_person(t-\u0026gt;data-\u0026gt;name, f-\u0026gt;data-\u0026gt;friends) == NULL) { printf(\u0026#34;%s-\u0026gt;%s-\u0026gt;%s, but there is no %s-\u0026gt;%s\\n\u0026#34;, f-\u0026gt;data-\u0026gt;name, s-\u0026gt;data-\u0026gt;name, t-\u0026gt;data-\u0026gt;name, f-\u0026gt;data-\u0026gt;name,t-\u0026gt;data-\u0026gt;name); found = true; } t = t-\u0026gt;next; } s = s-\u0026gt;next; } f = f-\u0026gt;next; } printf(\u0026#34;-------------------------\\n\u0026#34;); return !found; } main.c # #include \u0026#34;social_net.h\u0026#34; #include \u0026#34;stdio.h\u0026#34; int main() { SocialNet s = { NULL }; Person A = {\u0026#34;Alice\u0026#34;, 23, Single, NULL}; Person B ={\u0026#34;Bob\u0026#34;, 26, Engaged, NULL}; Person C = {\u0026#34;Charlie\u0026#34;, 21, NotMentioned, NULL}; Person D ={\u0026#34;Don\u0026#34;, 28, Married, NULL}; s.members = append(\u0026amp;A, s.members); s.members = append(\u0026amp;B, s.members); s.members = append(\u0026amp;C, s.members); s.members = append(\u0026amp;D, s.members); A.friends = append(\u0026amp;B, A.friends); A.friends = append(\u0026amp;C, A.friends); B.friends = append(\u0026amp;D, B.friends); C.friends = append(\u0026amp;D, C.friends); D.friends = append(\u0026amp;A, D.friends); printf(\u0026#34;List of people between ages 24 to 28:\\n\u0026#34;); print_network(filterby_age(s.members, 24, 28)); printf(\u0026#34;The person with most friends is %s.\\n\u0026#34;,person_with_most_friends(s.members)); // For above social network, `friends_triangle(s.members)` // returns `true` and prints // ----------------------------- // Friend Triangles // ----------------------------- // Alice-\u0026gt;Bob-\u0026gt;Don-\u0026gt;Alice // Alice-\u0026gt;Charlie-\u0026gt;Don-\u0026gt;Alice // Bob-\u0026gt;Don-\u0026gt;Alice-\u0026gt;Bob // Charlie-\u0026gt;Don-\u0026gt;Alice-\u0026gt;Charlie // Don-\u0026gt;Alice-\u0026gt;Bob-\u0026gt;Don // Don-\u0026gt;Alice-\u0026gt;Charlie-\u0026gt;Don // ------------------------- friends_triangle(s.members); // For the above social network, `transitive_friendship(s.members)` // returns false and prints // ----------------------------- // Links that are not Transitive // ----------------------------- // Alice-\u0026gt;Bob-\u0026gt;Don, but there is no Alice-\u0026gt;Don // Alice-\u0026gt;Charlie-\u0026gt;Don, but there is no Alice-\u0026gt;Don // Bob-\u0026gt;Don-\u0026gt;Alice, but there is no Bob-\u0026gt;Alice // Charlie-\u0026gt;Don-\u0026gt;Alice, but there is no Charlie-\u0026gt;Alice // Don-\u0026gt;Alice-\u0026gt;Bob, but there is no Don-\u0026gt;Bob // Don-\u0026gt;Alice-\u0026gt;Charlie, but there is no Don-\u0026gt;Charlie // ------------------------- transitive_friendship(s.members); return 0; } Home Work # Fill up the code for the matrix functions bellow and\nHW6: also seperate it out into multiple files (matrix.h, matrix.c, main.c) as we did in class.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct Matrix { int num_rows; int num_cols; float** data; } Matrix; Matrix* create_matrix(int r, int c) { Matrix* m = (Matrix*) malloc(sizeof(Matrix)); m-\u0026gt;num_rows = r; m-\u0026gt;num_cols = c; m-\u0026gt;data = (float**) calloc(r, sizeof(float*)); for (int i =0; i \u0026lt; r; i++) { m-\u0026gt;data[i] = (float*) calloc(c, sizeof(float)); } return m; } void destroy_matrix(Matrix* m) { // HW1: Write code here to free all memory used by the matrix stored in m } Matrix* add_matrix(Matrix* A, Matrix* B) { // HW2: write code here to add the matrices A, B and return a new matrix which has the results. // A, B should remain unmodified. If dimensions doesnt match should return NULL } Matrix* mult_matrix(Matrix* A, Matrix* B) { // HW3: write code here to multiply the matrices A, B and return a new matrix which has the results. // A, B should remain unmodified. If the dimensions doesnt match it should return NULL } Matrix* scalar_mult_matrix(float s, Matrix* M) { // HW4: write code here to multiply the matrix A with a scalar s and return a new matrix which has the results. // A should remain unmodified. } void print_matrix(Matrix* m) { for (int i = 0; i \u0026lt; m-\u0026gt;num_rows; i++) { for (int j = 0; j \u0026lt; m-\u0026gt;num_cols; j++) { printf(\u0026#34;%f\\t\u0026#34;, m-\u0026gt;data[i][j]); } printf(\u0026#34;\\n\u0026#34;); } } int main(int argc, char* argv[]) { // row size will be provided as the first arg // col size will be provided as the second arg // remaining row size * column size args will be the entries // of the matrix in row major order Matrix* m = create_matrix(3,3); print_matrix(m); // HW5: write code to create matrix of the dimension provied in first and second arg // and initialize it with the values provided as the remaing args return 0; } "},{"id":12,"href":"/docs/course_material/lectures/30_10/","title":"08 Advanced Pointers","section":"Lectures","content":" 08 Advanced Pointers # Pointer to Pointer for LinkedList functions # Full Code\nvoid insert_v2(Person p, int pos, LinkedList* l) { *l = insert(p, pos, *l); } void reverse_v2(LinkedList* l) { *l = reverse(*l); } int main() { Node third = { {\u0026#34;Alice\u0026#34;, 22, Single}, NULL }; Node second = { {\u0026#34;Bob\u0026#34;, 26, Married}, \u0026amp;third }; Node first = { {\u0026#34;Charlie\u0026#34;, 20, Engaged}, \u0026amp;second }; Person D = {\u0026#34;Raj\u0026#34;, 18, NotMentioned}; Node l2 = { D, NULL}; Person E = {\u0026#34;Eve\u0026#34;, 28, Married}; Node l3 = { E, NULL}; LinkedList l = \u0026amp;first; printf(\u0026#34;Size of the list is %d\\n\u0026#34;, size(l)); print_list(l); //l = reverse(l); reverse_v2(\u0026amp;l); print_list(l); // l = insert(D,2,l); // Problem1: Write the insert function such that, // we dont need to reassign l to the return value // of the function to update it. That is the // line bellow is equivalent to line above insert_v2(D, 2, \u0026amp;l); insert_v2(E, 3, \u0026amp;l); print_list(l); return 0; } Function Pointers # A variable to store address of functions\nbool check1(Person p) { return p.status == Single \u0026amp;\u0026amp; p.age \u0026lt; 24; } bool check2(Person p) { return p.age \u0026lt;= 26 \u0026amp;\u0026amp; p.age \u0026gt;= 16; } // check_person can store address of check or check_2 bool (*check_person)(Person p) = \u0026amp;check1; Function which takes function as arguments (Higher Order Functions) # Suppose we want to filter person who is Single and age \u0026lt;= 24, how to implement it.\nCopy paste solution # LinkedList filterby_age(LinkedList l, int lower, int upper) { LinkedList l2 = NULL; while(l != NULL) { if (l-\u0026gt;data.age \u0026gt;= lower \u0026amp;\u0026amp; l-\u0026gt;data.age \u0026lt;= upper) { l2 = append(l-\u0026gt;data, l2); } l = l-\u0026gt;next; } return l2; } LinkedList filter_status_age(LinkedList l, RelStatus s, int age) { LinkedList l2 = NULL; while(l != NULL) { if (l-\u0026gt;data.status == s \u0026amp;\u0026amp; l-\u0026gt;data.age \u0026lt;= age) { l2 = append(l-\u0026gt;data, l2); } l = l-\u0026gt;next; } return l2; } Problem: For every condition, we need to write new functions with similar logic.\nFunction pointer Solution # Full Code\nLinkedList filter(LinkedList l, bool (*check)(Person)) { LinkedList l2 = NULL; while(l != NULL) { if ((*check)(l-\u0026gt;data) == true) { l2 = append(l-\u0026gt;data, l2); } l = l-\u0026gt;next; } return l2; } int main() { Node third = { {\u0026#34;Alice\u0026#34;, 22, Single}, NULL }; Node second = { {\u0026#34;Bob\u0026#34;, 26, Married}, \u0026amp;third }; Node first = { {\u0026#34;Charlie\u0026#34;, 20, Engaged}, \u0026amp;second }; Person D = {\u0026#34;Raj\u0026#34;, 18, NotMentioned}; Node l2 = { D, NULL}; Person E = {\u0026#34;Eve\u0026#34;, 28, Married}; Node l3 = { E, NULL}; LinkedList l = \u0026amp;first; print_list(l); bool check1(Person p) { return p.status == Single \u0026amp;\u0026amp; p.age \u0026lt; 24; } bool check2(Person p) { return p.age \u0026lt;= 26 \u0026amp;\u0026amp; p.age \u0026gt;= 16; } bool (*check_person)(Person p) = \u0026amp;check1; // Problem2: Filter the linked list of person // who are Single and less than 24 in age. l = filter(l, \u0026amp;check1); print_list(l); return 0; } Find Best Person # Full Code\nPerson best(LinkedList l, bool (*compare_fn)(Person, Person)) { Person* b = \u0026amp;(l-\u0026gt;data); while(l!= NULL) { if ((*compare_fn)(l-\u0026gt;data, *b)) { b = \u0026amp;(l-\u0026gt;data); // printf(\u0026#34;Best person uptill now is %s\\n\u0026#34;, b-\u0026gt;name); // for debugging } l = l-\u0026gt;next; } return *b; } Inside main\nbool compare_status(Person p, Person q) { // printf(\u0026#34;Compare %s %s\\n\u0026#34;, p.name, q.name); //for debuging return p.status \u0026gt;= q.status; } bool compare_status_age(Person p, Person q) { // printf(\u0026#34;Compare %s %s\\n\u0026#34;, p.name, q.name); // for debugging return (p.status \u0026gt;= q.status) \u0026amp;\u0026amp; (p.age \u0026gt;= q.age); } printf(\u0026#34;Best person is\\n\u0026#34;); print_person(best(l, \u0026amp;compare_status_age)); Homework 1 # Suppose you want to print every person in the linkedlist and would like to customize how each person is printed.\nUse a function pointer as a second argument to print_list function, which prints the person in a customized way. You should be able to pass the pointer to print_person function or any other similar function.\nvoid print_person(Person p) { char status_string[][15] = { \u0026#34;Not Mentioned\u0026#34;,\u0026#34;Single\u0026#34;, \u0026#34;Engaged\u0026#34;, \u0026#34;Married\u0026#34; }; printf(\u0026#34;%s\\t\\t%d\\t%s\\n\u0026#34;,p.name, p.age, status_string[p.status]); } void print_list(LinkedList l) { printf(\u0026#34;-----------------------------------\\n\u0026#34;); while (l != NULL) { print_person(l-\u0026gt;data); l = l-\u0026gt;next; } printf(\u0026#34;-----------------------------------\\n\u0026#34;); } Homework 2 # Suppose you want to find some aggregate value of the elements of the linked list with integer data field. For example, sum of all elements, sum of squares of all elements, sum of absolute values of all elements etc.\nWrite an aggregate function which takes the linked list and a function pointer as arguments. The function pointer should be able to point to functions which implement any of the above functionalites. The aggregate function should return the aggregate value.\ntypedef struct Node { int data; struct Node* next; } Node; typedef Node* LinkedList; // Write functions to find sum of all elements, // sum of squares of all elements, sum of absolute // values of all elements // Generalize above functions to get an agregate function // which the takes the a function poiner where the // aggregation method can be passed. int aggregate(LinkedList l, /* function pointer here */) { // code for aggregae here } Full Code # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #define MAX_NAME_LEN 100 typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Person { char name[MAX_NAME_LEN]; int age; RelStatus status; } Person; typedef struct Node { Person data; struct Node* next; } Node; typedef Node* LinkedList; void print_person(Person p) { char status_string[][15] = { \u0026#34;Not Mentioned\u0026#34;,\u0026#34;Single\u0026#34;, \u0026#34;Engaged\u0026#34;, \u0026#34;Married\u0026#34; }; printf(\u0026#34;%s\\t\\t%d\\t%s\\n\u0026#34;,p.name, p.age, status_string[p.status]); } void print_list(LinkedList l) { printf(\u0026#34;-----------------------------------\\n\u0026#34;); while (l != NULL) { print_person(l-\u0026gt;data); l = l-\u0026gt;next; } printf(\u0026#34;-----------------------------------\\n\u0026#34;); } int size(LinkedList l) { int s = 0; while (l != NULL) { l = l-\u0026gt;next; s ++; } return s; } Person* element_at(int pos, LinkedList l) { int s = 0; while (l != NULL) { if (s == pos) return \u0026amp;(l-\u0026gt;data); l = l-\u0026gt;next; s ++; } return NULL; } LinkedList append(Person p, LinkedList l) { if (l == NULL) { // Node D = {{\u0026#34;Raj\u0026#34;, 18}, NULL}; Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = NULL; return D; } else { l-\u0026gt;next = append(p, l-\u0026gt;next); } return l; } LinkedList insert(Person p, int pos, LinkedList l) { if (pos == 0) { Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = l; return D; } else { l-\u0026gt;next = insert(p, pos-1, l-\u0026gt;next); return l; } } void insert_v2(Person p, int pos, LinkedList* l) { *l = insert(p, pos, *l); } LinkedList filterby_age(LinkedList l, int lower, int upper) { LinkedList l2 = NULL; while(l != NULL) { if (l-\u0026gt;data.age \u0026gt;= lower \u0026amp;\u0026amp; l-\u0026gt;data.age \u0026lt;= upper) { l2 = append(l-\u0026gt;data, l2); } l = l-\u0026gt;next; } return l2; } LinkedList filter(LinkedList l, bool (*check)(Person)) { LinkedList l2 = NULL; while(l != NULL) { if ((*check)(l-\u0026gt;data) == true) { l2 = append(l-\u0026gt;data, l2); } l = l-\u0026gt;next; } return l2; } LinkedList reverse(LinkedList l) { int s = size(l); LinkedList l2 = NULL; for (int i = 0; i \u0026lt; s; i++) { l2 = insert(*element_at(s-i-1, l), i, l2); } return l2; } void reverse_v2(LinkedList* l) { *l = reverse(*l); } Person best(LinkedList l, bool (*compare_fn)(Person, Person)) { Person* b = \u0026amp;(l-\u0026gt;data); while(l!= NULL) { if ((*compare_fn)(l-\u0026gt;data, *b)) { b = \u0026amp;(l-\u0026gt;data); // printf(\u0026#34;Best person uptill now is %s\\n\u0026#34;, b-\u0026gt;name); // for debugging } l = l-\u0026gt;next; } return *b; } int main() { Node third = { {\u0026#34;Alice\u0026#34;, 22, Single}, NULL }; Node second = { {\u0026#34;Bob\u0026#34;, 26, Married}, \u0026amp;third }; Node first = { {\u0026#34;Charlie\u0026#34;, 20, Engaged}, \u0026amp;second }; Person D = {\u0026#34;Raj\u0026#34;, 18, NotMentioned}; Node l2 = { D, NULL}; Person E = {\u0026#34;Eve\u0026#34;, 28, Married}; Node l3 = { E, NULL}; LinkedList l = \u0026amp;first; printf(\u0026#34;Size of the list is %d\\n\u0026#34;, size(l)); print_list(l); l = reverse(l); reverse_v2(\u0026amp;l); print_list(l); // l = insert(D,2,l); // Problem1: Write the insert function such that, // we dont need to reassign l to the return value // of the function to update it. That is the // line bellow is equivalent to line above insert_v2(D, 2, \u0026amp;l); insert_v2(E, 3, \u0026amp;l); print_list(l); bool compare_status(Person p, Person q) { // printf(\u0026#34;Compare %s %s\\n\u0026#34;, p.name, q.name); //for debuging return p.status \u0026gt;= q.status; } bool compare_status_age(Person p, Person q) { // printf(\u0026#34;Compare %s %s\\n\u0026#34;, p.name, q.name); // for debugging return (p.status \u0026gt;= q.status) \u0026amp;\u0026amp; (p.age \u0026gt;= q.age); } printf(\u0026#34;Best person is\\n\u0026#34;); print_person(best(l, \u0026amp;compare_status_age)); bool check1(Person p) { return p.status == Single \u0026amp;\u0026amp; p.age \u0026lt; 24; } bool check2(Person p) { return p.age \u0026lt;= 26 \u0026amp;\u0026amp; p.age \u0026gt;= 16; } bool (*check_person)(Person p) = \u0026amp;check1; // Problem2: Filter the linked list of person // who are Single and less than 24 in age. l = filter(l, \u0026amp;check2); print_list(l); return 0; } "},{"id":13,"href":"/docs/course_material/lectures/01_11/","title":"09 File Handling","section":"Lectures","content":" 09 File Handling # Opening/Closing a file # #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; /* File pointer to hold reference to our file */ FILE * fPtr; /* * Open file in w (write) mode. \u0026#34;data/file1.txt\u0026#34; is complete path to create file */ fPtr = fopen(\u0026#34;data/file1.txt\u0026#34;, \u0026#34;w\u0026#34;); /* fopen() return NULL if last operation was unsuccessful */ if(fPtr == NULL) { /* File not created hence exit */ printf(\u0026#34;Unable to create file.\\n\u0026#34;); exit(0); } /* Done with this file, close file to release resource */ fclose(fPtr); Reading from file # fgetc() – Used to read single character from file. fgets() – Used to read string from file. fscanf() – Use this to read formatted input from file. fread() – Read block of raw bytes from file. Used to read binary files. Reading # Open a file using fopen() function and store its reference in a FILE pointer say fPtr.\nYou must open file in r(read) mode or atleast mode that support read access.\nRead content from file using any of these functions fgetc(), fgets(), fscanf() or fread(). Finally, close the file using fclose(fPtr).\nReading from file, char by char # do { /* Read single character from file */ ch = fgetc(fPtr); /* Print character read on console */ putchar(ch); } while(ch != EOF); /* Repeat this if last read character is not EOF */ Copying a file with source/destination as commandline arguments # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(int argc, char* argv[]) { if (argc != 3) { printf(\u0026#34;Invalid arguments\\n\u0026#34;); return 0; } char ch; FILE* s = fopen(argv[1], \u0026#34;r\u0026#34;); FILE* d = fopen(argv[2], \u0026#34;w\u0026#34;); /* fopen() return NULL if last operation was unsuccessful */ if(s == NULL || d == NULL) { /* Unable to open file hence exit */ printf(\u0026#34;Unable to open file.\\n\u0026#34;); printf(\u0026#34;Please check whether file exists and you have read privilege.\\n\u0026#34;); return 0; } /* File open success message */ printf(\u0026#34;File opened successfully. Reading file contents character by character. \\n\\n\u0026#34;); do { /* Read single character from file */ ch = fgetc(s); /* Print character read on console */ putchar(ch); fputc(ch, d); } while(ch != EOF); /* Repeat this if last read character is not EOF */ /* Done with this file, close file to release resource */ fclose(s); fclose(d); return 0; } Reading line by line using fgets() # char * fgets(char * str, int num, FILE * stream); #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define BUFFER_SIZE 1000 int main() { /* File pointer to hold reference to our file */ FILE * fPtr; char buffer[BUFFER_SIZE]; int totalRead = 0; int total_chars = 0; /* * Open file in r (read) mode. * \u0026#34;data/file2.txt\u0026#34; is complete file path to read */ fPtr = fopen(\u0026#34;1.c\u0026#34;, \u0026#34;r\u0026#34;); /* fopen() return NULL if last operation was unsuccessful */ if(fPtr == NULL) { /* Unable to open file hence exit */ printf(\u0026#34;Unable to open file.\\n\u0026#34;); printf(\u0026#34;Please check whether file exists and you have read privilege.\\n\u0026#34;); return 0; } /* File open success message */ printf(\u0026#34;File opened successfully. Reading file contents line by line. \\n\\n\u0026#34;); /* Repeat this until read line is not NULL */ while(fgets(buffer, BUFFER_SIZE, fPtr) != NULL) { /* Total character read count */ totalRead = strlen(buffer); total_chars += strlen(buffer); /* Print line read on cosole*/ printf(\u0026#34;%s\u0026#34;, buffer); } printf(\u0026#34;Total number of chars: %d\u0026#34;, total_chars); /* Done with this file, close file to release resource */ fclose(fPtr); return 0; } Home Work # Write a program which takes a file name as command line argument and prints the number of chars, words, lines and paragraphs in the file.\n"},{"id":14,"href":"/docs/course_material/lectures/03_11/","title":"10 Libraries","section":"Lectures","content":" 10 Libraries # C Library Reference\nRandom Number Generation # Random Number Generation Reference\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main(void) { srand(time(NULL)); // use current time as seed for random generator int random_variable = rand(); printf(\u0026#34;Random value on [0,%d]: %d\\n\u0026#34;, RAND_MAX, random_variable); int x; int count[] = { 0,0,0,0,0,0}; for (int i=0; i \u0026lt; 6000; i++) { x = 1+ rand()%6; // printf(\u0026#34;%d \u0026#34;, x); count[x-1]++; } printf(\u0026#34;%d %d %d %d %d %d\\n\u0026#34;, count[0], count[1], count[2], count[3], count[4], count[5]); } Home Work 1 # Write a program to generate and print:\na uniformly random subset of {1, 2, .., n}. Take n as input. a uniformly random subset of {1, 2, .., n} of size k. Take n, k as input. a uniformly random permutation of {1, 2, .., n}. Take n as input. Date Time Clock # Date Time Clock Reference\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;time.h\u0026gt; typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Person { char name[100]; int age; RelStatus relstatus; int count_friends; struct Person* friends[5]; } Person; typedef struct SocialNet { struct Person members[100]; int size; } SocialNet; void print_person(struct Person p) { char status_string[][20] = { \u0026#34;Not Mentioned\u0026#34;, \u0026#34;Single\u0026#34;, \u0026#34;Engaged\u0026#34;, \u0026#34;Maried\u0026#34; }; printf(\u0026#34;%s\\t\\t%d\\t%s\\t\\t\u0026#34;, p.name, p.age, status_string[p.relstatus]); for (int i = 0; i \u0026lt; p.count_friends; i++) { printf(\u0026#34;%s, \u0026#34;,p.friends[i]-\u0026gt;name); } printf(\u0026#34;\\n\u0026#34;); } void print_network(SocialNet social_net) { printf( \u0026#34;----------------------------------------------\\n\u0026#34; \u0026#34;Name\\t\\tAge \\t Rel Status\\t\\t\\tFriends\\n\u0026#34; \u0026#34;----------------------------------------------\\n\u0026#34;); for (int i=0;i \u0026lt;social_net.size; i++) { print_person(social_net.members[i]); } printf(\u0026#34;----------------------------------------------\\n\u0026#34;); } // Person* find_person(char* name1, SocialNet *sn) { // // TODO // } int main() { clock_t now = clock(); SocialNet social_net = { { {\u0026#34;Alice\u0026#34;, 24, NotMentioned}, {\u0026#34;Bob\u0026#34;, 22, Married}, {\u0026#34;Charlie\u0026#34;, 28, Engaged} }, 3 }; social_net.members[0].friends[0] = \u0026amp;(social_net.members[1]); social_net.members[0].friends[1] = \u0026amp;(social_net.members[2]); social_net.members[0].count_friends = 2; social_net.members[2].friends[0] = \u0026amp;(social_net.members[1]); social_net.members[2].count_friends = 1; social_net.members[1].count_friends = 0; print_network(social_net); clock_t later = clock(); printf(\u0026#34;%d %d %f\\n\u0026#34;, later, now, ((float)(later-now)/ CLOCKS_PER_SEC)); return 0; } Home Work 2 # Write a program to print the number of days in the current month.\nWrite a program, which takes an input a date and prints the month calendar where that date belongs.\nFor eg: For today date it should print below:\nNovember 3rd, 2023 Sun Mon Tue Wed Thu Fri Sat 29 30 31 1 2 3* 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 "},{"id":15,"href":"/docs/course_material/lectures/06_11/","title":"11 File I/O: Binary Data","section":"Lectures","content":" 11 Reading\\Writing Binary Data # Store Reciept Management System # srms.h # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;string.h\u0026gt; typedef struct Customer { char name[100]; int phone_no; } Customer; typedef enum PayMode { Cash = 0, Card = 1, UPI = 2 } PayMode; typedef struct Reciept { time_t time; float value; // Customer *customer; int customer_index; PayMode mode; } Reciept; typedef struct Database { Customer customers[100]; Reciept reciepts[1000]; int customer_count; int reciept_count; } Database; int add_customer(char *name, int phone_no, Database *db); Reciept* add_reciept(int value, int c, PayMode mode, Database *db); int find_customer_by_phone_no(int phone, Database *db); srms.c # #include \u0026#34;srms.h\u0026#34; int add_customer(char *name, int phone_no, Database *db) { Customer *c = \u0026amp;(db-\u0026gt;customers[db-\u0026gt;customer_count++]); c-\u0026gt;phone_no = phone_no; strcpy(c-\u0026gt;name, name); return db-\u0026gt;customer_count-1; } Reciept* add_reciept(int value, int c, PayMode mode, Database *db) { time_t now = time(NULL); Reciept* r = \u0026amp;(db-\u0026gt;reciepts[db-\u0026gt;reciept_count++]); r-\u0026gt;customer_index= c; r-\u0026gt;value = value; r-\u0026gt;time = now; r-\u0026gt;mode = mode; return r; } int find_customer_by_phone_no(int phone, Database *db) { Customer *cust = NULL; for(int i =0; i\u0026lt; db-\u0026gt;customer_count; i++) { if(phone == db-\u0026gt;customers[i].phone_no) { cust = \u0026amp;(db-\u0026gt;customers[i]); return i; break; } } return -1; } write_example.c # #include \u0026#34;srms.h\u0026#34; int main() { Database db; db.customer_count = db.reciept_count = 0; int a = add_customer(\u0026#34;Alice\u0026#34;,12345,\u0026amp;db); add_reciept(1000, a, Cash, \u0026amp;db); add_reciept(500, a, UPI, \u0026amp;db); int b = add_customer(\u0026#34;Bob\u0026#34;,5678,\u0026amp;db); add_reciept(700, b, Card, \u0026amp;db); add_reciept(500, b, UPI, \u0026amp;db); FILE* cus_file = fopen(\u0026#34;customers.bin\u0026#34;,\u0026#34;w\u0026#34;); fwrite(\u0026amp;(db.customer_count), sizeof(int), 1, cus_file); fwrite(db.customers, sizeof(Customer), db.customer_count, cus_file); fclose(cus_file); FILE* res_file = fopen(\u0026#34;reciepts.bin\u0026#34;,\u0026#34;w\u0026#34;); fwrite(\u0026amp;(db.reciept_count), sizeof(int), 1, res_file); fwrite(db.reciepts, sizeof(Reciept), db.reciept_count, res_file); fclose(res_file); return 0; } Compile using\ngcc write_example.c srms.c read_example.c # #include \u0026#34;srms.h\u0026#34; int main() { Database db; db.customer_count = db.reciept_count = 0; FILE* cus_file = fopen(\u0026#34;customers.bin\u0026#34;,\u0026#34;r\u0026#34;); fread(\u0026amp;(db.customer_count), sizeof(int), 1, cus_file); fread(db.customers, sizeof(Customer), db.customer_count, cus_file); for (int i = 0; i \u0026lt; db.customer_count; i++) { printf(\u0026#34;%s\\t%d\\n\u0026#34;,db.customers[i].name, db.customers[i].phone_no); } fclose(cus_file); FILE* res_file = fopen(\u0026#34;reciepts.bin\u0026#34;,\u0026#34;r\u0026#34;); fread(\u0026amp;(db.reciept_count), sizeof(int), 1, res_file); fread(db.reciepts, sizeof(Reciept), db.reciept_count, res_file); for (int i = 0; i \u0026lt; db.reciept_count; i++) { printf(\u0026#34;%d\\t%d\\t%f\\t%s\\n\u0026#34;,db.reciepts[i].mode, db.reciepts[i].time, db.reciepts[i].value, db.customers[db.reciepts[i].customer_index].name ); } fclose(cus_file); return 0; } Compile using\ngcc read_example.c srms.c main.c with Home Work # HW1: Modify program bellow to have an exit option, on which it writes customers and reciepts to customers.bin and reciepts.bin from the database and exits.\nHW2: Modify program bellow such that on starting, it should read customers and reciepts from customers.bin and reciepts.bin and fill the database. It should work with the files generated in HW1.\nHW3: Modify the program such that it takes the name of the customers and reciepts file from the command line.\n#include \u0026#34;srms.h\u0026#34; #include \u0026lt;stdbool.h\u0026gt; int main() { Database db; db.customer_count = db.reciept_count = 0; while(true) { // system(\u0026#34;@cls||clear\u0026#34;); // clears the screen printf(\u0026#34;-------------------------------------------------------------------\\n\u0026#34; \u0026#34;Store Reciept Management System\\n\u0026#34; \u0026#34;-------------------------------------------------------------------\\n\u0026#34; \u0026#34;\\tOptions: 0 New Receipt | 1 New Customer | 2 Reciepts by Customer \\n\u0026#34; \u0026#34;\\tStats: %d Customers | %d Reciepts\\n\u0026#34; \u0026#34;-------------------------------------------------------------------\\n\u0026#34; \u0026#34;Enter Option: \u0026#34;, db.customer_count, db.reciept_count); int option; scanf(\u0026#34;%d\u0026#34;, \u0026amp;option); int p, v, m; int c = 0; char name[100]; switch (option) { case 0: printf(\u0026#34;Enter Customer Phone: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;p); c = find_customer_by_phone_no(p, \u0026amp;db); if (c == -1) { printf(\u0026#34;(New Customer) Name: \u0026#34;); scanf(\u0026#34;%s\u0026#34;, name); c = add_customer(name, p, \u0026amp;db); } printf(\u0026#34;Payment Mode (0 for Cash, 1 for Card, 2 for UPI): \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); printf(\u0026#34;Reciept Amount: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;v); add_reciept(v, c, m, \u0026amp;db); break; case 1: printf(\u0026#34;Enter Customer Phone: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;p); c = find_customer_by_phone_no(p, \u0026amp;db); if (c == -1) { printf(\u0026#34;(New Customer) Name: \u0026#34;); scanf(\u0026#34;%s\u0026#34;, name); c = add_customer(name, p, \u0026amp;db); } break; case 2: // input a phone nom printf(\u0026#34;Enter Customer Phone: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;p); c = find_customer_by_phone_no(p, \u0026amp;db); // print out all reicepts curresponding to that customer. printf(\u0026#34;No.\\tValue\\n\u0026#34; \u0026#34;--------------------------\\n\u0026#34;); for(int i =0; i\u0026lt; db.reciept_count; i++) { if (db.reciepts[i].customer_index == c) { printf(\u0026#34;%d\\t%f\\n\u0026#34;, i, db.reciepts[i].value); } } printf(\u0026#34;----------------------\\n\u0026#34;); default: break; } } return 0; } Compile using\ngcc main.c srms.c "},{"id":16,"href":"/docs/course_material/assignments/assignment1/","title":"Assignment - 1","section":"Assignments","content":" Assignment 1 # Question 1 # Problem Description # Given an integer n as input, print its binary representation starting with the most significant bit, i.e. don\u0026rsquo;t print the 0\u0026rsquo;s before the first 1.\nLink to problem on OJ\nInput constraints # \\(0 \\le n \\le 2^{30}\\) Input format # The only line of input contains a single integer n\nOutput Format # Output a continous stream of bits of n starting from the most significant bit.\nSample input and output # Sample Input Sample Output 11 1011 0 0 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); if (x==0){ printf(\u0026#34;0\u0026#34;); return 0; } int mask = 1 \u0026lt;\u0026lt; 30; int flag_first_one = 0; while (mask) { if (x \u0026amp; mask) { printf(\u0026#34;1\u0026#34;); flag_first_one = 1; } else if (flag_first_one) { printf(\u0026#34;0\u0026#34;); } mask \u0026gt;\u0026gt;= 1; } return 0; } Question 2 # Problem Description # Given an integer n between 2 and 100 as input, print all prime numbers from 1 to n (including n) in ascending order.\nLink to problem on OJ\nInput constraints # \\(2 \\le n \\le 100\\) Input format # The only line of input contains a single integer n.\nOutput Format # Output all primes that are less than or equal n in ascending order separated by spaces\nSample input and output # Sample Input Sample Output 2 2 6 2 3 5 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 2; i \u0026lt;= n; i++) { if (i == 2 || i == 3 || i == 5 || i == 7) { printf(\u0026#34;%d \u0026#34;, i); } else if (i % 2 != 0 \u0026amp;\u0026amp; i % 3 != 0 \u0026amp;\u0026amp; i % 5 != 0 \u0026amp;\u0026amp; i % 7 != 0) { printf(\u0026#34;%d \u0026#34;, i); } } return 0; } Question 3 # Problem Description # You are given width and height of a rectangle and you need to print that rectangle.\nLook at samples for more clarity.\nThe corners are to be represented by 'o'.\nThe vertical sides are represented by '|'\nThe horizontal sides are represented by '-'\nThe 'o' counts towards both height and width.\nLink to problem on OJ\nInput constraints # \\(1\\leq width\\leq 1000, 1\\leq height\\leq1000\\) Input format # Two space separated integers, width and height.\nOutput Format # Print the rectangle with the given width and height.\nSample input and output # Sample Input Sample Output 4 5 o--o\n| |\n| |\n| |\no--o 1 1 o 1 3 o\n|\no 3 2 o-o\no-o Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int width, height; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;width, \u0026amp;height); for (int i = 1; i \u0026lt;= height; i++) { for (int j = 1; j \u0026lt;= width; j++) { if ((i == 1 \u0026amp;\u0026amp; (j == 1 || j == width)) || (i == height \u0026amp;\u0026amp; (j == 1 || j == width))) printf(\u0026#34;o\u0026#34;); else if (j == 1 || j == width) printf(\u0026#34;|\u0026#34;); else if (i == 1 || i == height) printf(\u0026#34;-\u0026#34;); else printf(\u0026#34; \u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } return 0; } Question 4 # Problem Description # You are given three integers n, x and y. You need to print the first n terms of the sequence S which starts with \\(S_1=x\\) and \\(S_2=y\\) and further terms are derived from the relation \\(S_i = S_{i-1} \u0026#43; S_{i-2}\\) .\nThe first n values of S are guaranteed to fit in int Link to problem on OJ\nInput constraints # \\(1 \\le n \u0026lt; 50\\) \\(0\\leq x,y\\leq 1e5\\) \\(\\) Input format # The only line of input contains 3 space separated integers n, x and y.\nOutput Format # Output one line containing n space-seperated integers, denoting the first n terms of the sequence S.\nSample input and output # Sample Input Sample Output 5 1 2 1 2 3 5 8 Solution # #include \u0026lt;stdio.h\u0026gt; int main(){ int n, x, y; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;n, \u0026amp;x, \u0026amp;y); for (int i = 1; i \u0026lt;= n; i++) { if(i == 1)printf(\u0026#34;%d \u0026#34;, x); else if(i == 2)printf(\u0026#34;%d \u0026#34;, y); else{ int z = x + y; printf(\u0026#34;%d \u0026#34;, z); x = y; y = z; } } return 0; } Question 5 # Problem Description # Kushagra is in love with pairs. He has a list of numbers where each number has a duplicate pair. Unfortunately, there is one number that does not have a pair. Help him figure out which number it is.\nLink to problem on OJ\nInput constraints # \\(3 \\le n \\le 10^{6}\\) \\(1 \\le A_i \\le 10^{9}\\) \\(\\) Input format # The first line contains an integer n denoting the numbers present in the list.\nThe second line contains n space-separated integers \\([A_0, A_1, A_2,... A_{n-1}]\\) .\nOutput Format # A single integer, the number in the array without a pair\nSample input and output # Sample Input Sample Output 5\n4 5 6 4 5 6 7\n3 3 3 3 3 2 2 3 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int ans = 0; for(int i = 1; i \u0026lt;= n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); ans ^= x; } printf(\u0026#34;%d\\n\u0026#34;, ans); } "},{"id":17,"href":"/docs/course_material/assignments/assignment2/","title":"Assignment - 2","section":"Assignments","content":" Assignment 2 # Question 1 - \u0026ldquo;Doubling Investments\u0026rdquo; # Problem Description # Mitansh is world’s best investor. Whatever the amount he has today, it doubles on the next day.\nInitially he starts, with amount zero. Each day in the morning, he can choose to invest \\(\\$x\\) more in addition to his previous amount \\(\\$y\\) . And on next day, his total amount becomes \\(\\$2(x\u0026#43;y)\\) .\nHowever, he wants to get exactly \\(\\$z\\) on some day.\nWhat is the minimum amount of money he needs to invest, in order to get \\(\\$z\\) at some moment?\nLink to problem on OJ\nInput Format # The first and only line of input contains a single integer \\(z\\) which denotes the desired amount.\nInput constraints # \\(0 \\le z \\le 10^9\\) Output Format # On a single line, output the minimum amount of money that needs to be invested, in order to get exactly \\(\\$z\\) on some day.\nSample inputs and outputs # Sample Input 1\n7 Sample Output 1\n3 Explanation: Mitansh will invest \\(\\$1\\) on the \\(1^{st}\\) , \\(2^{nd}\\) and \\(3^{rd}\\) days. At the beginning of the second day he has \\(\\$2\\) (thanks to the \\(\\$1\\) doubling). He invests \\(\\$1\\) again, leading to the amount being \\(\\$3 \\times 2 = \\$6\\) at the beginning of the third day. He again invests \\(\\$1\\) to obtain the desired amount of \\(\\$7\\) .\nSample Input 2\n16 Sample Output 2\n1 Explanation: Mitansh invests \\(\\$1\\) on the first day which doubles four times to obtain \\(\\$16\\) .\nSample Input 3\n0 Sample Output 3\n0 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n, count = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while(n != 0) { count += (n % 2); n /= 2; } printf(\u0026#34;%d\\n\u0026#34;, count); return 0; } Question 2 - \u0026ldquo;Rotate Edges\u0026rdquo; # Problem Description # Kitansh Mayathwal was thinking of an easy problem which he can apply MOSS on. He came up with this problem.\nYou are given a grid with \\(N\\) rows and \\(N\\) columns. An integer \\(A_{i,j}\\) is written on the square at the \\(i\\) -th row from the top and \\(j\\) -th column from the left. Here, it is guaranteed that \\(A_{i,j}\\) is either 0 or 1.\nAn integer \\(D\\) is also given as input. It is guaranteed that \\(D\\) is either 0 or 1.\nIf \\(D = 0\\) , shift the integers written on the outer squares anticlockwise by one square each, and print the resulting grid.\nIf \\(D = 1\\) . shift the integers written on the outer squares clockwise by one square each, and print the resulting grid.\nHere, the outer squares are those for which at least one of the following conditions is true:\nThe square is present on the first row The square is present on the \\(N\\) -th row The square is present on the first column The square is present on the \\(N\\) -th column Link to problem on OJ\nInput Format # The first line of input contains a single integer \\(N\\) that denotes the size of the grid. The next \\(N\\) lines describe the grid.\nThe \\(i^{th}\\) line describes the \\(i^{th}\\) row of the grid, \\(A_{i, 1}, A_{i, 2}, \\dots, A_{i, N}\\) .\nThe final line of input contains a single integer \\(D\\) which denotes the direction of rotation.\nIn other words, the input is in the following format\nN A_1,1 A_1,2 ... A_1,N A_2,1 A_2,2 ... A_2,N ... A_N,1 A_N,2 ... A_N,N D Input constraints # \\(2 \\le N \\le 100\\) \\(0 \\le A_{i, j} \\le 1 (1 \\le i, j \\le N)\\) \\(0 \\le D \\le 1\\) Output Format # Output the appropriately rotated grid \\(B\\) in the following format:\nB_1,1 B_1,2 ... B_1,N B_2,1 ... ... B_N,1 B_N,2 ... B_N,N Sample inputs and outputs # Sample Input 1\n3 1 1 1 0 1 0 1 0 1 1 Sample Output 1\n0 1 1 1 1 1 0 1 0 Sample Input 2\n3 1 1 1 0 1 0 1 0 1 0 Sample Output 2\n1 1 0 1 1 1 0 1 0 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int a[n][n]; for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; n; j++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); int d; scanf(\u0026#34;%d\u0026#34;, \u0026amp;d); int b[n][n]; if (d) { for (int j = 1; j \u0026lt; n; j++) b[0][j] = a[0][j - 1]; for (int i = 1; i \u0026lt; n; i++) b[i][n - 1] = a[i - 1][n - 1]; for (int j = 0; j \u0026lt; n - 1; j++) b[n - 1][j] = a[n - 1][j + 1]; for (int i = 0; i \u0026lt; n - 1; i++) b[i][0] = a[i + 1][0]; } else { for (int j = 0; j \u0026lt; n - 1; j++) b[0][j] = a[0][j + 1]; for (int i = 0; i \u0026lt; n - 1; i++) b[i][n - 1] = a[i + 1][n - 1]; for (int j = 1; j \u0026lt; n; j++) b[n - 1][j] = a[n - 1][j - 1]; for (int i = 1; i \u0026lt; n; i++) b[i][0] = a[i - 1][0]; } for (int i = 1; i \u0026lt;= n - 2; i++) for (int j = 1; j \u0026lt;= n - 2; j++) b[i][j] = a[i][j]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) printf(\u0026#34;%d \u0026#34;, b[i][j]); printf(\u0026#34;\\n\u0026#34;); } return 0; } Question 3 - \u0026ldquo;Open Doors\u0026rdquo; # Problem Description # Madhav is a very lazy boy. He doesn’t like to do sports. So our PEC instructor has assigned him a task which he should complete in an hour. There are \\(n\\) doors which are all closed initially. Madhav should perform \\(n\\) iterations. In the \\(i^\\text{th}\\) iteration he starts from \\(i^\\text{th}\\) door and goes to each multiple of \\(i\\) untill \\(n\\) i.e. \\((i, 2*i, 3*i…..)\\) and toggles the door. Here toggles means if the door is open, he will close it and if it is closed he will open it.\nAfter all \\(n\\) iterations he has to tell which all doors are still opened. As Madhav is smart, he tries to solve this task using some program. Can you help him with this task ?\nLink to problem on OJ\nInput Format # You will be given only one integer \\(n\\) which are the number of doors.\nInput constraints # \\(1 \\leq n \\leq 10^{10}\\) Subtask 1 : (45 points)\n\\(1 \\leq n \\leq 10^3\\) Subtask 2 : (55 points)\nOriginal Constraints\nOutput Format # Print the open door numbers in increasing order.\nSample inputs and outputs # Sample Input 1\n1 Sample Output 1\n1 Sample Input 2\n4 Sample Output 2\n1 4 Solution # #include\u0026lt;stdio.h\u0026gt; int main() { long long n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); for(int i = 1; 1ll * i * i \u0026lt;= n; i++) printf(\u0026#34;%lld \u0026#34;, i * i); printf(\u0026#34;\\n\u0026#34;); return 0; } Question 4 - \u0026ldquo;Count Palindromes\u0026rdquo; # Problem Description # Given an array \\(A\\) of length \\(N\\) , count the number of non-empty subarrays which are palindromes.\nNote that two subarrays are considered to be different if they either start at different indices or end at different indices. The actual elements in the two subarrays do not influence this.\nA subarray is a contiguous segment of the array which can be obtained be deleting one or more elements from the beginning or the end of the array.\nAn array is said to be a palindrome if it reads the same backwards and forwards. For example, \\([1, 2, 2, 1], [1], [1, 2, 1]\\) are all palindromic arrays.\nLink to problem on OJ\nInput Format # The first line of input contains a single integer \\(N\\) that denotes the size of the array.\nThe second line of input contains \\(N\\) space-separated integers \\(A_1, A_2, \\dots, A_N\\) that describe the array.\nInput constraints # \\(1 \\le N \\le 100\\) \\(0 \\le A_i \\le 10^9\\) Output Format # Output a single positive that denotes the count of the non-empty palindromic subarrays\nSample inputs and outputs # Sample Input 1\n4 1 2 2 1 Sample Output 1\n6 Explanation: The subarrays satisfying the given conditions are: \\([1], [2], [2], [1], [2, 2], [1, 2, 2, 1]\\) Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int a[n]; for (int i = 0; i \u0026lt; n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); int ans = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = i; j \u0026lt; n; j++) { int good = 1; int p = i, q = j; while (p \u0026lt; q) { if (a[p] != a[q]) { good = 0; break; } p++, q--; } ans += good; } } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } Question 5 - \u0026ldquo;PEC woes\u0026rdquo; # Problem Description # As you all know, no student in IIIT likes PEC because they make us do some strange things. Once, they assigned a task to Pratham. They spread some rectangles sheets on the football ground and asked Pratham to calculate the total area covered by the rectangular sheets.\nSo, the task is like you are given some rectangles which are parallel to X or Y axis. Specifically, the i-th sheet covers all points \\((x, y)\\) that satisfy \\(a_i≤x≤b_i\\) and \\(c_i≤y≤d_i\\) . You have to calculate the total area which is covered by the rectangular sheets.\nYou have to calculate the total area which is covered by the recatngular sheets. For more explanation, read the sample test case.\nLink to problem on OJ\nInput Format # First line contains an integer N which denotes the total number of rectangular sheets.\nThe following N lines contain : \\(a_i\\) \\(b_i\\) \\(c_i\\) \\(d_i\\) Input constraints # \\(1 \\leq N \\leq 100\\) \\(0 \\leq a_i \u0026lt; b_i \\leq 100\\) \\(0 \\leq c_i \u0026lt; d_i \\leq 100\\) Output Format # Output a single integer the area covered by rectangular sheets.\nSample inputs and outputs # Sample Input 1\n3 0 5 1 3 1 4 0 5 2 5 2 4 Sample Output 1\n20 Explanation: For an explanation of the sample input 1, refer to this link. We can count that the sheets cover 20 squares.\nSample Input 2\n3 0 1 0 1 0 3 0 5 5 10 0 10 Sample Output 2\n65 Solution # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); const int MAX_N = 101; int g[MAX_N][MAX_N]; memset(g, 0, sizeof(g)); while (n--) { int a, b, c, d; scanf(\u0026#34;%d %d %d %d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d); for (int i = c; i \u0026lt; d; i++) for (int j = a; j \u0026lt; b; j++) g[i][j] = 1; } int ans = 0; for (int i = 0; i \u0026lt;= 100; i++) for (int j = 0; j \u0026lt;= 100; j++) ans += g[i][j]; printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } "},{"id":18,"href":"/c_lib_ref/","title":"C Library Reference","section":"Introduction","content":" C Library Reference # File I/O\nStrings\nDate Time\nRandom Number Generation\nSorting \u0026amp; Searching\nAnother C Library Reference\n"},{"id":19,"href":"/grading_scheme/","title":"Grading Scheme","section":"Introduction","content":" Grading Scheme # Assignments: 30% Quizzes: 20% (2 Quizzes worth 10% each) Mid-Semester Exam: 15% End-Semester Exam: 25% Labs: 10% Bonus*: 5% Note: Total score for a student would be capped at 100% (if the student\u0026rsquo;s score happens to exceed 100) "},{"id":20,"href":"/honor_code/","title":"Honor Code","section":"Introduction","content":" Honor Code # Any form of plagiarism in the Assignments or in the Lab Exams would be heavily penalised and would lead to a 0 score for both students, the student who copied and the one whose code was copied. It is solely your duty to ensure the safety of your code throughout the course .Thus, we will not be entertaining any requests after a student is found guilty of plagiarism.\n"},{"id":21,"href":"/docs/course_material/labs/lab1/","title":"Lab - 1","section":"Labs","content":" Lab 1 (Week of 14 August) # Question 1 - \u0026ldquo;The Last 3\u0026rdquo; # Problem Description # Given an integer n as input, print the last 3 bits of the number in its binary representation starting with the most significant bit among the three.\nNote: The last three bits are the bits corresponding to the,\n\\( 2^2, 2^1 \\) and \\( 2^0 \\) positions (in that order) Link to problem on OJ\nInput constraints # \\(0 \\le n \\le 2^{31}\\) Input format # The only line of input contains a single integer n\nOutput Format # Output three space-separated bits denoting the last three bits of the given number starting with the most significant bit among the three.\nSample input and output # Sample Input Sample Output 11 0 1 1 12 1 0 0 Solution # #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;%d %d %d\\n\u0026#34;, !!(n \u0026amp; 1), !!(n \u0026amp; 2), !!(n \u0026amp; 4)); return 0; } Question 2 - \u0026ldquo;Date Formats\u0026rdquo; # Problem Description # Given a date in DD-MM-YY format, output it in MM-DD-YY format.\nLink to problem on OJ\nInput format # The only line of input contains a valid date in DD-MM-YY format.\nOutput Format # Output the date in MM-DD-YY format with no space separation.\nSample input and output # Sample Input Sample Output 25-03-04 03-25-04 15-08-23 08-15-23 Solution # #include \u0026lt;stdio.h\u0026gt; int main(void) { int d, m, y; scanf(\u0026#34;%d-%d-%d\u0026#34;, \u0026amp;d, \u0026amp;m, \u0026amp;y); printf(\u0026#34;%02d-%02d-%02d\\n\u0026#34;, m, d, y); return 0; } "},{"id":22,"href":"/docs/course_material/labs/lab2/","title":"Lab - 2","section":"Labs","content":" Lab 2 (Week of 21 August) # Question 1 - \u0026ldquo;Divisibility By 3\u0026rdquo; # Problem Description # Given an integer which has n digits, print YES if it is divisible by 3, and NO otherwise.\nNote: The input number will not contain any leading zeroes. Link to problem on OJ\nInput constraints # \\(0 \\le n \\le 1000\\) Input format # The first line of input contains a single integer n denoting the number of digits.\nThe second line of input contains the integer which is n digit long.\nOutput Format # Output YES if the number is divisible by 3 and NO otherwise.\nSample input and output # Sample Input Sample Output 10 1234567890 YES 2 22 NO Solution # #include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); char c; scanf(\u0026#34;%c\u0026#34;, \u0026amp;c); //Skips the initial new line character int sum = 0; while (n--) { scanf(\u0026#34;%c\u0026#34;, \u0026amp;c); sum += c - \u0026#39;0\u0026#39;; } if (sum % 3) printf(\u0026#34;NO\\n\u0026#34;); else printf(\u0026#34;YES\\n\u0026#34;); return 0; } Question 2 - \u0026ldquo;K-Swap\u0026rdquo; # Problem Description # You are given three non-negative integers x, y and k where \\(0 \\le k \\le 31\\) . Replace the first k bits (from the right) of x with the first k bits of y and print the new value of x. In other words, replace the k least significant bits of x with the corresponding bits from y.\nLink to problem on OJ\nInput constraints # \\(0 \\le x,y \\le 2^{31}\\) \\(0 \\le k \\le 31\\) Input format # The only line of input contains 3 space-separated integers x, y and k.\nOutput Format # Output a single integer denoting the new value of x\nSample input and output # Sample Input Sample Output 11 22 3 14 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int x, y, k; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;k); x \u0026amp;= (~0 \u0026lt;\u0026lt; k); y \u0026amp;= ~(~0 \u0026lt;\u0026lt; k); printf(\u0026#34;%d\\n\u0026#34;, x | y); return 0; } "},{"id":23,"href":"/docs/course_material/labs/lab3/","title":"Lab - 3","section":"Labs","content":" Lab 3 (Week of 4 September) # Question 1 - \u0026ldquo;Club Recruitments\u0026rdquo; # Problem Description # A new student club is organising a huge event this semester for silver jubilee celebrations. Initially, they don\u0026rsquo;t have enough members. So, they started recruiting new members in groups.\nMeanwhile, tasks keep coming up within the club. Each club member can work on only one task during the semester.\nIf there is no member available (isn\u0026rsquo;t occupied with a task) when a task arises, it will remain unattended regardless of whether new individuals are recruited later on.\nGiven the chronological order of task arrivals and club members’ recruitment, find the number of tasks that will remain unattended.\nIn the input, a -1 denotes the arrival of a task (which may or may not go unattended depending on whether or not there are currently any free members to take up the task). Similarly, a non-neagative number denotes the number of new recruits.\nNote that once an individual is recruited for the club, they\u0026rsquo;ll always be part of the club. When an individual takes up a task, they\u0026rsquo;ll be occupied with it for the rest of the semester.\nLink to problem on OJ\nInput constraints # \\(1 \\le N \\le 2 \\times 10^5\\) \\(A_i \\in [-1, 10]\\) Input format # The first line of input contains a single integer N that denotes the number of events (either task arrival or new recruitment).\nThe second line of input contains N space-separated integers \\(A_1, A_2, \\dots, A_N\\) that describe the N events as explained in the description.\nOutput Format # Output a single integer that denotes the number of unattended tasks.\nSample input and output # Sample Input Sample Output 3 -1 -1 -1 2 11 -1 -1 2 -1 -1 -1 -1 -1 -1 -1 -1 8 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int pref = 0, ans = 0; for (int i = 0; i \u0026lt; n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); pref += x; if (pref \u0026lt; 0) ans++, pref = 0; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } Question 2 - Current Max # Problem Description # You are given a sequence of N integers \\(A_1,A_2,...,A_N \\) and while looking at the sequence in order from left to right (that is, from index 1 to N), you start by crossing the first number, and you cross a subsequent number if it is strictly greater than every number you crossed before. You keep crossing until you reach the end of the sequence.\nOutput all the numbers you have crossed.\nLink to problem on OJ\nInput constraints # \\(1 \\le N \\le 2 \\times 10^5\\) \\(0 \\le A_i \\le 10^9\\) Input format # The first line of input contains a single integer N that denotes the size of the array.\nThe second line of input contains N space-separated integers \\(A_1,A_2,...,A_N \\) that describe the N elements.\nOutput Format # On the first line, output the count of numbers that you cross out, K. Note that this is a positive number since the first number is always crossed.\nOn the second line, output K space-separated integers denoting the numbers crossed out in the order in which they appear in the original array.\nSample input and output # Sample Input Sample Output 7\n1 1 3 2 4 10 9 4\n1 3 4 10 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int final[n]; int sz = 0; for (int i = 0; i \u0026lt; n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); if (!sz || final[sz - 1] \u0026lt; x) final[sz++] = x; } printf(\u0026#34;%d\\n\u0026#34;, sz); for (int i = 0; i \u0026lt; sz; i++) printf(\u0026#34;%d \u0026#34;, final[i]); printf(\u0026#34;\\n\u0026#34;); return 0; } "},{"id":24,"href":"/docs/course_material/quizzes/midLab1/","title":"Mid-Sem Lab Exam","section":"Quizzes","content":" Mid-Sem Lab Exam # Question 1 - \u0026ldquo;Voting\u0026rdquo; # Problem Description # The Elections for the new academic year are in full swing!\nThere are \\(N\\) students in the college and two candidates for the current elections (where \\(N\\) is guaranteed to be an odd number). The students cast their votes in the form of \\(0s\\) or \\(1s\\) where the \\(i^{th}\\) vote ( \\(1 \u0026lt;= i \u0026lt;= N\\) ) being \\(1\\) represents a vote to candidate A and it being \\(0\\) represents a vote for candidate B.\nA candidate wins the elections if they have the strict majority. That is, if the number of votes cast for them is strictly greater than the number of votes cast for the other candidate.\nOutput Yes if candidate A wins the elections and No otherwise.\nLink to problem on OJ\nInput constraints # \\( 1 \\le N \\le 99 \\) \\( N \\text{ is an odd number} \\) \\( V_i = \\{0, 1\\} \\) Input format # The first line of input contains \\(N\\) , the number of students. Then, \\(N\\) line follows.\nThe \\(i^{th}\\) line contains a single integer \\(V_i = \\{0, 1\\}\\) where \\(1\\) represents a vote for candidate A and \\(0\\) represents a vote for candidate B.\nOutput Format # Output Yes if candidate A wins the elections and No otherwise.\nSample input and output # Sample Input Sample Output 3 1 0 1 Yes Explanation: There are \\(2\\) votes for candidate A and \\(1\\) vote for candidate B. Therefore, candidate A has the majority and wins the elections.\nSample Input Sample Output 5 0 0 1 0 1 No Explanation: There are \\(2\\) votes for candidate A and \\(3\\) votes for candidate B. Therefore, candidate B has the majority and wins the elections.\nSolution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int a = 0, b = 0; for (int i = 0; i \u0026lt; n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); if (x) a++; else b++; } if (a \u0026gt; b) printf(\u0026#34;Yes\\n\u0026#34;); else printf(\u0026#34;No\\n\u0026#34;); return 0; } Question 2 - \u0026ldquo;Jump Back\u0026rdquo; # Problem Description # There are \\(N\\) trees in the forest, numbered Tree 1, Tree 2,\u0026hellip;, Tree \\(N\\) .\nTree 1, is a special tree which is home to the entire forest. Each tree \\(i\\) ( \\(2 \\le i \\le N\\) ), has a parent tree \\(T_i\\) from which it grew. It is guaranteed that \\(T_i \u0026lt; i\\) .\nYou are currently on tree \\(N\\) and want to reach tree \\(1\\) . However, from a given tree, you can only jump to its parent tree (unless you are already on tree \\(1\\) , in which case you have already reached the destination).\nFor example, consider the input \\([1 1 2 4]\\) which means, \\(T_2 = 1, T_3 = 1, T_4 = 2, T_5 = 4\\) (note that tree \\(1\\) has no parent tree). Starting from tree \\(5\\) , the only option is to jump to tree 4, its parent. Similarly, from tree 4, you jump to tree 2. Finally, from tree 2 you jump to tree 1, taking a total of 3 jumps to go from tree 5 to tree 1.\nFind the number of jumps that you need to make in order to reach tree \\(1\\) starting from tree \\(N\\) . It can be shown that you can reach it in a finite number of jumps.\nLink to problem on OJ\nInput constraints # \\(2 \\le N \\le 50\\) \\(1 \\le T_i \u0026lt; i\\) ( \\(2 \\le i \\le N\\) ) Input format # The first line of input contains a single integer \\(N\\) , the number of trees.\nThe following line contains \\(N - 1\\) space separated integers, \\(T_2, T_3, \\dots, T_N\\) where \\(T_i\\) denotes the parent of the \\(i^{th}\\) tree.\nOutput Format # Output a single integer denoting the number of jumps required to go from tree \\(N\\) to tree \\(1\\) .\nSample input and output # Sample Input Sample Output 3 1 2 2 Sample Input Sample Output 5 1 1 2 4 3 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int a[n]; a[0] = -1; for (int i = 1; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); a[i]--; } int curr = n - 1, ans = 0; while (curr != -1) { ans++; curr = a[curr]; } printf(\u0026#34;%d\\n\u0026#34;, ans - 1); return 0; } Question 3 - \u0026ldquo;Max AND\u0026rdquo; # Problem Description # In this problem, we use the symbol ^ to denote the bitwise AND operation, and the symbol v to denote the bitwise OR operation.\nGiven an array of integers \\(A\\) of length \\(N\\) , \\(A_1, A_2, \\dots, A_N\\) . Define a \u0026ldquo;set operation\u0026rdquo; as the following:\nSelect any index \\(i\\) where \\(1 \\le i \\le N\\) and set the \\(j^{th}\\) bit of \\(A_i\\) where \\(j\\) is any integer between \\(0\\) and \\(30\\) inclusive. In other words, replace \\(A_i\\) with \\(A_i\\) v \\(2^j\\) . You are also given a non-negative integer \\(K\\) . You can perform at most \\(K\\) operations on the given array. After doing so, output the maximum possible value of \\(A_1\\) ^ \\(A_2\\) ^ \\(\\dots\\) ^ \\(A_N\\) .\nLink to problem on OJ\nInput constraints # \\(1 \\le N \\le 2 \\times 10^5\\) \\(0 \\le K \\le 10^9\\) \\(0 \\le A_i \u0026lt; 2^{31}\\) Input format # The first line of input contains two space separated integers \\(N\\) and \\(K\\) , denoting the length of the array and the maximum number of operations that can be performed respectively.\nThe second line contains \\(N\\) space separated integers \\(A_1, A_2, \\dots, A_N\\) that denote the initial array.\nOutput Format # Output the maximum possible value of the bitwise AND of the entire array after performing at most \\(K\\) operations.\nSample input and output # Sample Input Sample Output 3 2 2 1 1 2 Explanation: We set the \\(j = 1\\) bit (that is, the bit corresponding to \\(2^1\\) ) for \\(A_2\\) and \\(A_3\\) . This requires \\(2 \\le K\\) operations. After doing so, the array now looks like \\([2, 3, 3]\\) , giving us a bitwise AND value of \\(2\\) which can be shown is the maximum possible value for the given input.\nSample Input Sample Output 7 0 4 6 6 28 6 6 12 4 Explanation: Here, \\(K = 0\\) . So, we cannot perform any operations. Hence, the bitwise AND of the initial array, \\(4\\) is our final answer.\nSolution # #include \u0026lt;stdio.h\u0026gt; int main() { int n, k; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;k); int cnt[31] = {0}; for (int i = 0; i \u0026lt; n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); for (int j = 0; j \u0026lt; 31; j++, x /= 2) { cnt[j] += (x \u0026amp; 1); } } int ans = 0; for (int i = 30; i \u0026gt;= 0; i--) { if (k \u0026gt;= n - cnt[i]) { ans |= (1 \u0026lt;\u0026lt; i); k -= (n - cnt[i]); } } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } "},{"id":25,"href":"/docs/course_material/practice_problems/problems/","title":"Problems","section":"Practice Problems","content":" Practice Problems # 1. Cycles in a permutation # Let $\\pi:\\{1,\\cdots, n\\} \\rightarrow \\{1,\\cdots, n\\}$ be permutation (that is a one-one onto function). The cycle containing 1 is the sequence of numbers $$1\\qquad \\pi(1)\\qquad \\pi(\\pi(i))\\qquad \\pi(\\pi(\\pi(1)))\\qquad \\cdots$$ Notice that the sequence is periodic (Why?) and the period is called the size of the cycle containing 1. Similarly one can define the cycle containing 2, 3 etc. Write a program to take $n$ and a permutation of $\\{1,\\cdots,n\\}$ as inputs and print all the cycles (you can stop at the period).\nFor example:\nFor input 4 and perumutation 2 3 4 1, it should output 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;1.\nFor input 4 and perumutation 1 2 3 4, it should output 1-\u0026gt;1, 2-\u0026gt;2, 3-\u0026gt;3, 4-\u0026gt;4.\nFor input 4 and perumutation 2 1 4 3, it should output 1-\u0026gt;2-\u0026gt;1, 3-\u0026gt;4-\u0026gt;3.\n2. Cycles in a LinkedList # In a linked list, its possible to have a cycle in the nodes. That is, while iterating through the nodes, a node could be there whose next pointer is pointing to a previous node.\nWrite a C program which takes linked list as input and checks if it has a cycle.\nHint: You can add extra fields into the Node struct, for aiding this program.\nFor example:\nOn input linked list 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;6-\u0026gt;3, the program should print true.\nOn input linked list 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;6-\u0026gt;NULL, the program should print false.\n"},{"id":26,"href":"/docs/course_material/quizzes/quiz1A/","title":"Quiz - 1 Section A","section":"Quizzes","content":" Quiz 1 # Section A Question 1 - 5 marks # Problem Description # Write a program to find the factorial of a number. Here n can be taken to be an input from the user.\nSolution # #include \u0026lt;stdio.h\u0026gt; int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); if(n\u0026lt;0){ printf(\u0026#34;Invalid Input!\u0026#34;); }else{ int ans=1; for(int i=1;i\u0026lt;=n;i++){ ans*=i; } printf(\u0026#34;%d\\n\u0026#34;,ans); } return 0; } Grading Scheme # 1 mark: For writing\n#include \u0026lt;stdio.h\u0026gt; 1 mark: For writing\nint main(){ return 0 } 3 marks: For correct logic, this includes correct initialization of ans=1, writing the correct for-loop and correct formula. Marks have been cut for compilation errors(Between 0.5 to 1 marks have been cut)\nNote: For approaches other than the standard for-loop approach, marks have been awarded according to correctness of the approach.\nFor eg, in case of a recursion based approach, marks have been awarded if the base-case is correct and the recursion works properly. Question 2 - 5 marks # Problem Description # What is type-casting? Explain the types of type casting in C.\nSolution # The idea of type-casting is to convert one data type into another.\nThere are two types of type conversions/castings:\n1) Implicit conversions: The idea here is to convert the data type of one variable without altering the actual value of the variable. The datatype can be both promoted and demoted by compiler. There can be various implicit conversions:\na) Arithmetic conversions: Happens when operands in arithmetic or logical expressions don’t have same type. Example: Addition of integer and float.\nint a = 10; float b = 20.0; float c = a + b; // type of (a+b) is float, so it is stored back in `float c` b) Conversion during assignment: Happens when type of expression on the right side of an assignment operator doesn’t match the type of the variable on the left side. Example: assigning an int to char.\nchar pi1 = 3; int pi2 = \u0026#39;a\u0026#39;; int pi3 = 3.14; // Results in loss of information float pi4 = 3; // 3 is an int, but assigned to float c) Others: In function argument; in return statement.\n2. Explicit type-casting: In this case, the datatype conversion is user-defined according to the program’s needs. It can be a lower or higher end data type. Example:\nfloat pi = (float)21/7; Grading Scheme # Definition of typecasting (1 mark).\nDefinition of implicit conversion (1 mark) and its example (1 mark). (Sub-types of implicit conversion are not required.) Definition of explicit typecasting (1 mark) and its example (1 mark). Writing extra details relevant to the topic can also result in extra marks. For example: Writing hierarchical order of promotion in arithmetic conversion. Marks have been deducted for conceptual or syntax errors.\nQuestion 3 - 5 marks # Problem Description # Write -35 in 2’s complement form (assume 8-bit representation).\nSolution \u0026amp; Grading Scheme # The number 35 in binary is given by: 00100011 (2 marks)\nIn 2 complement it is given by: 11011101. (3 marks)\nQuestion 4 - 5 marks # Problem Description # State True/False with justification: Given two positive integers x and y, it is not possible to calculate the minimum and maximum of the two numbers without using any conditions or loops.\nSolution # False (1 mark).\n#include\u0026lt;stdio.h\u0026gt; int main() { int x,y, min, max; min = y^((x^y)\u0026amp;-(x\u0026lt;y)); max = x^((x^y)\u0026amp;-(x\u0026lt;y)); printf(\u0026#34;min = %d,max = %d\\n\u0026#34;, min,max); return 0; } (4 marks).\nGrading Scheme # 1 mark for writing False or even if have have wrote True but your Explanation points out to be correct marks have been awarded giving benefit of reading the question wrong . Such cases have been marked Lucky and are instructed to not do it from next time.\n1/2 mark if there’s a contradictory statements for the explanation and answer\n3/2 for writing the formula for minimum number expression here the formula using Absolute value concept and other correct equivalent bitwise expressions have also been taken into account.\nAgain, 3/2 for writing the correct way to find out the maximum value . Note:- Using the terms like maximum can be found out logically, naturally etc. from minimum have been given 0 marks for the same 1 mark for writing the above expressions with the whole of code structure.\nQuestion 5 - 10 marks # Problem Description # Write a program to print the following pattern of the Pascal’s triangle.\n1 1 1 1 2 1 1 3 3 1 Solution # #include\u0026lt;stdio.h\u0026gt; int main() { int rows=4, num= 1, space, i, j; for(i=0; i \u0026lt; rows; i++) { for(space=1; space \u0026lt;= rows-i; space++) printf(\u0026#34; \u0026#34;); for(j=0; j \u0026lt;= i; j++) { if (j==0 || i==0) num= 1; else num = num*(i-j+1)/j; printf(\u0026#34; %d\u0026#34;, num); } printf(\u0026#34;\\n\\n\u0026#34;); } return 0; } Grading Scheme # Header files: (1 mark - awarded if the syntax is strictly correct) Initialising variables using the right syntax: (1 mark - awarded if the syntax is strictly correct) Using the variables that were declared correctly: (1 mark - awarded with some leniency depending on the mistake) Using printf correctly for printing spaces: 2 marks are awarded if spaces are printed properly with correct generalised logic. 1 mark is awarded if just the syntax is correct. Using for or while loop: 2 marks are awarded if numbers are printed properly with correct generalised logic. 1 mark is awarded if just the syntax is correct Correct logic for generalised output - 2 marks Correct final output (brute or general) - 1 mark Question 6 - 20 marks # Problem Description # What is output of the following programs with proper justification ?\ni) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { int x = 5, y, z; y = x++; z = x--; printf(\u0026#34;%d %d %d\\n\u0026#34;, x, y, z); return 0; } Solution \u0026amp; Grading Scheme # Output: 5 5 6\nJustification:\ny = x++; // y = 5, x = 6 z = x--; // z = 6, x = 5 x = 5 (post-increment operator) (2 marks) y = 5 (post-increment operator) (2 marks) z = 6 (post-decrement operator) (1 mark) ii) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { int a = 3; a = (a++) + ~ (++a); printf(\u0026#34;%d\u0026#34;, a); return 0; } Solution \u0026amp; Grading Scheme # Output: -3 (2 marks)\nJustification:\na = 3; a = (a++) + ~ (++a) a = 3 + ~(5) [1 marks for post-increment, 1 marks for pre-increment]\na = 3 + (-6) [1 marks for writing ~(5) = -6]\na = -3\niii) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { int i = 21 \u0026gt; 5 \u0026gt; 3 \u0026lt; 4; printf(\u0026#34;%d\u0026#34;, i); return 0; } Solution \u0026amp; Grading Scheme # Output: 1 (2 marks, only 1 mark if justification is incorrect)\nJustification: The expression gets evaluated from left to right\nint i = (((21 \u0026gt; 5) \u0026gt; 3) \u0026gt; 4) 21 \u0026gt; 5 is true, so it gets evaluated to 1. (1 mark)\n1 \u0026gt; 3 is false, so it gets evaluated to 0. (1 mark)\n0 \u0026lt; 4 is true, so it gets evaluated to 1. (1 mark)\niv) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { int y; printf(\u0026#34;%d\u0026#34;, scanf(\u0026#34;%d\u0026#34;, \u0026amp;y)); /* Suppose that input value given for above scanf is 2023*/ return 0; } Solution \u0026amp; Grading Scheme # Output: 1\nJustification: Scanf returns the number of objects that are input, in this case the number of object is 1 (an integer y) so Scanf will return 1 and it will be printed.\n2 marks for output and 3 marks for justification\n"},{"id":27,"href":"/docs/course_material/quizzes/quiz1B/","title":"Quiz - 1 Section B","section":"Quizzes","content":" Quiz 1 # Section B Question 1 - 5 marks # Problem Description # Write a program to find the sum of first n even numbers. Here n can be taken to be an input from the user.\nSolution # Both Codes are considered to be valid.\n#include\u0026lt;stdio.h\u0026gt; int main() { int i, ans = 0,n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(i=0; i \u0026lt; n; i ++) { ans = ans + 2*i; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } #include\u0026lt;stdio.h\u0026gt; int main() { int i, ans = 0,n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int ans = n*(n-1); // n*(n+1) is also given as correct ans. printf(\u0026#34;%d\\n\u0026#34;,ans); return 0; } Grading Scheme # 1 mark: For writing\n#include \u0026lt;stdio.h\u0026gt; 1 mark: For writing\nint main(){ return 0 } 3 marks: For correctness of the code\nQuestion 2 - 5 marks # Problem Description # Explain the control flow between the RAM, Hard disk and the CPU after a program is written.\nSolution \u0026amp; Grading Scheme # There are a few different interpretations to the question. The question expects you to explain what happens when a program is run.\nThe OS-kernel loads the program from the Hard disk into the RAM. (1 mark) It is then transmitted to the CPU through the memory bus. (1 mark) The CPU performs the following cycle: (2 marks)\nFetch Decode Execute After this the output is written back to the RAM through the memory bus. (1 mark) Other interpretations include:\nWhat happens when the program is written in the editor and saved? What happens when the program is compiled? Marks have been given to these interpretations if points similar to what we were looking for in the intended solution are given but according to the different interpretations.\nQuestion 3 - 5 marks # Problem Description # Write -15 in 1’s complement form (assume 8-bit representation)\nSolution \u0026amp; Grading Scheme # The number 15 in binary is given by: 00001111 (2 marks)\nIn 1\u0026rsquo;s complement it is given by: 11110000. (3 marks)\nQuestion 4 - 5 marks # Problem Description # State True/False with justification: Given two numbers x and y, the expression y ^ ((x ^ y)\u0026amp; − (x \u0026lt; y)) calculates the minimum of the two numbers.\nSolution # True, This expression does calculate the minimum of the two numbers (1 Mark)\nJustification:\nIf x \u0026lt; y (2 Marks) (x \u0026lt; y) = 1 -(x\u0026lt;y) = -1 -(x\u0026lt;y) = (1111...1) (Due to one’s compliment representation of negative numbers in binary) (x ^ y) \u0026amp; (1111...1)_2 = (x ^ y) (As 1 is the identity for AND operation) y^(( x ^ y) \u0026amp; - (x \u0026lt; y) = y ^ (x ^ y) = x y ^ (x ^ y) = y ^ x ^ y ( ^ (Bitwise xor) is associative ) y ^ x ^ y = x ^ y ^ y ( ^ (Bitwise xor) is commutative ) x ^ y ^ y = x ^ 0 ( inverse of a number for bitwise xor is the number itself ) x ^ 0 = x (0 is the identity for XOR operation) Hence if x \u0026lt; y, y ^ ((x ^ y) \u0026amp; -(x \u0026lt; y)) = x If x \u0026gt;= y (2 Marks) (x \u0026lt; y) = 0 -(x\u0026lt;y) = 0 (x ^ y) \u0026amp; 0 = 0 (As any number AND 0 is 0) y ^ (( x ^ y) \u0026amp; - (x \u0026lt; y) = y ^ 0 y ^ (( x ^ y) \u0026amp; - (x \u0026lt; y) = y (0 is the identity for XOR operation) Hence if x \u0026gt;= y, y ^ ((x ^ y) \u0026amp; -(x \u0026lt; y)) = y Therefore, this expression calculates the minimum of the two numbers\nGrading Scheme # 0 marks awarded for wrong option (False) with any justification 1 mark awarded for correct option (True) without correct justification. 1.5 marks awarded for correct option (True) and justifying it by correctly evaluating it for an example, incorrect evaluation of an example have been given 1. 3 marks awarded for correct option (True) and when only one case’s justification is correct. 5 marks awarded for correct option (True) and correct justification by proving for both the cases. Question 5 - 10 marks # Problem Description # Write a program to print the following pattern.\n1 2 3 4 5 6 7 8 9 10 Solution # #include\u0026lt;stdio.h\u0026gt; int main() { int rows = 4, num = 1, space, i, j; for(i = 1; i \u0026lt;= rows; i++){ for(space = 1; space \u0026lt;= rows - i; space++) printf(\u0026#34; \u0026#34;); for(j = i*(i-1)/2; j \u0026lt; i*(i+1)/2; j++){ num = j + 1; printf(\u0026#34;%d \u0026#34;, num); } printf(\u0026#34;\\n\u0026#34;); } } Grading Scheme # Header files: (1 mark - awarded if the syntax is strictly correct) Initialising variables using the right syntax: (1 mark - awarded if the syntax is strictly correct) Using the variables that were declared correctly: (1 mark - awarded with some leniency depending on the mistake) Using printf correctly for printing spaces: 2 marks are awarded if spaces are printed properly with correct generalised logic. 1 mark is awarded if just the syntax is correct. Using for or while loop: 2 marks are awarded if numbers are printed properly with correct generalised logic. 1 mark is awarded if just the syntax is correct Correct logic for generalised output - 2 marks Correct final output (brute or general) - 1 mark Question 6 - 20 marks # Problem Description # What is output of the following programs with proper justification ?\ni) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { int x = 7, y, z; y = --x; z = x++; printf(\u0026#34;%d %d %d\\n\u0026#34;, x, y, z); return 0; } Solution \u0026amp; Grading Scheme # Output: 7 6 6\nJustification:\ny = --x; // y = 6, x = 6 z = x++; // z = 6, x = 7 x = 7 (post-increment operator) (2 marks) y = 6 (pre-decrement operator) (2 marks) z = 6 (post-increment operator) (1 mark) ii) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { int i; for(i = 9 ; i != 0 ; i--) printf(\u0026#34;%d\\n\u0026#34;, i--); return 0; } Solution \u0026amp; Grading Scheme # Output: Infinite loop of odd numbers starting from 9, 7, 5, .... (2 marks) i-- happens twice: once in the printf statement and once in the for loop. The condition i != 0 is never reached. So there is infinite loop. (3 marks)\niii) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { int x = 4, y = 4, z = 4; if (x == y == z) { printf(\u0026#34;YES\u0026#34;); } else { printf(\u0026#34;NO\u0026#34;); } return 0; } Solution \u0026amp; Grading Scheme # Output: NO (2 marks, only 1 mark if justification is incorrect)\nExpression gets evaluated from left to right ((x==y)==z)\nx == y is true, so it gets evaluated to 1. (1 mark)\n1 == z is false, so it gets evaluated to 0. (1 mark)\nTherefore “NO” is printed. (1 mark)\niv) 5 marks # #include\u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;%d\u0026#34;, printf(\u0026#34;Hello World\u0026#34;)); return 0; } Solution \u0026amp; Grading Scheme # Output: Hello World11\nJustification: printf outputs the text Hello World. Printf with %d returns the number of characters in the word (11). Therefore, the output is Hello World11\n2 marks for output and 3 marks for justification\n"},{"id":28,"href":"/docs/course_material/quizzes/quiz2/","title":"Quiz - 2","section":"Quizzes","content":" Quiz 2 # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Node Node; typedef Node* LinkedList; typedef struct Person { char name[100]; int age; RelStatus relstatus; LinkedList friends; } Person; struct Node { struct Person* data; struct Node* next; }; typedef struct SocialNet { LinkedList members; } SocialNet; LinkedList append(Person* p, LinkedList l) { if (l == NULL) { Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = NULL; return D; } else { l-\u0026gt;next = append(p, l-\u0026gt;next); } return l; } void print_person(Person* p) { char status_string[][15] = { \u0026#34;Not Mentioned\u0026#34;,\u0026#34;Single\u0026#34;, \u0026#34;Married\u0026#34;, \u0026#34;Engaged\u0026#34; }; printf(\u0026#34;%s\\t\\t%d\\t%s\\t\\t\\t\u0026#34;, p-\u0026gt;name, p-\u0026gt;age, status_string[p-\u0026gt;relstatus]); LinkedList f = p-\u0026gt;friends; while (f != NULL) { printf(\u0026#34;%s, \u0026#34;, f-\u0026gt;data-\u0026gt;name); f = f-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); } void print_network(LinkedList m) { printf( \u0026#34;------------------------------------------------------\\n\u0026#34; \u0026#34;Name\\t\\tAge\\tStatus\\t\\t\\tFriends\\n\u0026#34; \u0026#34;------------------------------------------------------\\n\u0026#34;); while (m != NULL) { print_person(m-\u0026gt;data); m = m-\u0026gt;next; } printf(\u0026#34;------------------------------------------------------\\n\u0026#34;); } Person* find_person(char* name, LinkedList l) { // Either find the person with a particular name // if not found return NULL while(l!= NULL) { if (strcmp(l-\u0026gt;data-\u0026gt;name, name) == 0) { return l-\u0026gt;data; } l = l-\u0026gt;next; } return NULL; } int size(LinkedList l) { return l == NULL? 0: 1+size(l-\u0026gt;next); } char* person_with_most_friends(LinkedList l) { // Q A1: Return the name of the person with most friends // (3 marks) int d = 0; Node* n = NULL; while(l != NULL) { int e = size(l-\u0026gt;data-\u0026gt;friends); if (e \u0026gt; d) { d = e; n = l; } l = l-\u0026gt;next; } return n==NULL? \u0026#34;\u0026#34; : n-\u0026gt;data-\u0026gt;name; } int popularity(char* name, LinkedList l) { // Q B1: Return the number of people who has the person // named `name` amoung their friends. (3 marks) int count = 0; while ( l!= NULL) { if (find_person(name, l-\u0026gt;data-\u0026gt;friends) != NULL) { count++; } } return count; } LinkedList delete_by_name(char* name, LinkedList l) { // Q A2: Delete the person named `name` from l (3 marks) if (l == NULL) { return NULL; } else if (strcmp(name, l-\u0026gt;data-\u0026gt;name) == 0) { Node* tail = l-\u0026gt;next; free(l); return tail; } else { l-\u0026gt;next = delete_by_name(name, l-\u0026gt;next); return l;z } } LinkedList filterby_age(LinkedList l, int lower, int upper) { // Q B2: Return the link list of people in l with age // between lower and upper (3 marks) LinkedList l2 = NULL; while(l != NULL) { if (l-\u0026gt;data-\u0026gt;age \u0026gt;= lower \u0026amp;\u0026amp; l-\u0026gt;data-\u0026gt;age \u0026lt;= upper) { l2 = append(l-\u0026gt;data, l2); } l = l-\u0026gt;next; } return l2; } bool friends_triangle(LinkedList members) { // Q A3: Check if there is a triangle of friends // ie there exists X, Y, Z such that // Y is a friend of X, Z is a friend of Y, X is a friend of Z // ALso print all such triplets (4 marks) LinkedList f = members; printf( \u0026#34;-----------------------------\\n\u0026#34; \u0026#34;Friend Triangles\\n\u0026#34; \u0026#34;-----------------------------\\n\u0026#34;); bool found = false; while(f != NULL) { LinkedList s = f-\u0026gt;data-\u0026gt;friends; while (s != NULL) { LinkedList t = s-\u0026gt;data-\u0026gt;friends; while (t != NULL) { LinkedList l = t-\u0026gt;data-\u0026gt;friends; while (l != NULL) { if (strcmp(l-\u0026gt;data-\u0026gt;name, f-\u0026gt;data-\u0026gt;name)==0) { printf(\u0026#34;%s-\u0026gt;%s-\u0026gt;%s-\u0026gt;%s\\n\u0026#34;, f-\u0026gt;data-\u0026gt;name, s-\u0026gt;data-\u0026gt;name, t-\u0026gt;data-\u0026gt;name, f-\u0026gt;data-\u0026gt;name); found = true; } l = l-\u0026gt;next; } t = t-\u0026gt;next; } s = s-\u0026gt;next; } f = f-\u0026gt;next; } printf(\u0026#34;-------------------------\\n\u0026#34;); return found; } bool transitive_friendship(LinkedList members) { // Q B3: check if the friendship relation is transitive // ie for any X,Y, Z, if Y is a friend of X and // Z is a friend of Y then Z is a friend of X // Also print all the links that violates transitivity // (4 marks) LinkedList f = members; printf( \u0026#34;-----------------------------\\n\u0026#34; \u0026#34;Links that are not Transitive\\n\u0026#34; \u0026#34;-----------------------------\\n\u0026#34;); bool found = false; while(f != NULL) { LinkedList s = f-\u0026gt;data-\u0026gt;friends; while (s != NULL) { LinkedList t = s-\u0026gt;data-\u0026gt;friends; while (t != NULL) { if (find_person(t-\u0026gt;data-\u0026gt;name, f-\u0026gt;data-\u0026gt;friends) == NULL) { printf(\u0026#34;%s-\u0026gt;%s-\u0026gt;%s, but there is no %s-\u0026gt;%s\\n\u0026#34;, f-\u0026gt;data-\u0026gt;name, s-\u0026gt;data-\u0026gt;name, t-\u0026gt;data-\u0026gt;name, f-\u0026gt;data-\u0026gt;name,t-\u0026gt;data-\u0026gt;name); found = true; } t = t-\u0026gt;next; } s = s-\u0026gt;next; } f = f-\u0026gt;next; } printf(\u0026#34;-------------------------\\n\u0026#34;); return !found; } int main() { SocialNet s = { NULL }; Person A = {\u0026#34;Alice\u0026#34;, 23, Single, NULL}; Person B ={\u0026#34;Bob\u0026#34;, 26, Engaged, NULL}; Person C = {\u0026#34;Charlie\u0026#34;, 21, NotMentioned, NULL}; Person D ={\u0026#34;Don\u0026#34;, 28, Married, NULL}; s.members = append(\u0026amp;A, s.members); s.members = append(\u0026amp;B, s.members); s.members = append(\u0026amp;C, s.members); s.members = append(\u0026amp;D, s.members); A.friends = append(\u0026amp;B, A.friends); A.friends = append(\u0026amp;C, A.friends); B.friends = append(\u0026amp;D, B.friends); C.friends = append(\u0026amp;D, C.friends); D.friends = append(\u0026amp;A, D.friends); printf(\u0026#34;List of people between ages 24 to 28:\\n\u0026#34;); print_network(filterby_age(s.members, 24, 28)); printf(\u0026#34;The person with most friends is %s.\\n\u0026#34;,person_with_most_friends(s.members)); // For above social network, `friends_triangle(s.members)` // returns `true` and prints // ----------------------------- // Friend Triangles // ----------------------------- // Alice-\u0026gt;Bob-\u0026gt;Don-\u0026gt;Alice // Alice-\u0026gt;Charlie-\u0026gt;Don-\u0026gt;Alice // Bob-\u0026gt;Don-\u0026gt;Alice-\u0026gt;Bob // Charlie-\u0026gt;Don-\u0026gt;Alice-\u0026gt;Charlie // Don-\u0026gt;Alice-\u0026gt;Bob-\u0026gt;Don // Don-\u0026gt;Alice-\u0026gt;Charlie-\u0026gt;Don // ------------------------- friends_triangle(s.members); // For the above social network, `transitive_friendship(s.members)` // returns false and prints // ----------------------------- // Links that are not Transitive // ----------------------------- // Alice-\u0026gt;Bob-\u0026gt;Don, but there is no Alice-\u0026gt;Don // Alice-\u0026gt;Charlie-\u0026gt;Don, but there is no Alice-\u0026gt;Don // Bob-\u0026gt;Don-\u0026gt;Alice, but there is no Bob-\u0026gt;Alice // Charlie-\u0026gt;Don-\u0026gt;Alice, but there is no Charlie-\u0026gt;Alice // Don-\u0026gt;Alice-\u0026gt;Bob, but there is no Don-\u0026gt;Bob // Don-\u0026gt;Alice-\u0026gt;Charlie, but there is no Don-\u0026gt;Charlie // ------------------------- transitive_friendship(s.members); return 0; } "},{"id":29,"href":"/references/","title":"References","section":"Introduction","content":" References from the web # Dive into C Textbook\nC Programing Textbook\nC Programming Wikibook\nVariables, functions, arrays, strings\nC Structs and Pointers\nThe C Book by Banahan, Brady, Doran\nPractical Programming in C (MIT OCW)\nObject-Oriented Programming With ANSI-C\nC and Unix Documentation from the Stanford CS Education Library\nC Primer from Brown: Part 1 Part 2 Part 3: Debugging\nA C programming course by Steve Summit, online course material\nProgramming in C by A.D. Marshall, notes and examples\nRecursive and Loopy GCD in C\nSieve of Eratosthenes in C\n"},{"id":30,"href":"/tas/","title":"Teaching Assistants","section":"Introduction","content":" Teaching Assistants # Pramod Rao | pramod.b@research.iiit.ac.in Shreeya Singh | shreeya.singh@students.iiit.ac.in Aditya Malhotra | aditya.malhotra@students.iiit.ac.in Anushka Agrawal | anushka.agrawal@students.iiit.ac.in Ayan Datta | ayan.datta@research.iiit.ac.in Bhargav Srinivas | bhargav.srinivas@students.iiit.ac.in Dheeraja Rajreddygari | dheeraja.rajreddygari@students.iiit.ac.in Harshvardhan | harshvardhan.sv@research.iiit.ac.in Keval Jain | keval.jain@research.iiit.ac.in Kriti Gupta | kriti.gupta@research.iiit.ac.in Kushagra Kharbanda | kushagra.kharbanda@students.iiit.ac.in Kyrylo Shyvam Kumar | kyrylo.shyvam@students.iiit.ac.in Manav Shah | shah.devendrakumar@students.iiit.ac.in Mihika Sanghi | mihika.sanghi@research.iiit.ac.in Mitansh Kayathwal | mitansh.kayathwal@students.iiit.ac.in Sriteja Pashya | sriteja.pashya@research.iiit.ac.in Ujjwal Shekhar | ujjwal.shekhar@research.iiit.ac.in "},{"id":31,"href":"/docs/course_material/template/","title":"Template","section":"Course Material","content":" Course material template # Question 1 # The question body would go here\nText # Linked list can be defined as either a node structure doing nothing or one that is pointing to another linked list\nLinks # See linked: Recursion\nButton # Get Home Contribute Columns # Left Content Lorem markdownum insigne\u0026hellip; Mid Content Lorem markdownum insigne\u0026hellip; Right Content Lorem markdownum insigne\u0026hellip; Expand # Expand ↕ Markdown content # Lorem markdownum insigne\u0026hellip; Hint # Warning: Make sure to always free up memory! KaTeX # \\(f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\\) Tabs # MacOS MacOS Content # Linux Linux Content # Windows Windows Content # Code # typedef struct node { struct node* nxt; // will point to the next node in the linked list if any int val; // store whatever else you might need } Node; int main() { // Code here } "},{"id":32,"href":"/docs/course_material/tutorials/week1/","title":"Tutorial - 1","section":"Tutorials","content":" Tutorial 1 (Week of 14 August) # Theory # Introduction to how compilation works in C # We all know that computer is incapable of reading and understanding the code we write in its native form. This means that the code needs to be converted in a form which the machine can understand. The machine only understands Binary code. Thus, there should be a process by which the code we write can be converted to Binary form. This process is known as compilation. You can think of compilation to be similar to translation (For eg: Let’s say you know English but you are with someone who only understands French. This situation would require a translator! This is exactly what a compiler does. It acts as a translator!).\nThere are various stages in which the code is converted from C-language into binary for the computer to understand it:\nPreprocessing: All headers files starting with “#include” are processed in this phase. (Several other forms of processing including the removal of comments also happen at this stage). This generates a .i file Compiling: For now, assume it to be an intermediate process of conversion from .i to .s file. The .s file (known as an assembly file) is a set of commands which our machine knows to execute. Assembly: Code is converted into machine-understandable code by the assembler. The file output is a .o or .obj file. Linking: links library files(eg: stdio.h, math.h etc) to the object file to produce the a.out file, which is a binary executable of the program that was supplied as input. Finally, we execute the a.out file to get the desired output.\nNote: At this stage of the course, it is fine if the process is not entirely clear. It would become more clear in future courses (CSO for CXX students for example). The previous section just acts as a glimpse into compilation as a process being a series of smaller sub-processes. Return values of scanf and printf function # scanf() and printf() are both part of the standard I/O library in C. They are used for taking input from the user, printing output etc. It\u0026rsquo;s important to notice that these functions have a certain return value.\nscanf() function returns the number of inputs that have been read.\nExample:\nint a; int rval = scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); printf(\u0026#34;%d\u0026#34;, rval); The above snippet of code would print 1 as its output. This is because it\u0026rsquo;s reading only 1 argument. If the number of arguments increases, then the return value would change similarly.\nSimilarly, printf() function returns the number of characters written.\nint rval = printf(\u0026#34;Hello world!\u0026#34;); printf(\u0026#34;%d\u0026#34;, rval); The above snippet would print 12 as its output.\n"},{"id":33,"href":"/docs/course_material/practice_problems/week1/","title":"Week - 1","section":"Practice Problems","content":" Practice problems for week - 1 (Week of 14 August) # None of the following problems require a knowledge of loops, conditional statements etc.\nQuestion 1 # Problem Description # Keval has forgotten the password to his I-Pad. The password is a 4-digit number where each digit takes a value from 0 to 9. The good thing is that Keval remembers that his password had exactly two unique digits, and each of these digits appeared exactly twice in the password. Keval also remembers that n digits (where, \\( 0 \\le n \\le 10 \\) ) from 0-9 were definitely not used in the password.\nFind the number of different possible passwords Keval could have.\nNote that the password can start with the digit 0 Input constraints # \\(0 \\le n \\le 10\\) Input format # The only line of input contains a single integer n, the number of digits which were not used in the password\nOutput Format # Output a single integer that denotes the number of possible password sequences.\nSample input and output # Sample Input Sample Output 1 216 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int ans = ((10-n)*(10-n-1))/2 * 6; // (10-n)C2 * 4C2 printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } Question 2 # Problem Description # You are given two integers x and y. Output the minimum integer z, such that x | z = y. Here, \u0026ldquo;|\u0026rdquo; denotes the bitwise-OR operator\nInput constraints # \\(1 \\le x, y \\le 10^9\\) Input format # The only line of input contains two space-separated integers x and y\nOutput Format # Output a single integer that denotes z as described in the problem statement\nSample input and output # Sample Input Sample Output 1 3 2 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int x, y; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;x, \u0026amp;y); int z = x ^ y; printf(\u0026#34;%d\u0026#34;, z); return 0; } Question 3 # Problem Description # Reverse a 4-digit number using the modulo operator.\nInput constraints # The input would be a valid 4-digit number (i.e. no leading zeroes would be present)\nInput format # The only line of input contains a single integer n\nOutput Format # Output a single integer which denotes the reverse of the n. Note that the output may have leading zeroes.\nSample input and output # Sample Input Sample Output 3214 4123 5600 0065 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n, reversed = 0; // Input a 4-digit number printf(\u0026#34;Enter a 4-digit number: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); // Reverse the number using modulo operator reversed = (n % 10) * 1000 + ((n / 10) % 10) * 100 + ((n / 100) % 10) * 10 + (n / 1000); // Output the reversed number printf(\u0026#34;Reversed number: %d\\n\u0026#34;, reversed); return 0; } Question 4 # Problem Description # Given a time as input in hh:mm:ss format, print the total number of minutes which have passed in the day.\nInput format # The only line of input would contain the time in hh:mm:ss format (24-hour clock)\nOutput Format # Output the total number of minutes that have passed. Note that this may not be an integer.\nSample input and output # Sample Input Sample Output 13:40:30 820.5 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { // Declare three variables that will be used to store the hours, minutes, // and seconds, respectively int h, m, s; // Take input in the specified format scanf(\u0026#34;%d:%d:%d\u0026#34;, \u0026amp;h, \u0026amp;m, \u0026amp;s); /** * Calculate the total minutes * Total minutes = hours * 60 + minutes + seconds / 60 * However, to ensure that float division is done, we typecast the seconds * to float */ float minutes = 60 * h + m + (float)s / 60; // Output the total minutes as a floating point number printf(\u0026#34;%f\u0026#34;, minutes); } Question 5 # Problem Description # Kishore is a very strange boy. He keeps solving weird problems and is now stuck on one such question. Please help him solve it.\nGiven an integer n, you need to find the number of ordered pairs of integers (a, b) such that, \\( 1 \\le a \\le b \\le n \\) and\n\\(\\frac{lcm(a, b)}{gcd(a, b)} \\le 3\\) In this problem, gcd(a, b) denotes the greatest common divisor of the numbers a and b, and lcm(a, b) denotes their lowest common multiple.\nInput constraints # \\(1 \\le n \\le 10^8\\) Input format # The only line of input contains a single integer n\nOutput Format # Output a single integer that denotes the number of pairs (a, b) that satisfy the given constraints\nSample input and output # Sample Input Sample Output 5 11 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int ans = n + 2 * ((n / 2) + (n / 3)); printf(\u0026#34;%d\u0026#34;, n); return 0; } "},{"id":34,"href":"/docs/course_material/practice_problems/week2/","title":"Week - 2","section":"Practice Problems","content":" Practice problems for week - 2 (Week of 21 August) # Question 1 # Problem Description # You are given a 3 x 3 grid filled with integers 1 to 9, in the following way:\n1 2 3 4 5 6 7 8 9 You will be given two natural numbers A and B, both between 1 and 9. Your task is to find out if the two small squares with A and B written on them are horizontally adjacent.\nInput constraints # A and B are natural numbers and \\(1 \\le A,B \\le 9\\) \\(A \\le B\\) Input format # The only line of input contains two space-separated natural numbers A and B\nOutput Format # Print YES if the two squares are horizontally adjacent, and NO otherwise.\nSample input and output # Sample Input Sample Output 5 6 YES 6 7 NO Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int A, B; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;A, \u0026amp;B); if ((A - 1) % 3 == (B - 1) % 3) printf(\u0026#34;YES\\n\u0026#34;); else printf(\u0026#34;NO\\n\u0026#34;); return 0; } Question 2 # Problem Description # Shiven was given a problem to solve as assignment. In the problem, he was given two numbers n and s. He was asked to create a sequence of n non-negative integers such that the median of the sequence is as large as possible and that sum of all numbers of the sequence is s. Can you help Shiven find the maximum possible median of such a sequence?\nNote: The definition of the median is the \\( \\left\\lceil \\frac{n}{2}\\right\\rceil^{th} \\) element of a sequence noted in the ascending order\nInput constraints # \\(1 \\le n \\le 10^{8}\\) Input format # The only line of input contains two space-separated integers n and s\nOutput Format # Output a single integer that is the maximum median of such a sequence.\nSample input and output # Sample Input Sample Output 7 17 4 Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n, s; printf(\u0026#34;Enter two numbers: \u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;s); int m = n / 2 + 1; int ans = s / m; printf(\u0026#34;The maximum value of median is: %d\\n\u0026#34;, ans); return 0; } "},{"id":35,"href":"/docs/course_material/practice_problems/week4/","title":"Week - 4","section":"Practice Problems","content":" Practice problems for week 4 # Question 1 - \u0026ldquo;Divisibility by 11\u0026rdquo; # Problem Description # Given an integer which has \\(n\\) digits, print YES if it is divisible by \\(11\\) and NO otherwise.\nNote that the input number may contain leading zeroes.\nNote that a number is divisible by \\(11\\) if and only if the difference of the sum of digits at odd positions and sum of digits at even positions in a number is divisible by 11.\nLink to problem on OJ\nInput Format # The first line of input contains a single integer \\(n\\) denoting the number of digits.\nThe second line of input contains a positive integer which is \\(n\\) digit long.\nInput constraints # \\(1 \\le n \\le 10000\\) Output Format # Output YES if the number is divisible by 11 and NO otherwise.\nSample inputs and outputs # Sample Input 1\n4 2548 Sample Output 1\nNO Sample Input 2\n2 22 Sample Output 2\nYES Solution # #include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\\n\u0026#34;, \u0026amp;n); int cnt[] = {0, 0}; for (int i = 0; i \u0026lt; n; i++) { char c; scanf(\u0026#34;%c\u0026#34;, \u0026amp;c); cnt[i % 2] += (c - \u0026#39;0\u0026#39;); } cnt[0] %= 11, cnt[1] %= 11; if ((cnt[0] - cnt[1] + 11) % 11) printf(\u0026#34;NO\\n\u0026#34;); else printf(\u0026#34;YES\\n\u0026#34;); return 0; } Question 2 - \u0026ldquo;Reversed\u0026rdquo; (Modified) # Problem Description # Given an integer input, print the number obtained by reversing its digits. If the reverse contains leading zeroes, do not output them\nInput Format # The first and only line of input contains a positive integer \\(N\\) .\nInput constraints # \\(1 \\le N \\le 10^{18}\\) Output Format # Output a single integer which denotes the integer obtained by reversing the digits of \\(N\\) , without any leading zeroes.\nSample inputs and outputs # Sample Input 1\n348 Sample Output 1\n843 Sample Input 2\n23813900 Sample Output 2\n931832 Solution # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(void) { long long int n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); const int MAX_DIGITS = 20; int final[MAX_DIGITS]; memset(final, 0, sizeof(final)); int end = 0; while (n) { final[end++] = (n % 10); n /= 10; } int st = 0; while (!final[st]) st++; //would break if n = 0 was part of the input for (; st \u0026lt; end; st++) printf(\u0026#34;%d\u0026#34;, final[st]); printf(\u0026#34;\\n\u0026#34;); return 0; } "},{"id":36,"href":"/docs/course_material/practice_problems/week6/","title":"Week - 6","section":"Practice Problems","content":" Practice problems for week 6 # Question 1 - \u0026ldquo;Non-Fancy Trains\u0026rdquo; # Problem Description # There are \\(n\\) stations numbered \\(1, 2, ... n\\) . Stations \\(i\\) and \\(j\\) are connected via a train ( \\(1 \\le i, j \\le n\\) ) iff \\(|i - j| \\le 2\\) . The price of such a train would be \\(|a_i - a_{j}|\\) where \\(a_i\\) is an input array denoting the ratings of stations. If you travel optimally, find the minimum cost to travel form station \\(1\\) to station \\(n\\) .\nInput Format # The first line of input contains a single integer \\(n\\) denoting the number of stations.\nThe second line contains \\(n\\) space-seperated integers, \\(a_i\\) .\nInput constraints # \\(2 \\le n \\le 10^5\\) \\(1 \\le a_i \\le 10^4\\) Output Format # Print one integer, the minimum cost to travel from station \\(1\\) to station \\(n\\) .\nSample Input 1 # 4 10 30 40 20 Sample Output 1 # 30 Sample Explanation # One valid path is to go through the stations \\(1 \\rightarrow 2 \\rightarrow 4\\) , which incurs the cost \\(|10 - 30| \u0026#43; |30 - 20| = 30\\) **Sample Input 2 **\n2 10 10 Sample Output 2\n0 Question 2 - \u0026ldquo;String Palindrome Check\u0026rdquo; # Problem Description # Given a string \\(S\\) , check if it is a palindrome using recursion.\nInput Format # The first line of input contains a single integer \\(2T\\) that denotes the number of test-cases. Then, \\(2T\\) lines follow. The first line of each test-case contains a single integer \\(N\\) denoting the length of the string. The second line of each test-case contains a string \\(S\\) of length \\(N\\) .\nInput constraints # \\(1 \\le T \\le 2 \\times 10^5\\) \\(1 \\le N \\le 2 \\times 10^5\\) \\(|S| = N\\) \\(S\\) consists of only lowercase English alphabets The sum of \\(N\\) over all test-cases does not exceed \\(2 \\times 10^5\\) Output Format # For each test-case, on a single line, output YES if the string is a palindrome and NO if not\nSample inputs and outputs # Sample Input 1\n2 addd sss Sample Output 1\nNO YES Sample Input 2\n3 addfdfdda a addfdffdda Sample Output 2\nYES YES NO "}]