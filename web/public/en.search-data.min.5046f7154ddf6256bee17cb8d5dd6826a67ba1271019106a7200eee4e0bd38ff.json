[{"id":0,"href":"/posts/installingGCC/","title":"Installing GCC","section":"Resources","content":"\rInstalling gcc\r#\rThis tutorial will be a quick walkthrough on installing gcc on different OS. We recommend you try installing gcc on your own before the start of classes. If, for some reason, you are unable to install gcc, then we will help you in the first tutorial session. We also recommend you install some text editor (VS Code for example).\nWe recommend the usage of Linux as this would be advantageous for your future courses as well.\rlinux\rLinux (Ubuntu 22.04)\r#\rFor Linux-based systems, gcc usually comes installed by default.\nCheck if gcc is installed on Ubuntu by running the command: $ gcc --version\nIf running this shows a version (For eg 13.1 or say any other version) then you are good to go.\nOtherwise, if you see an error that reads “command not found” or something similar, run the following commands:\n$ sudo apt update\n$ sudo apt install build-essential\nAfter running this, check if gcc is installed by running:\n$ gcc --version\nmac\rMacOS\r#\rFor Mac-based systems, first start with installing homebrew (if not installed).\n$ /bin/bash -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026quot;\nAfter installing homebrew, you simply have to run:\n$ brew install gcc\nAfter running this, check if gcc is installed by running:\n$ gcc --version\nThis should show the path in which gcc has been installed on your Mac.\nwindows\rWindows\r#\rIn Windows, C programs can be compiled using the MinGW C compiler.\nFor installation details, refer: https://www.scaler.com/topics/c/c-compiler-for-windows/\nAlternatively, you can install WSL or a Virtual Machine to have a Linux-like environment.\n"},{"id":1,"href":"/docs/course_material/project/","title":"Project","section":"Course Material","content":"\rProject (Optional)\r#\rIn the project, you will use all the features of C language and a few more new tools (git, make) to build a game. You will be given some basic code, with tasks for implementing certain functions. The project will help you build your confidence in large-scale programming with 1000+ lines of code. We will provide reference material for learning useful tools like git/make. You must learn some of these yourself (TAs could volunteer to help).\nGrading: As mentioned the project is optional and you can score 100% marks in this course without doing it. The project is mainly to do something fun with programming. We will also provide 5% bonus marks which will be evaluated based on a viva after the endsem. If a student doing the project gets a total of more than 100, we will round it down to 100. If you want your project to be evaluated and be eligible for bonus marks, please fill out this form by Friday 9pm: https://forms.office.com/r/y9gEy6jFGK . You may withdraw also before 9pm by mentioning \u0026ldquo;withdrawn\u0026rdquo; by editing the name field in the same form. We will release the problem statements/code for the project for everyone and you are encoraged to try it out even if you have not opted for bonus marks.\nHonour Code: The grading is based on viva and if we find that you don\u0026rsquo;t understand your code, then there will be a negative marking!. We will also have intermediate evaluations to test wheather you are regularly solving the problem. Failing intermediate evals, will result in negative marking and loss of eligibility for bonus marks.\nOther Requirements: You will need to create a GitHub account (https://github.com/). This is only because they provide some tools which allow us to grade and give feedback easily.\nFAQs\r#\rWhat is the timeline?\nWe hope to release it this weekend and you will need to finish it by Nov 27.\nWill I get a negative mark if I don\u0026rsquo;t submit anything?\nWe will also have an intermediate automated evaluation, which if you fail, will result in -5% negative marking. So only take it up, if you can commit 6-8hrs of work per week.\nWill the resources be available to students not taking up the project?\nYes. But you need to decide by Friday 9pm to be considered for bonus marks.\nCan I get any more info about the project by Friday?\nWe are still finalizing. It will also depend on the number of people. so no.\n"},{"id":2,"href":"/docs/course_material/project/snake/","title":"Snake","section":"Project","content":"\rConceptual Overview\r#\rSnakes\r#\rA snake game can be represented by a grid of characters. The grid contains walls, fruits, and one or more snakes. An example of a game is shown below:\n##############\n#\rdv #\rv # #\rv # #\rs \u0026raquo;D # #\rv # #\r*A\u0026lt; * # #\r#\r############## The grid has the following special characters:\n# denotes a wall. (space character) denotes an empty space.\ndenotes a fruit. wasd denotes the tail of a snake. ^ denotes the body of a snake. WASD denotes the head of a snake. x denotes the head of a snake that has died. Each character of the snake tells you what direction the snake is currently heading in: w, W, or ^ denotes up a, A, or \u0026lt; denotes left s, S, or v denotes down d, D, or \u0026gt; denotes right At each time step, each snakes moves according to the following rules:\nEach snake moves one step in the direction of its head. If the head crashes into the body of a snake or a wall, the snake dies and stops moving. When a snake dies, the head is replaced with an x. If the head moves into a fruit, the snake eats the fruit and grows by 1 unit in length. Each time fruit is consumed, a new fruit is generated on the board. In the example above, after one time step, the board will look like this:\n##############\n* #\rs #\rv # #\rv # #\rs \u0026raquo;\u0026gt;D# #\rv # #\rA\u0026laquo; * # #\r#\r############## After one more time step, the board will look like this:\n##############\n* #\rs #\rv # #\rv # #\r\u0026raquo;\u0026gt;x# #\rs # #\r#A\u0026laquo;\u0026lt; * # #\n#\r############## Snakes are guaranteed to be at least three units long.\nNumbering snakes\r#\rEach snake on the board is numbered depending on the position of its tail, in the order that the tails appear in the file (going from top-to-bottom, then left-to-right). For example, consider the following board with four snakes:\n#############\ns d\u0026raquo;D #\rv A\u0026lt;a #\rS W #\r^ #\rw #\r############# Snake 0 is the snake with tail s, snake 1 has tail d, snake 2 has tail a, and snake 3 has tail w.\nOnce the snakes are numbered from their initial positions, the numbering of the snakes does not change throughout the game.\nGame board\r#\rA game board is a grid of characters, not necessarily rectangular. Here\u0026rsquo;s an example of a non-rectangular board:\n##############\n#\r#\r# #\r#\r## #\r#\r#\r#\r##### #\r######## ######### Note that each row can have a different number of characters, but will start and end with a wall (#). You can also assume that the board is an enclosed space, so snakes can\u0026rsquo;t travel infinitely far in any direction.\nThe game_state_t struct\r#\rA snake game is stored in memory in a game_state_t struct, which is defined in state.h. The struct contains the following fields:\nunsigned int num_rows: The number of rows in the game board. char** board: The game board in memory. Each element of the board array is a char* pointer to a character array containing a row of the map. unsigned int num_snakes: The number of snakes on the board. snake_t* snakes: An array of snake_t structs. The snake_t struct Also defined in state.h, each snake_t struct contains the following fields:\nunsigned int tail_row: The row of the snake\u0026rsquo;s tail. unsigned int tail_col: The column of the snake\u0026rsquo;s tail. unsigned int head_row: The row of the snake\u0026rsquo;s head. unsigned int head_col: The column of the snake\u0026rsquo;s head. bool live: true if the snake is alive, and false if the snake is dead. Please don\u0026rsquo;t modify the provided struct definitions. You should only need to modify state.c snake.c, and custom_tests.c in this project.\nTask 1: create_default_state\r#\rImplement the create_default_state function in state.c. This function should create a default snake game in memory with the following starting state (which you can hardcode), and return a pointer to the newly created game_state_t struct.\n####################\n#\rd\u0026gt;D * #\r#\r#\r#\r#\r#\r#\r#\r#\r#\r#\r#\r#\r#\r#\r#################### create_default_state Arguments\tNone Return values\tgame_state_t *\tA pointer to the newly created game_state_t struct. Hints The board has 18 rows, and each row has 20 columns. The fruit is at row 2, column 9 (zero-indexed). The tail is at row 2, column 2, and the head is at row 2, column 4. Which part of memory (code, static, stack, heap) should you store the new game in? strcpy may be helpful. Testing and debugging You can run make run-unit-tests to check your implementation for each task. Please note that the unit tests are not comprehensive, and passing them does not guarantee that your implementation is fully correct. However, they should be helpful to get you started with debugging.\nIf your implementation isn\u0026rsquo;t working, it\u0026rsquo;s time to start debugging. You can add printf statements in your code to print out variables during code execution, and then run make run-unit-tests again to see the output of your print statements.\nAlso, you can use make debug-unit-tests to start CGDB. In CGDB, you can set a breakpoint in your own code (hint: see the GDB reference card for how to set a breakpoint in a different file). Then type run or r to start the program, and it\u0026rsquo;ll pause at your breakpoint.\nTip: If you see \u0026ldquo;Segmentation fault (core dumped)\u0026rdquo;, this means that your program crashed. One way to start debugging is by starting CGDB, running the program with no breakpoints, and then typing backtrace or bt to see what line of code the program crashed at.\nTask 2: free_state\r#\rImplement the free_state function in state.c. This function should free all memory allocated for the given state, including all snake structs and all map-\u0026gt;board contents.\nfree_state Arguments\tgame_state_t* state\tA pointer to the game_state_t struct to be freed Return values\tNone Testing and debugging To test if we correctly freed memory for the game state, run make valgrind-test-free-state to check for memory leaks. If nothing is leaked, then you\u0026rsquo;ve passed the unit test for this task.\nTask 3: print_board\r#\rImplement the print_board function in state.c. This function should print out the given game board to the given file pointer.\nprint_board Arguments\tgame_state_t* state\tA pointer to the game_state_t struct to be printed FILE* fp\tA pointer to the file object where the board should be printed to Return values\tNone Hints The fprintf function will help you print out characters and/or strings to a given file pointer. Testing and debugging Run make run-unit-tests and make debug-unit-tests to test and debug, just like before.\nIf your function executes successfully (doesn\u0026rsquo;t segfault or crash) but doesn\u0026rsquo;t print the correct output, the board you printed will be in unit-test-out.snk. A correctly-printed board should match the default board from Task 1.\nTask 4: update_state\r#\rImplement the update_state function in state.c. This function should move the snakes one timestep according to the rules of the game.\nYou are free to implement this function however you want, but if you\u0026rsquo;d like, you can work through this task by implementing the helper functions we\u0026rsquo;ve provided. Helper functions are not graded; for this task, we\u0026rsquo;ll only be checking that update_state is correct.\nTask 4.1: Helpers\r#\rWe have provided the following helper function definitions that you can implement. These functions are entirely independent of any game board or snake; they only take in a single character and output some information about that character.\nbool is_tail(char c): Returns true if c is part of the snake\u0026rsquo;s tail. The snake\u0026rsquo;s tail consists of these characters: wasd. Returns false otherwise. bool is_head(char c): Returns true if c is part of the snake\u0026rsquo;s head. The snake\u0026rsquo;s head consists of these characters: WASDx. Returns false otherwise. bool is_snake(char c): Returns true if c is part of the snake. The snake consists of these characters: wasd^WASDx. Returns false otherwise. char body_to_tail(char c): Converts a character in the snake\u0026rsquo;s body (^) to the matching character representing the snake\u0026rsquo;s tail (wasd). The output may be undefined for characters that are not a snake\u0026rsquo;s body. char head_to_body(char c): Converts a character in the snake\u0026rsquo;s head (WASD) to the matching character representing the snake\u0026rsquo;s body (^). The output may be undefined for characters that are not a snake\u0026rsquo;s head. unsigned int get_next_row(unsigned int cur_row, char c): Returns cur_row + 1 if c is v or s or S. Returns cur_row - 1 if c is ^ or w or W. Returns cur_row otherwise. unsigned int get_next_col(unsigned int cur_col, char c): Returns cur_col + 1 if c is \u0026gt; or d or D. Returns cur_col - 1 if c is \u0026lt; or a or A. Returns cur_col otherwise. Unit tests are not provided for these helper functions, so you\u0026rsquo;ll have to write your own tests in custom_tests.c to make sure that these are working as expected. Make sure that these tests comprehensively test your helper functions\u0026ndash;our autograder will run your tests on buggy implementations to make sure that your tests can catch bugs!\nWhen writing a unit test, the test function should return false if the test fails, and true if the test passes. You can use printf to print out debugging statements. Some of the assert helper functions in asserts.h might be useful.\nOnce you\u0026rsquo;ve written your own unit tests, you can run them with make run-custom-tests and make debug-custom-tests.\nTask 4.2: next_square Implement the next_square helper function in state.c. This function returns the character in the cell the given snake is moving into. This function should not modify anything in the game stored in memory.\nnext_square Arguments\tgame_state_t* state\tA pointer to the game_state_t struct to be analyzed int snum\tThe index of the snake to be analyzed Return values\tchar\tThe character in the cell the given snake is moving into As an example, consider the following board:\n##############\n#\r#\r#\rd\u0026gt;D* #\r#\rs #\rv #\rS #\r############## Assuming that state is a pointer to this game state, then next_square(state, 0) should return *, because the head of snake 0 is moving into a cell with * in it. Similarly, next_square(state, 1) should return # for snake 1.\nThe helper functions you wrote earlier might be helpful for this function (and the rest of this task too). Also, check out get_board_at and set_board_at, which are helper functions we wrote for you.\nUse make run-unit-tests and make debug-unit-tests to run the provided unit tests. You can also use p print_board(state, stdout) to print out your entire board while debugging in cgdb.\nTask 4.3: update_head Implement the update_head function in state.c. This function will update the head of the snake.\nRemember that you will need to update the head both on the game board and in the snake_t struct. On the game board, add a character where the snake is moving. In the snake_t struct, update the row and column of the head.\nupdate_head Arguments\tgame_state_t* state\tA pointer to the game_state_t struct to be updated int snum\tThe index of the snake to be updated Return values\tNone As an example, consider the following board:\n##############\nd\u0026gt;D #\r* #\rW #\r^ #\r^ #\rw #\r#\r#\r############## Assuming that state is a pointer to this game state, then update_head(state, 0) will move the head of snake 0, leaving all other snakes unchanged. In the snake_t struct corresponding to snake 0, the head_col value should be updated from 6 to 7, and the head_row value should stay unchanged at 1. The new board will look like this:\n##############\nd\u0026raquo;D #\r* #\rW #\r^ #\r^ #\rw #\r#\r#\r############## Note that this function ignores food, walls, and snake bodies when moving the head.\nUse make run-unit-tests and make debug-unit-tests to run the provided unit tests. You can also use p print_board(state, stdout) to print out your entire board while debugging in cgdb.\nTask 4.4: update_tail Implement the update_tail function in state.c. This function will update the tail of the snake.\nRemember that you will need to update the tail both on the game board and in the snake_t struct. On the game board, blank out the current tail, and change the new tail from a body character (^) into a tail character (wasd). In the snake_t struct, update the row and column of the tail.\nupdate_tail Arguments\tgame_state_t* state\tA pointer to the game_state_t struct to be updated int snum\tThe index of the snake to be updated Return values\tNone As an example, consider the following board:\n##############\nd\u0026gt;D #\r* #\rW #\r^ #\r^ #\rw #\r#\r#\r############## Assuming that state is a pointer to this game state, then update_tail(state, 1) will move the tail of snake 1, leaving all other snakes unchanged. In the snake_t struct corresponding to snake 1, the tail_row value should be updated from 6 to 5, and the tail_col value should stay unchanged at 9. The new board will look like this:\n##############\nd\u0026gt;D #\r* #\rW #\r^ #\rw #\r#\r#\r#\r############## Use make run-unit-tests and make debug-unit-tests to run the provided unit tests. You can also use p print_board(state, stdout) to print out your entire board while debugging in cgdb.\nTask 4.5: update_state Using the helpers you created, implement update_state in state.c.\nAs a reminder, the rules for moving a snake are as follows:\nEach snake moves one step in the direction of its head. If the head crashes into the body of a snake or a wall, the snake dies and stops moving. When a snake dies, the head is replaced with an x. If the head moves into a fruit, the snake eats the fruit and grows by 1 unit in length. (You can implement growing by 1 unit by updating the head without updating the tail.) Each time fruit is consumed, a new fruit is generated on the board. The int (add_food)(game_state_t state) argument is a function pointer, which means that add_food is a pointer to the code section of memory. The code that add_food is pointing at is a function that takes in game_state_t* state as an argument and returns an int. You can call this function with add_food(x), replacing x with your argument, to add a fruit to the board.\nupdate_state Arguments\tgame_state_t* state\tA pointer to the game_state_t struct to be updated int (add_food)(game_state_t state)\tA pointer to a function that will add fruit to the board Return values\tNone Use make run-unit-tests and make debug-unit-tests to run the provided unit tests. You can also use p print_board(state, stdout) to print out your entire board while debugging in cgdb.\nTask 5: load_board Implement the load_board function in state.c. This function will read a game board from a stream (FILE *) into memory. Your implementation of load_board must support reading in from stdin and any other streams, so please do not use anything that does not support stdin, such as seeking, rewinding, or reopening.\nRemember that each row of the game board might have a different number of columns. Your implementation should be memory-efficient and should not allocate more memory than necessary to store the board. For example, if a row is 3 characters long, you shouldn\u0026rsquo;t be allocating 100 bytes of space for that row. We highly recommend against using getline since it is not memory efficient and will most likely fail autograder tests.\nHint: realloc may be helpful for this task.\nTasks 5 and 6 combined will create a game_state_t struct in memory with all its fields set up. In this task, please set num_snakes to 0 and set the snakes array to NULL, since these will be initialized in task 6.\nload_board Arguments\tFILE* file\tA file pointer where the board can be read from Return values\tgame_state_t *\tA pointer to the newly created game_state_t struct. NULL if there are any errors. Use make run-unit-tests and make debug-unit-tests to run the provided unit tests (which are not comprehensive). You can also use p print_board(state, stdout) to print out your entire board while debugging in cgdb.\nTask 6: initialize_snake Implement the initialize_snake function in state.c. This function takes in a game board and creates the array of snake_t structs.\nYou are free to implement this function however you want, but if you\u0026rsquo;d like, you can work through this task by implementing the helper function we\u0026rsquo;ve provided.\nTask 6.1: find_head Implement the find_head function in state.c. Given a snake_t struct with the tail row and column filled in, this function traces through the board to find the head row and column, and fills in the head row and column in the struct.\nfind_head Arguments\tgame_state_t* state\tA pointer to the game_state_t struct to be analyzed int snum\tThe index of the snake to be analyzed Return values\tNone As an example, consider the following board:\n##############\n#\r* #\r#\rd\u0026gt;v #\rv #\rW v #\r^\u0026laquo;\u0026lt; #\r#\r############## Assuming that state is a pointer to this game state, then find_head(state, 0) will fill in the head_row and head_col fields of the snake 0 struct with 6 and 3, respectively.\nUse make run-unit-tests and make debug-unit-tests to run the provided unit tests. You can also use p print_board(state, stdout) to print out your entire board while debugging in cgdb.\nTask 6.2: initialize_snake Using find_head, implement the initialize_snake function in state.c. You can assume that the state passed into this function is the result of calling load_board, but you may not assume that the snakes array is defined. This means the board-related fields are already filled in, and you only need to fill in num_snakes and create the snakes array.\nYou may assume that all snakes on the board start out alive.\ninitialize_snakes Arguments\tgame_state_t* state\tA pointer to the game_state_t struct to be filled in Return values\tgame_state_t* state\tA pointer to the game_state_t struct with fields filled in. This can be the same as the struct passed in (you can modify the struct in-place). Use make run-unit-tests and make debug-unit-tests to run the provided unit tests. You can also use p print_board(state, stdout) to print out your entire board while debugging in cgdb.\nTask 7: main Using the functions you implemented in all the previous tasks, fill in the blanks in snake.c. Each time the snake.c program is run, the board will be updated by one time step.\nTo test your full implementation, run make run-integration-tests.\nTo debug your implementation, run cgdb \u0026ndash;args ./snake -i tests/TESTNAME-in.snk -o tests/TESTNAME-out.snk. To check for memory leaks or out-of-bounds reads/writes, you can run valgrind ./snake -i tests/TESTNAME-in.snk -o tests/TESTNAME-out.snk. Replace TESTNAME with one of the test names in the tests folder:\n01-simple 02-direction 03-tail 04-food 05-wall 06-small 07-medium 08-multisnake 09-everything 10-filled 11-manyclose 12-corner 13-sus 14-orochi 15-hydra 16-huge 17-wide 18-tall 19-101-127 20-long-line 21-bigL Similarly, you can test loading from stdin by running ./snake \u0026ndash;stdin -o tests/TESTNAME-out.snk \u0026lt; tests/TESTNAME-in.snk, then running diff tests/TESTNAME-ref.snk tests/TESTNAME-out.snk. To debug, run either cgdb ./snake followed by set args \u0026ndash;stdin -o tests/TESTNAME-out.snk \u0026lt; tests/TESTNAME-in.snk or run valgrind ./snake \u0026ndash;stdin -o tests/TESTNAME-out.snk \u0026lt; tests/TESTNAME-in.snk. Note: this behavior is not explicitly tested with make run-unit-tests or make run-integration-tests, but will be tested on the autograder.\nYou can also run make run-nonexistent-input-file-test to make sure that your program correctly exits with error code -1 if the input file doesn\u0026rsquo;t exist.\nTask 8: Partner/Feedback Form Congratulations on finishing the project! This is a relatively new project, so we\u0026rsquo;d love to hear your feedback on what can be improved for future semesters.\nPlease fill out this short form, where you can offer your thoughts on the project and (if applicable) your partnership. Any feedback you provide won\u0026rsquo;t affect your grade, so feel free to be honest and constructive.\nSubmission and Grading Submit your code to the Project 1 Gradescope assignment. Make sure that you have only modified snake.c, state.c, and custom_tests.c. You can submit to Gradescope as many times as you want, and the score you see on Gradescope will be your final score for this project.\nJust for fun: play snake Now you can play a game with the code you\u0026rsquo;ve written by make interactive-snake followed by ./interactive-snake. Use the wasd keys to control your snake!\nTo speed up or slow down the game, you can run ./interactive-snake -d 0.5 (replacing 0.5 with the number of seconds between time steps). During the game, you can also press ] to move faster and [ to move slower.\n"},{"id":3,"href":"/posts/linux_tools_course/","title":"Linux Tools Course","section":"Resources","content":"To get familiar with Linux tools that are generally helpful for computer science, please go through the material here: https://missing.csail.mit.edu/\n"},{"id":4,"href":"/posts/linear_algebra_in_c/","title":"Linear Algebra in C","section":"Resources","content":"See implementation of a linear algebra library in C here: https://www.andreinc.net/2021/01/20/writing-your-own-linear-algebra-matrix-library-in-c\n"},{"id":5,"href":"/posts/video_lectures/","title":"Video Lectures from Elsewhere","section":"Resources","content":"You can find some video lectures on c programming from other universities bellow:\nUni. of Nebraska, Lincon Harvard\nhttps://cs50.harvard.edu/x/2023/\nhttps://www.youtube.com/watch?v=8mAITcNt710 "},{"id":6,"href":"/docs/course_material/lectures/4_10/","title":"01 Typedef, Struct Initialization, Passing Pointers","section":"Lectures","content":"\r01 Typedef, Struct Initialization\r#\rStruct without Typedef\r#\r#include\u0026lt;stdio.h\u0026gt; struct rectangle { float length; float breadth; }; float compute_area(struct rectangle r) { return r.length * r.breadth; } void print_rectangle(struct rectangle r) { printf(\u0026#34;Rectangle with length %f and breadth %f\\n\u0026#34;, r.length, r.breadth); } int main() { struct rectangle rect = { 1.5, 3.2 }; // Initializer print_rectangle(rect); printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(rect) ); } Struct with Typedef\r#\r#include\u0026lt;stdio.h\u0026gt; typedef struct rectangle { float length; float breadth; } rectangle; float compute_area(rectangle r) { return r.length*r.breadth; } rectangle scale(rectangle r, float s) { r.length = r.length*s; r.breadth = r.breadth*s; return r; } int main() { rectangle rect = { .breadth = 1.0, .length = 3.0} /* {3.0, 1.0 }*/; // rect.length = 3.2; // rect.breadth = 1.2; printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(rect)); rectangle rp = scale(rect, 5); printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(*rp)); printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(rect)); } Passing using pointers\r#\r#include\u0026lt;stdio.h\u0026gt; typedef struct rectangle { float length; float breadth; } rectangle; float compute_area(rectangle r) { return r.length*r.breadth; } rectangle* scale(rectangle* r, float s) { r-\u0026gt;length = r-\u0026gt;length*s; r-\u0026gt;breadth = r-\u0026gt;breadth*s; return r; } int main() { rectangle rect = { .breadth = 1.0, .length = 3.0} /* {3.0, 1.0 }*/; // rect.length = 3.2; // rect.breadth = 1.2; printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(rect)); rectangle* rp = scale(\u0026amp;rect, 5); printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(*rp)); printf(\u0026#34;Area of the rectangle is %f \\n\u0026#34;, compute_area(rect)); } "},{"id":7,"href":"/docs/course_material/lectures/6_10/","title":"02 Strings and Enums","section":"Lectures","content":"\r02 Strings and Enums\r#\rStrings in C\r#\ras a pointer to char char *p = \u0026#34;abcde\u0026#34;; as an array of char char s[] = \u0026#34;abcde\u0026#34;; print(\u0026#34;%d %d\u0026#34;, sizeof(p), sizeof(s)); String Function Implementation\r#\r#include \u0026#34;stdio.h\u0026#34; int strlenB(char* s) { int i = 0; while (s[i] != \u0026#39;\\0\u0026#39;) { i++; } return i; } char* strcpyB(char *s, char *d) { int len_s = strlenB(s); for(int i = 0; i \u0026lt;= len_s;i++) { d[i] = s[i]; } return d; } char* str_rev(char *s, char *d) { int len_s = strlenB(s); for(int i = 0; i\u0026lt; len_s; i++) { d[i] = s[len_s - 1 - i]; } d[len_s] = \u0026#39;\\0\u0026#39;; return d; } int main() { char *p = \u0026#34;xyz\\0dsalkfjds\u0026#34;; char s[] = \u0026#34;abcde\\0kjdakfjsh\u0026#34;; // abcde\\0 // printf(\u0026#34;%d %d\\n\u0026#34;,sizeof(p),sizeof(s)); // printf(\u0026#34;%s %s\\n\u0026#34;,p, s); // printf(\u0026#34;%d %d\\n\u0026#34;, strlen(p), strlen(s)); // strcpy(s,p); printf(\u0026#34;%s\\n\u0026#34;,str_rev(p, s)); return 1; } String Functions\r#\r#include \u0026lt;string.h\u0026gt;\nint strlen(char *s): returns the length of the string pointed by s (ie lenth upto the first \\0 in memory). char* strcat(char* s1, char* s2): concatenates s1 with s2, stores it in s1 and returns s1. int strcmp(char *s1,char *s2): returns negative int if s1 is lex. smaller than s2, returns 0 if equal, returns positive int if s1 is lex. greater than s2. char* strcpy(char* s1, char* s2): copies s2 in to s1 and returns s1. Social Network\r#\rName Age Rel Status Friends Alice 24 Single Diestel, Eve Bob 28 Maried Alice Charlie 20 Single Diestel Diestel 27 Not Mentioned Alice, Eve, Charlie Eve 25 Engaged Diestel, Alice Define a Person (Profile)\r#\rstruct Person { char name[100]; int age; int rel_status; }; Implemeting Rel Status as int, requires us to keep in mind the mapping between Single, Maried, Not Mentioned, Engaged and integers.\nCan we specify this in code??\r#\rEnums\r#\rtypedef enum Weekday { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday } Weekday; Weekday today = Wednesday; printf(\u0026#34;Day %d\u0026#34;,today+1); printf(\u0026#34;Size of enum variable = %d bytes\u0026#34;, sizeof(today));\tEnums : Changing default values\r#\rtypedef enum Weekday { Sunday = 1, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday } Weekday; Weekday today = Wednesday; printf(\u0026#34;Day %d\u0026#34;,today+1); Enums : interchangable with int\r#\r#include \u0026#34;stdio.h\u0026#34; typedef enum Weekday { Sunday = 5, Monday = 3, Tuesday, Wednesday = 2, Thursday, Friday, Saturday } Weekday; int main() { Weekday today = Wednesday;; printf(\u0026#34;Day %d\\n\u0026#34;,today+1); printf(\u0026#34;Size of enum variable = %d bytes\u0026#34;, sizeof(today));\treturn 0 ; } Define a Person (Profile)\r#\renum RelStatus { NotMentioned, Single, Engaged, Married }; struct Person { char name[100]; int age; enum RelStatus status; }; Practice Problems\r#\rImplement str_rev in place. ie. it takes only one string (char *) as argument, reverses it. "},{"id":8,"href":"/docs/course_material/lectures/9_10/","title":"03 Macros, More Intializers in Social Nets","section":"Lectures","content":"\r03 Macros, More Intializers in Social Nets\r#\rSocial Nets\r#\rtypedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Person { char name[100]; int age; RelStatus relstatus; struct Person* friends[5]; } Person; typedef struct SocialNet { Person members[100]; int size; } SocialNet; Social Nets with Macros\r#\r#define MAX_FRIENDS 5 #define MAX_MEMBERS 100 #define MAX_NAME_LEN 100 typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Person { char name[MAX_NAME_LEN]; int age; RelStatus relstatus; struct Person* friends[MAX_FRIENDS]; } Person; typedef struct SocialNet { Person members[MAX_MEMBERS]; int size; } SocialNet; Intitializer\r#\rName Age Rel Status Alice 24 Not Mentioned Bob 28 Maried Charlie 20 Single int main() { SocialNet social_net = { .members = { { \u0026#34;Alice\u0026#34;, 24, NotMentioned}, { \u0026#34;Bob\u0026#34;, 28, Married}, { \u0026#34;Charlie\u0026#34;, 20, Single}, } , .size = 3 }; print_network(social_net); return 0; } Print Person\r#\rvoid print_person(struct Person p) { // TODO (solution at the end of page) } void print_network(SocialNet social_net) { printf( \u0026#34;----------------------------------------------\\n\u0026#34; \u0026#34;Name\\t\\tAge \\t Rel Status\\n\u0026#34; \u0026#34;----------------------------------------------\\n\u0026#34;); for (int i=0;i \u0026lt;social_net.size; i++) { print_person(social_net.members[i]); } printf(\u0026#34;----------------------------------------------\\n\u0026#34;); } Finding a person by name\r#\rPerson* find_person(char* name1, SocialNet *sn) { // TODO (solution at the end of page) } HW: Check Mutual Friends by name\r#\rbool check_mutual_friends(char *name1, char *name2, SocialNet *sn) { // TODO p and q are mutual friends if q is in the friend list of p // and p is in the friend list of q } Full Code with Solutions\r#\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Person { char name[100]; int age; RelStatus relstatus; int count_friends; struct Person *friends[5]; } Person; typedef struct SocialNet { Person members[80]; int size; } SocialNet; Person* find_person(char* name1, SocialNet *sn) { for(int i = 0; i \u0026lt; sn-\u0026gt;size; i++) { if ( strcmp(sn-\u0026gt;members[i].name, name1) == 0) { return \u0026amp;(sn-\u0026gt;members[i]); } } return NULL; } void print_person(Person p) { char status_string[][15] = { \u0026#34;Not Mentioned\u0026#34;, \u0026#34;Single\u0026#34;, \u0026#34;Married\u0026#34;, \u0026#34;Engaged\u0026#34; }; printf(\u0026#34;%s\\t\\t%d\\t%s\\n\u0026#34;, p.name, p.age, status_string[p.relstatus]); } void print_network(SocialNet social_net) { printf( \u0026#34;----------------------------------------------\\n\u0026#34; \u0026#34;Name\\t\\tAge \\t Rel Status\\n\u0026#34; \u0026#34;----------------------------------------------\\n\u0026#34;); for (int i=0;i \u0026lt;social_net.size; i++) { print_person(social_net.members[i]); } printf(\u0026#34;----------------------------------------------\\n\u0026#34;); } int main() { SocialNet social_net = { .members = { { \u0026#34;Alice\u0026#34;, 24, NotMentioned}, { \u0026#34;Bob\u0026#34;, 28, Married}, { \u0026#34;Charlie\u0026#34;, 20, Single}, } , .size = 3 }; print_network(social_net); print_person(*find_person(\u0026#34;Bob\u0026#34;, \u0026amp;social_net)); return 0; } "},{"id":9,"href":"/docs/course_material/lectures/11_10/","title":"04 Linked Lists","section":"Lectures","content":"\r04 Linked Lists\r#\rProblem: Large Arrays!\r#\r#define MAX_MEMBERS 100 typedef struct SocialNet { Person members[MAX_MEMBERS]; int size; } SocialNet; Linked List: A array that grows according to needs\r#\rLinked List: Code\r#\rtypedef struct Node { Person data; struct Node* next; } Node; typedef Node* LinkedList; Node third = { {\u0026#34;Alice\u0026#34;, 22}, NULL }; Node second = { {\u0026#34;Bob\u0026#34;, 26}, \u0026amp;third }; Node first = { {\u0026#34;Charlie\u0026#34;, 20}, \u0026amp;second }; LinkedList L = \u0026amp;first; Size of a Liniked List\r#\rint size(LinkedList l) { int s = 0; while (l != NULL) { l = l-\u0026gt;next; s ++; } return s; } A recursive solution\r#\rint size(LinkedList l) { return l==NULL? 0: size(l-\u0026gt;next) + 1; } Printing elements of a linked list\r#\rvoid print_list(LinkedList l) { while (l != NULL) { printf(\u0026#34;%s\\t\\t%d\\n\u0026#34;,l-\u0026gt;data.name, l-\u0026gt;data.age); l = l-\u0026gt;next; } } Find the element at the ith position\r#\rPerson* element_at(int pos, LinkedList l) { int s = 0; while (l != NULL) { if (s == pos) return \u0026amp;(l-\u0026gt;data); l = l-\u0026gt;next; s ++; } return NULL; } A recursive solution\r#\rPerson* element_at_recursive(int pos, LinkedList l) { // TODO if (l==NULL) return NULL; if (pos == 0) {return \u0026amp;(l-\u0026gt;data);} else { return element_at(pos-1, l-\u0026gt;next); } // return pos == 0 ? \u0026amp;(l-\u0026gt;data): element_at(pos-1, l-\u0026gt;next); } Append element to end of the list\r#\rLinkedList append(Person p, LinkedList l) { // Node D = {{\u0026#34;Raj\u0026#34;, 18}, NULL}; Local Variable! Will not work. Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = NULL; if (l == NULL) return D; // if l is empty just return D. while (l-\u0026gt;next != NULL) { l = l-\u0026gt;next; } l-\u0026gt;next = D; return l; } Full code\r#\r#include \u0026#34;stdio.h\u0026#34; #include \u0026#34;stdlib.h\u0026#34; #define MAX_NAME_LEN 100 typedef struct Person { char name[MAX_NAME_LEN]; int age; } Person; typedef struct Node { Person data; struct Node* next; } Node; typedef Node* LinkedList; void print_list(LinkedList l) { printf(\u0026#34;-----------------------------------\\n\u0026#34;); while (l != NULL) { printf(\u0026#34;%s\\t\\t%d\\n\u0026#34;,l-\u0026gt;data.name, l-\u0026gt;data.age); l = l-\u0026gt;next; } printf(\u0026#34;-----------------------------------\\n\u0026#34;); } int size(LinkedList l) { int s = 0; while (l != NULL) { l = l-\u0026gt;next; s ++; } return s; // Simpler recursive solution // return l==NULL? 0: size(l-\u0026gt;next) + 1; } Person* element_at(int pos, LinkedList l) { int s = 0; while (l != NULL) { if (s == pos) return \u0026amp;(l-\u0026gt;data); l = l-\u0026gt;next; s ++; } return NULL; } Person* element_at_recursive(int pos, LinkedList l) { // TODO if (l==NULL) return NULL; if (pos == 0) {return \u0026amp;(l-\u0026gt;data);} else { return element_at(pos-1, l-\u0026gt;next); } // return pos == 0 ? \u0026amp;(l-\u0026gt;data): element_at(pos-1, l-\u0026gt;next); } LinkedList append(Person p, LinkedList l) { // Node D = {{\u0026#34;Raj\u0026#34;, 18}, NULL}; Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = NULL; if (l == NULL) return D; while (l-\u0026gt;next != NULL) { l = l-\u0026gt;next; } l-\u0026gt;next = D; return l; } int main() { Node third = { {\u0026#34;Alice\u0026#34;, 22}, NULL }; Node second = { {\u0026#34;Bob\u0026#34;, 26}, \u0026amp;third }; Node first = { {\u0026#34;Charlie\u0026#34;, 20}, \u0026amp;second }; Person D = {\u0026#34;Raj\u0026#34;, 18}; LinkedList l = \u0026amp;first; printf(\u0026#34;Size of the list is %d\\n\u0026#34;, size(l)); print_list(l); printf(\u0026#34;Element at 1st position: %s\\n\u0026#34;, element_at(1,l)-\u0026gt;name); printf(\u0026#34;Element at 2nd position: %s\\n\u0026#34;, element_at(2,l)-\u0026gt;name); append(D, l); printf(\u0026#34;List after appending\\n\u0026#34;); print_list(l); return 0; } HW: Insert element at a position in the list\r#\rLinkedList insert(Person p, int pos, LinkedList l) { // TODO } HW: Concatenate 2 lists\r#\rLinkedList concat(LinkedList l1, LinkedList l2) { // TODO } HW: Reverse a list\r#\rLinkedList reverse(LinkedList l) { // TODO } "},{"id":10,"href":"/docs/course_material/lectures/16_10/","title":"05 Linked Lists Problems","section":"Lectures","content":"\r05 Linked Lists Problems\r#\rInsert element at a position in the list\r#\rLinkedList insert(Person p, int pos, LinkedList l) { if (pos == 0) { Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = l; return D; } else { l-\u0026gt;next = insert(p, pos-1, l-\u0026gt;next); return l; } } Concatenate 2 lists\r#\rLinkedList concat(LinkedList l1, LinkedList l2) { if (l1 == NULL) { return l2; } else { l1-\u0026gt;next = concat(l1-\u0026gt;next, l2); return l1; } } Reverse a list\r#\rLinkedList reverse(LinkedList l) { int s = size(l); LinkedList l2 = NULL; for (int i = 0; i \u0026lt; s; i++) { l2 = insert(*element_at(s-i-1, l), i, l2); } return l2; } Full code\r#\r#include \u0026#34;stdio.h\u0026#34; #include \u0026#34;stdlib.h\u0026#34; #define MAX_NAME_LEN 100 typedef struct Person { char name[MAX_NAME_LEN]; int age; } Person; typedef struct Node { Person data; struct Node* next; } Node; typedef Node* LinkedList; void print_list(LinkedList l) { printf(\u0026#34;-----------------------------------\\n\u0026#34;); while (l != NULL) { printf(\u0026#34;%s\\t\\t%d\\n\u0026#34;,l-\u0026gt;data.name, l-\u0026gt;data.age); l = l-\u0026gt;next; } printf(\u0026#34;-----------------------------------\\n\u0026#34;); } int size(LinkedList l) { int s = 0; while (l != NULL) { l = l-\u0026gt;next; s ++; } // Single line recursive solution // return l == NULL? 0 ; 1 + size(l-\u0026gt;next); return s; } Person* element_at(int pos, LinkedList l) { int s = 0; while (l != NULL) { if (s == pos) return \u0026amp;(l-\u0026gt;data); l = l-\u0026gt;next; s ++; } return NULL; } LinkedList append(Person p, LinkedList l) { if (l == NULL) { // Node D = {{\u0026#34;Raj\u0026#34;, 18}, NULL}; Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = NULL; return D; } else { l-\u0026gt;next = append(p, l-\u0026gt;next); } return l; } LinkedList insert(Person p, int pos, LinkedList l) { if (pos == 0) { Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = l; return D; } else { l-\u0026gt;next = insert(p, pos-1, l-\u0026gt;next); return l; } } LinkedList concat(LinkedList l1, LinkedList l2) { if (l1 == NULL) { return l2; } else { l1-\u0026gt;next = concat(l1-\u0026gt;next, l2); return l1; } } LinkedList reverse(LinkedList l) { int s = size(l); LinkedList l2 = NULL; for (int i = 0; i \u0026lt; s; i++) { l2 = insert(*element_at(s-i-1, l), i, l2); } return l2; } int main() { Node third = { {\u0026#34;Alice\u0026#34;, 22}, NULL }; Node second = { {\u0026#34;Bob\u0026#34;, 26}, \u0026amp;third }; Node first = { {\u0026#34;Charlie\u0026#34;, 20}, \u0026amp;second }; Person D = {\u0026#34;Raj\u0026#34;, 18}; Node l2 = { D, NULL}; LinkedList l = \u0026amp;first; printf(\u0026#34;Size of the list is %d\\n\u0026#34;, size(l)); print_list(l); l = concat( \u0026amp;l2,l); print_list(l); print_list(reverse(l)); // print_list(insert(D,2,l)); // printf(\u0026#34;Element at 1st position: %s\\n\u0026#34;, element_at(1,l)-\u0026gt;name); // printf(\u0026#34;Element at 2nd position: %s\\n\u0026#34;, element_at(2,l)-\u0026gt;name); // append(D, l); // printf(\u0026#34;List after appending\\n\u0026#34;); // print_list(l); return 0; } HW: Reverse a LinkedList in place\r#\rvoid reverse_inplace(LinkedList l) { // If l is a-\u0026gt;b-\u0026gt;c-\u0026gt;d // after executing reverse_inplace(l) // l should become d-\u0026gt;c-\u0026gt;b-\u0026gt;a // the function also should not use another linkedlist or array } HW: Shuffle 2 lists\r#\rLinkedList shuffle(LinkedList l1, LinkedList l2) { // If l1 is a-\u0026gt;b-\u0026gt;c-\u0026gt;d and l2 is 1-\u0026gt;2-\u0026gt;3-\u0026gt;4 // shuffle(l1,l2) should return the list // a-\u0026gt;1-\u0026gt;b-\u0026gt;2-\u0026gt;c-\u0026gt;3-\u0026gt;d-\u0026gt;4 } Can you make the above function also in place? That is it should not use any additional array or linked list other than l1 and l2.\r#\rHW: Free memory in a LinkedList\r#\rvoid free(LinkedList l) { // free all memory used by a linked list l } HW: Sort a LinkedList\r#\rLinkedList sort(LinkedList l) { // sort the linked list l and return it. } HW: Write the social network program using LinkedList\r#\rUse a Linked list instead of array in the social network program to save memory. You can used a linked list instead of the members array in Social Net. Can we replace the friends array (in Person) also with a LinkedList?\ntypedef struct Person { char name[100]; int age; RelStatus relstatus; int count_friends; Person* friends[5]; } Person; typedef struct SocialNet { struct Person members[100]; int size; } SocialNet; Implement the check_mutual_friendship function from the last days homework with the social network made using linked lists.\nSolution: Shuffle in place\r#\rLinkedList shuffle_inplace(LinkedList l1, LinkedList l2) { Node* head = l1; Node* temp1; Node* temp2; while (l1 != NULL \u0026amp;\u0026amp; l2 != NULL) { temp1 = l1-\u0026gt;next; temp2 = l2-\u0026gt;next; l1-\u0026gt;next = l2; if (temp1 == NULL) { break; } l2-\u0026gt;next = temp1; l1 = temp1; l2 = temp2; } return head; } "},{"id":11,"href":"/docs/course_material/lectures/18_10/","title":"06 More Linked List Problems","section":"Lectures","content":"\r06 More Linked List Problems\r#\rReverse a LinkedList in place\r#\rLinkedList node_append(Node* n, LinkedList l) { if (l == NULL) { return n; } else { l-\u0026gt;next = node_append(n, l-\u0026gt;next); return l; } } // Recursive Solution LinkedList reverse_in_place(LinkedList l) { if (l == NULL) { return l; } else { LinkedList rev = reverse_in_place(l-\u0026gt;next); l-\u0026gt;next = NULL; rev = node_append(l, rev); return rev; } } Free memory in a LinkedList\r#\rvoid free_linked_list(LinkedList l) { if (l == NULL) { return; } else { LinkedList tail = l-\u0026gt;next; free(l); free_linked_list(tail); } } Sort a LinkedList\r#\r// assuming a \u0026lt; b // swaping is done by copy the data field in Node LinkedList swap(LinkedList l, int a, int b) { LinkedList head = l; Person temp; Node* a_ptr; Node* b_ptr; // Find above while(a \u0026gt;= 1) { l = l-\u0026gt;next; a--; b--; } a_ptr = l; while(b \u0026gt;= 1) { l = l-\u0026gt;next; b--; } b_ptr = l; temp = a_ptr-\u0026gt;data; a_ptr-\u0026gt;data = b_ptr-\u0026gt;data; b_ptr-\u0026gt;data = temp; return head; } LinkedList sort(LinkedList l) { // sort the linked list l and return it. // use swap to implement sorting } Write the social network program using LinkedList\r#\rUse a Linked list instead of array in the social network program to save memory. You can used a linked list instead of the members array in Social Net. Can we replace the friends array (in Person) also with a LinkedList?\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Person { char name[100]; int age; RelStatus relstatus; int count_friends; struct Person* friends[5]; } Person; typedef struct Node { Person data; struct Node* next; } Node; typedef Node* LinkedList; typedef struct SocialNet { LinkedList members; int size; } SocialNet; void print_person(struct Person p) { char status_string[][20] = { \u0026#34;Not Mentioned\u0026#34;, \u0026#34;Single\u0026#34;, \u0026#34;Engaged\u0026#34;, \u0026#34;Married\u0026#34; }; printf(\u0026#34;%s\\t\\t%d\\t%s\\t\\t\\t\u0026#34;, p.name, p.age, status_string[p.relstatus]); for (int i = 0; i \u0026lt; p.count_friends; i++) { printf(\u0026#34;%s, \u0026#34;,p.friends[i]-\u0026gt;name); } printf(\u0026#34;\\n\u0026#34;); } void print_network(SocialNet social_net) { LinkedList l = social_net.members; printf( \u0026#34;-------------------------------------------------------------------\\n\u0026#34; \u0026#34;Name\\t\\tAge \\tRel Status\\t\\tFriends\\n\u0026#34; \u0026#34;-------------------------------------------------------------------\\n\u0026#34;); while (l!=NULL) { print_person(l-\u0026gt;data); l = l-\u0026gt;next; } printf( \u0026#34;-------------------------------------------------------------------\\n\u0026#34;); } Person* find_person(char* name, SocialNet *sn) { // TODO LinkedList l = sn-\u0026gt;members; while(l!= NULL) { if (strcmp(l-\u0026gt;data.name, name) == 0) { return \u0026amp;(l-\u0026gt;data); } l = l-\u0026gt;next; } return NULL; } bool check_mutual_friendship(char* name1, char* name2, SocialNet* sn) { Person* p = find_person(name1, sn); Person* q = find_person(name2, sn); bool q_in_fl_of_p = false; bool p_in_fl_of_q = false; for(int i =0; i\u0026lt; p-\u0026gt;count_friends; i++) { if (q == p-\u0026gt;friends[i]) { q_in_fl_of_p = true; } } for(int i =0; i\u0026lt; q-\u0026gt;count_friends; i++) { if (p == q-\u0026gt;friends[i]) { p_in_fl_of_q = true; } } if (p_in_fl_of_q \u0026amp;\u0026amp; q_in_fl_of_p) { return true; } else { return false; } } LinkedList append(Person p, LinkedList l) { if (l == NULL) { // Node D = {{\u0026#34;Raj\u0026#34;, 18}, NULL}; Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = NULL; return D; } else { l-\u0026gt;next = append(p, l-\u0026gt;next); } return l; } Person* element_at(int pos, LinkedList l) { int s = 0; while (l != NULL) { if (s == pos) return \u0026amp;(l-\u0026gt;data); l = l-\u0026gt;next; s ++; } return NULL; } int main() { SocialNet social_net = { .members=NULL, .size = 0}; Person A = { \u0026#34;Alice\u0026#34;, 24, Single, 2}; Person B = { \u0026#34;Bob\u0026#34;, 20, Engaged, 0}; Person C = { \u0026#34;Charlie\u0026#34;, 26, Married, 1}; social_net.members = append( A,social_net.members); social_net.members = append( B,social_net.members); social_net.members = append( C,social_net.members); //social_net.members[0].friends[0] = \u0026amp;(social_net.members[1]); // social_net.members[0].friends[1] = \u0026amp;(social_net.members[2]); social_net.members-\u0026gt;data.friends[0] = element_at(1, social_net.members); social_net.members-\u0026gt;data.friends[1] = element_at(2, social_net.members); // social_net.members[2].friends[0] = \u0026amp;(social_net.members[1]); element_at(2, social_net.members)-\u0026gt;friends[0] = element_at(0, social_net.members); print_network(social_net); print_person(*find_person(\u0026#34;Alice\u0026#34;, \u0026amp;social_net)); print_person(*find_person(\u0026#34;Bob\u0026#34;, \u0026amp;social_net)); print_person(*find_person(\u0026#34;Charlie\u0026#34;, \u0026amp;social_net)); printf(\u0026#34;Is Alice and Charlie mutual friends: %d\\n\u0026#34;, check_mutual_friendship(\u0026#34;Alice\u0026#34;, \u0026#34;Charlie\u0026#34;, \u0026amp;social_net)); printf(\u0026#34;Is Alice and Bob mutual friends: %d\\n\u0026#34;, check_mutual_friendship(\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026amp;social_net)); return 0; } Implement the check_mutual_friendship function from the last days homework with the social network made using linked lists.\nShuffle in place\r#\r// If l1 is a-\u0026gt;b-\u0026gt;c-\u0026gt;d and l2 is 1-\u0026gt;2-\u0026gt;3-\u0026gt;4 // shuffle(l1,l2) should return the list // a-\u0026gt;1-\u0026gt;b-\u0026gt;2-\u0026gt;c-\u0026gt;3-\u0026gt;d-\u0026gt;4 LinkedList shuffle_inplace(LinkedList l1, LinkedList l2) { Node* head = l1; Node* temp1; Node* temp2; while (l1 != NULL \u0026amp;\u0026amp; l2 != NULL) { temp1 = l1-\u0026gt;next; temp2 = l2-\u0026gt;next; l1-\u0026gt;next = l2; if (temp1 == NULL) { break; } l2-\u0026gt;next = temp1; l1 = temp1; l2 = temp2; } return head; } "},{"id":12,"href":"/docs/course_material/lectures/27_10/","title":"07 Commandline Args \u0026 Multifile Programming","section":"Lectures","content":"\r07 Commandline Args \u0026amp; Multifile Programming\r#\rCommandline Argument\r#\r#include \u0026#34;stdio.h\u0026#34; int main(int argc, char* argv[]) { printf(\u0026#34;The number of arguments is %d\\n\u0026#34;, argc); for (int i = 0; i \u0026lt; argc; i++) { printf(\u0026#34;%d Argument: %s\\n\u0026#34;, i, argv[i]); } return 0; } Write a program that takes the First Name Last Name Age as commandline arguments and prints it as follows First Name: Last name : Age : /// Command Line Arguments // Write a program that takes the First Name Last Name Age // as commandline arguments and prints it as follows // First Name: \u0026lt;first arg\u0026gt; // Last name : \u0026lt;sec arg\u0026gt; // Age : \u0026lt;third arg\u0026gt; #include \u0026#34;stdio.h\u0026#34; int main(int argc, char* argv[]) { if (argc != 4) { printf(\u0026#34;Incorrect number of arguments provided.\\n\u0026#34;); return 0; } printf(\u0026#34;First Name:\\t%s\\n\u0026#34;, argv[1]); printf(\u0026#34;Last Name :\\t%s\\n\u0026#34;, argv[2]); printf(\u0026#34;Age :\\t%s\\n\u0026#34;, argv[3]); return 0; } Multifile Programming\r#\rCode listed bellow also available at https://github.com/cpro-iiit/cpro-iiit.github.io/tree/main/lecs/multifile_progs/sample.\nProgram need to be compiled with the command:\ngcc main.c linked_list.c social_net.c linked_list.h\r#\rtypedef struct Node Node; typedef Node* LinkedList; typedef struct Person Person; struct Node { struct Person* data; struct Node* next; }; LinkedList append(Person* p, LinkedList l); int size(LinkedList l); linked_list.c\r#\r#include \u0026#34;linked_list.h\u0026#34; #include \u0026#34;stdlib.h\u0026#34; int size(LinkedList l) { return l == NULL? 0: 1+size(l-\u0026gt;next); } LinkedList append(Person* p, LinkedList l) { if (l == NULL) { Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = NULL; return D; } else { l-\u0026gt;next = append(p, l-\u0026gt;next); } return l; } social_net.h\r#\r#include \u0026#34;linked_list.h\u0026#34; #include \u0026#34;stdbool.h\u0026#34; typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Person { char name[100]; int age; RelStatus relstatus; LinkedList friends; } Person; typedef struct SocialNet { LinkedList members; } SocialNet; void print_person(Person* p); void print_network(LinkedList m); Person* find_person(char* name, LinkedList l); char* person_with_most_friends(LinkedList l); int popularity(char* name, LinkedList l); LinkedList delete_by_name(char* name, LinkedList l); LinkedList filterby_age(LinkedList l, int lower, int upper); bool friends_triangle(LinkedList members); bool transitive_friendship(LinkedList members) ; social_net.c\r#\r#include \u0026#34;social_net.h\u0026#34; #include \u0026#34;stdio.h\u0026#34; #include \u0026#34;stdlib.h\u0026#34; #include \u0026#34;string.h\u0026#34; void print_person(Person* p) { char status_string[][15] = { \u0026#34;Not Mentioned\u0026#34;,\u0026#34;Single\u0026#34;, \u0026#34;Married\u0026#34;, \u0026#34;Engaged\u0026#34; }; printf(\u0026#34;%s\\t\\t%d\\t%s\\t\\t\\t\u0026#34;, p-\u0026gt;name, p-\u0026gt;age, status_string[p-\u0026gt;relstatus]); LinkedList f = p-\u0026gt;friends; while (f != NULL) { printf(\u0026#34;%s, \u0026#34;, f-\u0026gt;data-\u0026gt;name); f = f-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); } void print_network(LinkedList m) { printf( \u0026#34;------------------------------------------------------\\n\u0026#34; \u0026#34;Name\\t\\tAge\\tStatus\\t\\t\\tFriends\\n\u0026#34; \u0026#34;------------------------------------------------------\\n\u0026#34;); while (m != NULL) { print_person(m-\u0026gt;data); m = m-\u0026gt;next; } printf(\u0026#34;------------------------------------------------------\\n\u0026#34;); } Person* find_person(char* name, LinkedList l) { // Either find the person with a particular name // if not found return NULL while(l!= NULL) { if (strcmp(l-\u0026gt;data-\u0026gt;name, name) == 0) { return l-\u0026gt;data; } l = l-\u0026gt;next; } return NULL; } char* person_with_most_friends(LinkedList l) { // Q A1: Return the name of the person with most friends // (3 marks) int d = 0; Node* n = NULL; while(l != NULL) { int e = size(l-\u0026gt;data-\u0026gt;friends); if (e \u0026gt; d) { d = e; n = l; } l = l-\u0026gt;next; } return n==NULL? \u0026#34;\u0026#34; : n-\u0026gt;data-\u0026gt;name; } int popularity(char* name, LinkedList l) { // Q B1: Return the number of people who has the person // named `name` amoung their friends. (3 marks) int count = 0; while ( l!= NULL) { if (find_person(name, l-\u0026gt;data-\u0026gt;friends) != NULL) { count++; } } return count; } LinkedList delete_by_name(char* name, LinkedList l) { // Q A2: Delete the person named `name` from l (3 marks) if (l == NULL) { return NULL; } else if (strcmp(name, l-\u0026gt;data-\u0026gt;name) == 0) { Node* tail = l-\u0026gt;next; free(l); return tail; } else { l-\u0026gt;next = delete_by_name(name, l-\u0026gt;next); return l; } } LinkedList filterby_age(LinkedList l, int lower, int upper) { // Q B2: Return the link list of people in l with age // between lower and upper (3 marks) LinkedList l2 = NULL; while(l != NULL) { if (l-\u0026gt;data-\u0026gt;age \u0026gt;= lower \u0026amp;\u0026amp; l-\u0026gt;data-\u0026gt;age \u0026lt;= upper) { l2 = append(l-\u0026gt;data, l2); } l = l-\u0026gt;next; } return l2; } bool friends_triangle(LinkedList members) { // Q A3: Check if there is a triangle of friends // ie there exists X, Y, Z such that // Y is a friend of X, Z is a friend of Y, X is a friend of Z // ALso print all such triplets (4 marks) LinkedList f = members; printf( \u0026#34;-----------------------------\\n\u0026#34; \u0026#34;Friend Triangles\\n\u0026#34; \u0026#34;-----------------------------\\n\u0026#34;); bool found = false; while(f != NULL) { LinkedList s = f-\u0026gt;data-\u0026gt;friends; while (s != NULL) { LinkedList t = s-\u0026gt;data-\u0026gt;friends; while (t != NULL) { LinkedList l = t-\u0026gt;data-\u0026gt;friends; while (l != NULL) { if (strcmp(l-\u0026gt;data-\u0026gt;name, f-\u0026gt;data-\u0026gt;name)==0) { printf(\u0026#34;%s-\u0026gt;%s-\u0026gt;%s-\u0026gt;%s\\n\u0026#34;, f-\u0026gt;data-\u0026gt;name, s-\u0026gt;data-\u0026gt;name, t-\u0026gt;data-\u0026gt;name, f-\u0026gt;data-\u0026gt;name); found = true; } l = l-\u0026gt;next; } t = t-\u0026gt;next; } s = s-\u0026gt;next; } f = f-\u0026gt;next; } printf(\u0026#34;-------------------------\\n\u0026#34;); return found; } bool transitive_friendship(LinkedList members) { // Q B3: check if the friendship relation is transitive // ie for any X,Y, Z, if Y is a friend of X and // Z is a friend of Y then Z is a friend of X // Also print all the links that violates transitivity // (4 marks) LinkedList f = members; printf( \u0026#34;-----------------------------\\n\u0026#34; \u0026#34;Links that are not Transitive\\n\u0026#34; \u0026#34;-----------------------------\\n\u0026#34;); bool found = false; while(f != NULL) { LinkedList s = f-\u0026gt;data-\u0026gt;friends; while (s != NULL) { LinkedList t = s-\u0026gt;data-\u0026gt;friends; while (t != NULL) { if (find_person(t-\u0026gt;data-\u0026gt;name, f-\u0026gt;data-\u0026gt;friends) == NULL) { printf(\u0026#34;%s-\u0026gt;%s-\u0026gt;%s, but there is no %s-\u0026gt;%s\\n\u0026#34;, f-\u0026gt;data-\u0026gt;name, s-\u0026gt;data-\u0026gt;name, t-\u0026gt;data-\u0026gt;name, f-\u0026gt;data-\u0026gt;name,t-\u0026gt;data-\u0026gt;name); found = true; } t = t-\u0026gt;next; } s = s-\u0026gt;next; } f = f-\u0026gt;next; } printf(\u0026#34;-------------------------\\n\u0026#34;); return !found; } main.c\r#\r#include \u0026#34;social_net.h\u0026#34; #include \u0026#34;stdio.h\u0026#34; int main() { SocialNet s = { NULL }; Person A = {\u0026#34;Alice\u0026#34;, 23, Single, NULL}; Person B ={\u0026#34;Bob\u0026#34;, 26, Engaged, NULL}; Person C = {\u0026#34;Charlie\u0026#34;, 21, NotMentioned, NULL}; Person D ={\u0026#34;Don\u0026#34;, 28, Married, NULL}; s.members = append(\u0026amp;A, s.members); s.members = append(\u0026amp;B, s.members); s.members = append(\u0026amp;C, s.members); s.members = append(\u0026amp;D, s.members); A.friends = append(\u0026amp;B, A.friends); A.friends = append(\u0026amp;C, A.friends); B.friends = append(\u0026amp;D, B.friends); C.friends = append(\u0026amp;D, C.friends); D.friends = append(\u0026amp;A, D.friends); printf(\u0026#34;List of people between ages 24 to 28:\\n\u0026#34;); print_network(filterby_age(s.members, 24, 28)); printf(\u0026#34;The person with most friends is %s.\\n\u0026#34;,person_with_most_friends(s.members)); // For above social network, `friends_triangle(s.members)` // returns `true` and prints // ----------------------------- // Friend Triangles // ----------------------------- // Alice-\u0026gt;Bob-\u0026gt;Don-\u0026gt;Alice // Alice-\u0026gt;Charlie-\u0026gt;Don-\u0026gt;Alice // Bob-\u0026gt;Don-\u0026gt;Alice-\u0026gt;Bob // Charlie-\u0026gt;Don-\u0026gt;Alice-\u0026gt;Charlie // Don-\u0026gt;Alice-\u0026gt;Bob-\u0026gt;Don // Don-\u0026gt;Alice-\u0026gt;Charlie-\u0026gt;Don // ------------------------- friends_triangle(s.members); // For the above social network, `transitive_friendship(s.members)` // returns false and prints // ----------------------------- // Links that are not Transitive // ----------------------------- // Alice-\u0026gt;Bob-\u0026gt;Don, but there is no Alice-\u0026gt;Don // Alice-\u0026gt;Charlie-\u0026gt;Don, but there is no Alice-\u0026gt;Don // Bob-\u0026gt;Don-\u0026gt;Alice, but there is no Bob-\u0026gt;Alice // Charlie-\u0026gt;Don-\u0026gt;Alice, but there is no Charlie-\u0026gt;Alice // Don-\u0026gt;Alice-\u0026gt;Bob, but there is no Don-\u0026gt;Bob // Don-\u0026gt;Alice-\u0026gt;Charlie, but there is no Don-\u0026gt;Charlie // ------------------------- transitive_friendship(s.members); return 0; } Home Work\r#\rFill up the code for the matrix functions bellow and\nHW6: also seperate it out into multiple files (matrix.h, matrix.c, main.c) as we did in class.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct Matrix { int num_rows; int num_cols; float** data; } Matrix; Matrix* create_matrix(int r, int c) { Matrix* m = (Matrix*) malloc(sizeof(Matrix)); m-\u0026gt;num_rows = r; m-\u0026gt;num_cols = c; m-\u0026gt;data = (float**) calloc(r, sizeof(float*)); for (int i =0; i \u0026lt; r; i++) { m-\u0026gt;data[i] = (float*) calloc(c, sizeof(float)); } return m; } void destroy_matrix(Matrix* m) { // HW1: Write code here to free all memory used by the matrix stored in m } Matrix* add_matrix(Matrix* A, Matrix* B) { // HW2: write code here to add the matrices A, B and return a new matrix which has the results. // A, B should remain unmodified. If dimensions doesnt match should return NULL } Matrix* mult_matrix(Matrix* A, Matrix* B) { // HW3: write code here to multiply the matrices A, B and return a new matrix which has the results. // A, B should remain unmodified. If the dimensions doesnt match it should return NULL } Matrix* scalar_mult_matrix(float s, Matrix* M) { // HW4: write code here to multiply the matrix A with a scalar s and return a new matrix which has the results. // A should remain unmodified. } void print_matrix(Matrix* m) { for (int i = 0; i \u0026lt; m-\u0026gt;num_rows; i++) { for (int j = 0; j \u0026lt; m-\u0026gt;num_cols; j++) { printf(\u0026#34;%f\\t\u0026#34;, m-\u0026gt;data[i][j]); } printf(\u0026#34;\\n\u0026#34;); } } int main(int argc, char* argv[]) { // row size will be provided as the first arg // col size will be provided as the second arg // remaining row size * column size args will be the entries // of the matrix in row major order Matrix* m = create_matrix(3,3); print_matrix(m); // HW5: write code to create matrix of the dimension provied in first and second arg // and initialize it with the values provided as the remaing args return 0; } "},{"id":13,"href":"/docs/course_material/lectures/30_10/","title":"08 Advanced Pointers","section":"Lectures","content":"\r08 Advanced Pointers\r#\rPointer to Pointer for LinkedList functions\r#\rFull Code\nvoid insert_v2(Person p, int pos, LinkedList* l) { *l = insert(p, pos, *l); } void reverse_v2(LinkedList* l) { *l = reverse(*l); } int main() { Node third = { {\u0026#34;Alice\u0026#34;, 22, Single}, NULL }; Node second = { {\u0026#34;Bob\u0026#34;, 26, Married}, \u0026amp;third }; Node first = { {\u0026#34;Charlie\u0026#34;, 20, Engaged}, \u0026amp;second }; Person D = {\u0026#34;Raj\u0026#34;, 18, NotMentioned}; Node l2 = { D, NULL}; Person E = {\u0026#34;Eve\u0026#34;, 28, Married}; Node l3 = { E, NULL}; LinkedList l = \u0026amp;first; printf(\u0026#34;Size of the list is %d\\n\u0026#34;, size(l)); print_list(l); //l = reverse(l); reverse_v2(\u0026amp;l); print_list(l); // l = insert(D,2,l); // Problem1: Write the insert function such that, // we dont need to reassign l to the return value // of the function to update it. That is the // line bellow is equivalent to line above insert_v2(D, 2, \u0026amp;l); insert_v2(E, 3, \u0026amp;l); print_list(l); return 0; } Function Pointers\r#\rA variable to store address of functions\nbool check1(Person p) { return p.status == Single \u0026amp;\u0026amp; p.age \u0026lt; 24; } bool check2(Person p) { return p.age \u0026lt;= 26 \u0026amp;\u0026amp; p.age \u0026gt;= 16; } // check_person can store address of check or check_2 bool (*check_person)(Person p) = \u0026amp;check1; Function which takes function as arguments (Higher Order Functions)\r#\rSuppose we want to filter person who is Single and age \u0026lt;= 24, how to implement it.\nCopy paste solution\r#\rLinkedList filterby_age(LinkedList l, int lower, int upper) { LinkedList l2 = NULL; while(l != NULL) { if (l-\u0026gt;data.age \u0026gt;= lower \u0026amp;\u0026amp; l-\u0026gt;data.age \u0026lt;= upper) { l2 = append(l-\u0026gt;data, l2); } l = l-\u0026gt;next; } return l2; } LinkedList filter_status_age(LinkedList l, RelStatus s, int age) { LinkedList l2 = NULL; while(l != NULL) { if (l-\u0026gt;data.status == s \u0026amp;\u0026amp; l-\u0026gt;data.age \u0026lt;= age) { l2 = append(l-\u0026gt;data, l2); } l = l-\u0026gt;next; } return l2; } Problem: For every condition, we need to write new functions with similar logic.\nFunction pointer Solution\r#\rFull Code\nLinkedList filter(LinkedList l, bool (*check)(Person)) { LinkedList l2 = NULL; while(l != NULL) { if ((*check)(l-\u0026gt;data) == true) { l2 = append(l-\u0026gt;data, l2); } l = l-\u0026gt;next; } return l2; } int main() { Node third = { {\u0026#34;Alice\u0026#34;, 22, Single}, NULL }; Node second = { {\u0026#34;Bob\u0026#34;, 26, Married}, \u0026amp;third }; Node first = { {\u0026#34;Charlie\u0026#34;, 20, Engaged}, \u0026amp;second }; Person D = {\u0026#34;Raj\u0026#34;, 18, NotMentioned}; Node l2 = { D, NULL}; Person E = {\u0026#34;Eve\u0026#34;, 28, Married}; Node l3 = { E, NULL}; LinkedList l = \u0026amp;first; print_list(l); bool check1(Person p) { return p.status == Single \u0026amp;\u0026amp; p.age \u0026lt; 24; } bool check2(Person p) { return p.age \u0026lt;= 26 \u0026amp;\u0026amp; p.age \u0026gt;= 16; } bool (*check_person)(Person p) = \u0026amp;check1; // Problem2: Filter the linked list of person // who are Single and less than 24 in age. l = filter(l, \u0026amp;check1); print_list(l); return 0; } Find Best Person\r#\rFull Code\nPerson best(LinkedList l, bool (*compare_fn)(Person, Person)) { Person* b = \u0026amp;(l-\u0026gt;data); while(l!= NULL) { if ((*compare_fn)(l-\u0026gt;data, *b)) { b = \u0026amp;(l-\u0026gt;data); // printf(\u0026#34;Best person uptill now is %s\\n\u0026#34;, b-\u0026gt;name); // for debugging } l = l-\u0026gt;next; } return *b; } Inside main\nbool compare_status(Person p, Person q) { // printf(\u0026#34;Compare %s %s\\n\u0026#34;, p.name, q.name); //for debuging return p.status \u0026gt;= q.status; } bool compare_status_age(Person p, Person q) { // printf(\u0026#34;Compare %s %s\\n\u0026#34;, p.name, q.name); // for debugging return (p.status \u0026gt;= q.status) \u0026amp;\u0026amp; (p.age \u0026gt;= q.age); } printf(\u0026#34;Best person is\\n\u0026#34;); print_person(best(l, \u0026amp;compare_status_age)); Homework 1\r#\rSuppose you want to print every person in the linkedlist and would like to customize how each person is printed.\nUse a function pointer as a second argument to print_list function, which prints the person in a customized way. You should be able to pass the pointer to print_person function or any other similar function.\nvoid print_person(Person p) { char status_string[][15] = { \u0026#34;Not Mentioned\u0026#34;,\u0026#34;Single\u0026#34;, \u0026#34;Engaged\u0026#34;, \u0026#34;Married\u0026#34; }; printf(\u0026#34;%s\\t\\t%d\\t%s\\n\u0026#34;,p.name, p.age, status_string[p.status]); } void print_list(LinkedList l) { printf(\u0026#34;-----------------------------------\\n\u0026#34;); while (l != NULL) { print_person(l-\u0026gt;data); l = l-\u0026gt;next; } printf(\u0026#34;-----------------------------------\\n\u0026#34;); } Homework 2\r#\rSuppose you want to find some aggregate value of the elements of the linked list with integer data field. For example, sum of all elements, sum of squares of all elements, sum of absolute values of all elements etc.\nWrite an aggregate function which takes the linked list and a function pointer as arguments. The function pointer should be able to point to functions which implement any of the above functionalites. The aggregate function should return the aggregate value.\ntypedef struct Node { int data; struct Node* next; } Node; typedef Node* LinkedList; // Write functions to find sum of all elements, // sum of squares of all elements, sum of absolute // values of all elements // Generalize above functions to get an agregate function // which the takes the a function poiner where the // aggregation method can be passed. int aggregate(LinkedList l, /* function pointer here */) { // code for aggregae here } Full Code\r#\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #define MAX_NAME_LEN 100 typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Person { char name[MAX_NAME_LEN]; int age; RelStatus status; } Person; typedef struct Node { Person data; struct Node* next; } Node; typedef Node* LinkedList; void print_person(Person p) { char status_string[][15] = { \u0026#34;Not Mentioned\u0026#34;,\u0026#34;Single\u0026#34;, \u0026#34;Engaged\u0026#34;, \u0026#34;Married\u0026#34; }; printf(\u0026#34;%s\\t\\t%d\\t%s\\n\u0026#34;,p.name, p.age, status_string[p.status]); } void print_list(LinkedList l) { printf(\u0026#34;-----------------------------------\\n\u0026#34;); while (l != NULL) { print_person(l-\u0026gt;data); l = l-\u0026gt;next; } printf(\u0026#34;-----------------------------------\\n\u0026#34;); } int size(LinkedList l) { int s = 0; while (l != NULL) { l = l-\u0026gt;next; s ++; } return s; } Person* element_at(int pos, LinkedList l) { int s = 0; while (l != NULL) { if (s == pos) return \u0026amp;(l-\u0026gt;data); l = l-\u0026gt;next; s ++; } return NULL; } LinkedList append(Person p, LinkedList l) { if (l == NULL) { // Node D = {{\u0026#34;Raj\u0026#34;, 18}, NULL}; Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = NULL; return D; } else { l-\u0026gt;next = append(p, l-\u0026gt;next); } return l; } LinkedList insert(Person p, int pos, LinkedList l) { if (pos == 0) { Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = l; return D; } else { l-\u0026gt;next = insert(p, pos-1, l-\u0026gt;next); return l; } } void insert_v2(Person p, int pos, LinkedList* l) { *l = insert(p, pos, *l); } LinkedList filterby_age(LinkedList l, int lower, int upper) { LinkedList l2 = NULL; while(l != NULL) { if (l-\u0026gt;data.age \u0026gt;= lower \u0026amp;\u0026amp; l-\u0026gt;data.age \u0026lt;= upper) { l2 = append(l-\u0026gt;data, l2); } l = l-\u0026gt;next; } return l2; } LinkedList filter(LinkedList l, bool (*check)(Person)) { LinkedList l2 = NULL; while(l != NULL) { if ((*check)(l-\u0026gt;data) == true) { l2 = append(l-\u0026gt;data, l2); } l = l-\u0026gt;next; } return l2; } LinkedList reverse(LinkedList l) { int s = size(l); LinkedList l2 = NULL; for (int i = 0; i \u0026lt; s; i++) { l2 = insert(*element_at(s-i-1, l), i, l2); } return l2; } void reverse_v2(LinkedList* l) { *l = reverse(*l); } Person best(LinkedList l, bool (*compare_fn)(Person, Person)) { Person* b = \u0026amp;(l-\u0026gt;data); while(l!= NULL) { if ((*compare_fn)(l-\u0026gt;data, *b)) { b = \u0026amp;(l-\u0026gt;data); // printf(\u0026#34;Best person uptill now is %s\\n\u0026#34;, b-\u0026gt;name); // for debugging } l = l-\u0026gt;next; } return *b; } int main() { Node third = { {\u0026#34;Alice\u0026#34;, 22, Single}, NULL }; Node second = { {\u0026#34;Bob\u0026#34;, 26, Married}, \u0026amp;third }; Node first = { {\u0026#34;Charlie\u0026#34;, 20, Engaged}, \u0026amp;second }; Person D = {\u0026#34;Raj\u0026#34;, 18, NotMentioned}; Node l2 = { D, NULL}; Person E = {\u0026#34;Eve\u0026#34;, 28, Married}; Node l3 = { E, NULL}; LinkedList l = \u0026amp;first; printf(\u0026#34;Size of the list is %d\\n\u0026#34;, size(l)); print_list(l); l = reverse(l); reverse_v2(\u0026amp;l); print_list(l); // l = insert(D,2,l); // Problem1: Write the insert function such that, // we dont need to reassign l to the return value // of the function to update it. That is the // line bellow is equivalent to line above insert_v2(D, 2, \u0026amp;l); insert_v2(E, 3, \u0026amp;l); print_list(l); bool compare_status(Person p, Person q) { // printf(\u0026#34;Compare %s %s\\n\u0026#34;, p.name, q.name); //for debuging return p.status \u0026gt;= q.status; } bool compare_status_age(Person p, Person q) { // printf(\u0026#34;Compare %s %s\\n\u0026#34;, p.name, q.name); // for debugging return (p.status \u0026gt;= q.status) \u0026amp;\u0026amp; (p.age \u0026gt;= q.age); } printf(\u0026#34;Best person is\\n\u0026#34;); print_person(best(l, \u0026amp;compare_status_age)); bool check1(Person p) { return p.status == Single \u0026amp;\u0026amp; p.age \u0026lt; 24; } bool check2(Person p) { return p.age \u0026lt;= 26 \u0026amp;\u0026amp; p.age \u0026gt;= 16; } bool (*check_person)(Person p) = \u0026amp;check1; // Problem2: Filter the linked list of person // who are Single and less than 24 in age. l = filter(l, \u0026amp;check2); print_list(l); return 0; } "},{"id":14,"href":"/docs/course_material/lectures/01_11/","title":"09 File Handling","section":"Lectures","content":"\r09 File Handling\r#\rOpening/Closing a file\r#\r#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; /* File pointer to hold reference to our file */ FILE * fPtr; /* * Open file in w (write) mode. \u0026#34;data/file1.txt\u0026#34; is complete path to create file */ fPtr = fopen(\u0026#34;data/file1.txt\u0026#34;, \u0026#34;w\u0026#34;); /* fopen() return NULL if last operation was unsuccessful */ if(fPtr == NULL) { /* File not created hence exit */ printf(\u0026#34;Unable to create file.\\n\u0026#34;); exit(0); } /* Done with this file, close file to release resource */ fclose(fPtr); Reading from file\r#\rfgetc() – Used to read single character from file. fgets() – Used to read string from file. fscanf() – Use this to read formatted input from file. fread() – Read block of raw bytes from file. Used to read binary files. Reading\r#\rOpen a file using fopen() function and store its reference in a FILE pointer say fPtr.\nYou must open file in r(read) mode or atleast mode that support read access.\nRead content from file using any of these functions fgetc(), fgets(), fscanf() or fread(). Finally, close the file using fclose(fPtr).\nReading from file, char by char\r#\rdo { /* Read single character from file */ ch = fgetc(fPtr); /* Print character read on console */ putchar(ch); } while(ch != EOF); /* Repeat this if last read character is not EOF */ Copying a file with source/destination as commandline arguments\r#\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(int argc, char* argv[]) { if (argc != 3) { printf(\u0026#34;Invalid arguments\\n\u0026#34;); return 0; } char ch; FILE* s = fopen(argv[1], \u0026#34;r\u0026#34;); FILE* d = fopen(argv[2], \u0026#34;w\u0026#34;); /* fopen() return NULL if last operation was unsuccessful */ if(s == NULL || d == NULL) { /* Unable to open file hence exit */ printf(\u0026#34;Unable to open file.\\n\u0026#34;); printf(\u0026#34;Please check whether file exists and you have read privilege.\\n\u0026#34;); return 0; } /* File open success message */ printf(\u0026#34;File opened successfully. Reading file contents character by character. \\n\\n\u0026#34;); do { /* Read single character from file */ ch = fgetc(s); /* Print character read on console */ putchar(ch); fputc(ch, d); } while(ch != EOF); /* Repeat this if last read character is not EOF */ /* Done with this file, close file to release resource */ fclose(s); fclose(d); return 0; } Reading line by line using fgets()\r#\rchar * fgets(char * str, int num, FILE * stream); #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define BUFFER_SIZE 1000 int main() { /* File pointer to hold reference to our file */ FILE * fPtr; char buffer[BUFFER_SIZE]; int totalRead = 0; int total_chars = 0; /* * Open file in r (read) mode. * \u0026#34;data/file2.txt\u0026#34; is complete file path to read */ fPtr = fopen(\u0026#34;1.c\u0026#34;, \u0026#34;r\u0026#34;); /* fopen() return NULL if last operation was unsuccessful */ if(fPtr == NULL) { /* Unable to open file hence exit */ printf(\u0026#34;Unable to open file.\\n\u0026#34;); printf(\u0026#34;Please check whether file exists and you have read privilege.\\n\u0026#34;); return 0; } /* File open success message */ printf(\u0026#34;File opened successfully. Reading file contents line by line. \\n\\n\u0026#34;); /* Repeat this until read line is not NULL */ while(fgets(buffer, BUFFER_SIZE, fPtr) != NULL) { /* Total character read count */ totalRead = strlen(buffer); total_chars += strlen(buffer); /* Print line read on cosole*/ printf(\u0026#34;%s\u0026#34;, buffer); } printf(\u0026#34;Total number of chars: %d\u0026#34;, total_chars); /* Done with this file, close file to release resource */ fclose(fPtr); return 0; } Home Work\r#\rWrite a program which takes a file name as command line argument and prints the number of chars, words, lines and paragraphs in the file.\n"},{"id":15,"href":"/docs/course_material/lectures/03_11/","title":"10 Libraries","section":"Lectures","content":"\r10 Libraries\r#\rC Library Reference\nRandom Number Generation\r#\rRandom Number Generation Reference\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main(void) { srand(time(NULL)); // use current time as seed for random generator int random_variable = rand(); printf(\u0026#34;Random value on [0,%d]: %d\\n\u0026#34;, RAND_MAX, random_variable); int x; int count[] = { 0,0,0,0,0,0}; for (int i=0; i \u0026lt; 6000; i++) { x = 1+ rand()%6; // printf(\u0026#34;%d \u0026#34;, x); count[x-1]++; } printf(\u0026#34;%d %d %d %d %d %d\\n\u0026#34;, count[0], count[1], count[2], count[3], count[4], count[5]); } Home Work 1\r#\rWrite a program to generate\na uniformly random subset of {1,.., n}. Take n as input. a uniformly random subset of {1,.., n} of size k. Take n, k as input. a uniformly random permutation of {1,.., n}. Take n as input. Date Time Clock\r#\rDate Time Clock Reference\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;time.h\u0026gt; typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Person { char name[100]; int age; RelStatus relstatus; int count_friends; struct Person* friends[5]; } Person; typedef struct SocialNet { struct Person members[100]; int size; } SocialNet; void print_person(struct Person p) { char status_string[][20] = { \u0026#34;Not Mentioned\u0026#34;, \u0026#34;Single\u0026#34;, \u0026#34;Engaged\u0026#34;, \u0026#34;Maried\u0026#34; }; printf(\u0026#34;%s\\t\\t%d\\t%s\\t\\t\u0026#34;, p.name, p.age, status_string[p.relstatus]); for (int i = 0; i \u0026lt; p.count_friends; i++) { printf(\u0026#34;%s, \u0026#34;,p.friends[i]-\u0026gt;name); } printf(\u0026#34;\\n\u0026#34;); } void print_network(SocialNet social_net) { printf( \u0026#34;----------------------------------------------\\n\u0026#34; \u0026#34;Name\\t\\tAge \\t Rel Status\\t\\t\\tFriends\\n\u0026#34; \u0026#34;----------------------------------------------\\n\u0026#34;); for (int i=0;i \u0026lt;social_net.size; i++) { print_person(social_net.members[i]); } printf(\u0026#34;----------------------------------------------\\n\u0026#34;); } // Person* find_person(char* name1, SocialNet *sn) { // // TODO // } int main() { clock_t now = clock(); SocialNet social_net = { { {\u0026#34;Alice\u0026#34;, 24, NotMentioned}, {\u0026#34;Bob\u0026#34;, 22, Married}, {\u0026#34;Charlie\u0026#34;, 28, Engaged} }, 3 }; social_net.members[0].friends[0] = \u0026amp;(social_net.members[1]); social_net.members[0].friends[1] = \u0026amp;(social_net.members[2]); social_net.members[0].count_friends = 2; social_net.members[2].friends[0] = \u0026amp;(social_net.members[1]); social_net.members[2].count_friends = 1; social_net.members[1].count_friends = 0; print_network(social_net); clock_t later = clock(); printf(\u0026#34;%d %d %f\\n\u0026#34;, later, now, ((float)(later-now)/ CLOCKS_PER_SEC)); return 0; } Home Work 2\r#\rWrite a program to print the number of days in the current month.\nWrite a program, which takes an input a date and prints the month calendar where that date belongs.\nFor eg: For today date it should print below:\nNovember 3rd, 2023\rSun Mon Tue Wed Thu Fri Sat 29 30 31 1 2 3* 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 "},{"id":16,"href":"/docs/course_material/assignments/assignment1/","title":"Assignment - 1","section":"Assignments","content":"\rAssignment 1\r#\rQuestion 1\r#\rProblem Description\r#\rGiven an integer n as input, print its binary representation starting with the most significant bit, i.e. don\u0026rsquo;t print the 0\u0026rsquo;s before the first 1.\nLink to problem on OJ\nInput constraints\r#\r\\(\r0 \\le n \\le 2^{30}\r\\)\rInput format\r#\rThe only line of input contains a single integer n\nOutput Format\r#\rOutput a continous stream of bits of n starting from the most significant bit.\nSample input and output\r#\rSample Input Sample Output 11 1011 0 0 Solution\r#\r#include \u0026lt;stdio.h\u0026gt; int main() { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); if (x==0){ printf(\u0026#34;0\u0026#34;); return 0; } int mask = 1 \u0026lt;\u0026lt; 30; int flag_first_one = 0; while (mask) { if (x \u0026amp; mask) { printf(\u0026#34;1\u0026#34;); flag_first_one = 1; } else if (flag_first_one) { printf(\u0026#34;0\u0026#34;); } mask \u0026gt;\u0026gt;= 1; } return 0; } Question 2\r#\rProblem Description\r#\rGiven an integer n between 2 and 100 as input, print all prime numbers from 1 to n (including n) in ascending order.\nLink to problem on OJ\nInput constraints\r#\r\\(\r2 \\le n \\le 100\r\\)\rInput format\r#\rThe only line of input contains a single integer n.\nOutput Format\r#\rOutput all primes that are less than or equal n in ascending order separated by spaces\nSample input and output\r#\rSample Input Sample Output 2 2 6 2 3 5 Solution\r#\r#include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 2; i \u0026lt;= n; i++) { if (i == 2 || i == 3 || i == 5 || i == 7) { printf(\u0026#34;%d \u0026#34;, i); } else if (i % 2 != 0 \u0026amp;\u0026amp; i % 3 != 0 \u0026amp;\u0026amp; i % 5 != 0 \u0026amp;\u0026amp; i % 7 != 0) { printf(\u0026#34;%d \u0026#34;, i); } } return 0; } Question 3\r#\rProblem Description\r#\rYou are given width and height of a rectangle and you need to print that rectangle.\nLook at samples for more clarity.\nThe corners are to be represented by 'o'.\nThe vertical sides are represented by '|'\nThe horizontal sides are represented by '-'\nThe 'o' counts towards both height and width.\nLink to problem on OJ\nInput constraints\r#\r\\(\r1\\leq width\\leq 1000, 1\\leq height\\leq1000\r\\)\rInput format\r#\rTwo space separated integers, width and height.\nOutput Format\r#\rPrint the rectangle with the given width and height.\nSample input and output\r#\rSample Input Sample Output 4 5 o--o\n| |\n| |\n| |\no--o 1 1 o 1 3 o\n|\no 3 2 o-o\no-o Solution\r#\r#include \u0026lt;stdio.h\u0026gt; int main() { int width, height; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;width, \u0026amp;height); for (int i = 1; i \u0026lt;= height; i++) { for (int j = 1; j \u0026lt;= width; j++) { if ((i == 1 \u0026amp;\u0026amp; (j == 1 || j == width)) || (i == height \u0026amp;\u0026amp; (j == 1 || j == width))) printf(\u0026#34;o\u0026#34;); else if (j == 1 || j == width) printf(\u0026#34;|\u0026#34;); else if (i == 1 || i == height) printf(\u0026#34;-\u0026#34;); else printf(\u0026#34; \u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } return 0; } Question 4\r#\rProblem Description\r#\rYou are given three integers n, x and y. You need to print the first n terms of the sequence S which starts with \\(S_1=x\\)\rand \\(S_2=y\\)\rand further terms are derived from the relation \\(S_i = S_{i-1} \u0026#43; S_{i-2}\\)\r.\nThe first n values of S are guaranteed to fit in int\rLink to problem on OJ\nInput constraints\r#\r\\(\r1 \\le n \u0026lt; 50\r\\)\r\\(\r0\\leq x,y\\leq 1e5\r\\)\r\\(\r\\)\rInput format\r#\rThe only line of input contains 3 space separated integers n, x and y.\nOutput Format\r#\rOutput one line containing n space-seperated integers, denoting the first n terms of the sequence S.\nSample input and output\r#\rSample Input Sample Output 5 1 2 1 2 3 5 8 Solution\r#\r#include \u0026lt;stdio.h\u0026gt; int main(){ int n, x, y; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;n, \u0026amp;x, \u0026amp;y); for (int i = 1; i \u0026lt;= n; i++) { if(i == 1)printf(\u0026#34;%d \u0026#34;, x); else if(i == 2)printf(\u0026#34;%d \u0026#34;, y); else{ int z = x + y; printf(\u0026#34;%d \u0026#34;, z); x = y; y = z; } } return 0; } Question 5\r#\rProblem Description\r#\rKushagra is in love with pairs. He has a list of numbers where each number has a duplicate pair. Unfortunately, there is one number that does not have a pair. Help him figure out which number it is.\nLink to problem on OJ\nInput constraints\r#\r\\(\r3 \\le n \\le 10^{6}\r\\)\r\\(\r1 \\le A_i \\le 10^{9}\r\\)\r\\(\r\\)\rInput format\r#\rThe first line contains an integer n denoting the numbers present in the list.\nThe second line contains n space-separated integers \\([A_0, A_1, A_2,... A_{n-1}]\\)\r.\nOutput Format\r#\rA single integer, the number in the array without a pair\nSample input and output\r#\rSample Input Sample Output 5\n4 5 6 4 5 6 7\n3 3 3 3 3 2 2 3 Solution\r#\r#include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int ans = 0; for(int i = 1; i \u0026lt;= n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); ans ^= x; } printf(\u0026#34;%d\\n\u0026#34;, ans); } "},{"id":17,"href":"/docs/course_material/assignments/assignment2/","title":"Assignment - 2","section":"Assignments","content":"\rAssignment 2\r#\rQuestion 1 - \u0026ldquo;Doubling Investments\u0026rdquo;\r#\rProblem Description\r#\rMitansh is world’s best investor. Whatever the amount he has today, it doubles on the next day.\nInitially he starts, with amount zero. Each day in the morning, he can choose to invest \\(\\$x\\)\rmore in addition to his previous amount \\(\\$y\\)\r. And on next day, his total amount becomes \\(\\$2(x\u0026#43;y)\\)\r.\nHowever, he wants to get exactly \\(\\$z\\)\ron some day.\nWhat is the minimum amount of money he needs to invest, in order to get \\(\\$z\\)\rat some moment?\nLink to problem on OJ\nInput Format\r#\rThe first and only line of input contains a single integer \\(z\\)\rwhich denotes the desired amount.\nInput constraints\r#\r\\(0 \\le z \\le 10^9\\)\rOutput Format\r#\rOn a single line, output the minimum amount of money that needs to be invested, in order to get exactly \\(\\$z\\)\ron some day.\nSample inputs and outputs\r#\rSample Input 1\n7\rSample Output 1\n3\rExplanation: Mitansh will invest \\(\\$1\\)\ron the \\(1^{st}\\)\r, \\(2^{nd}\\)\rand \\(3^{rd}\\)\rdays. At the beginning of the second day he has \\(\\$2\\)\r(thanks to the \\(\\$1\\)\rdoubling). He invests \\(\\$1\\)\ragain, leading to the amount being \\(\\$3 \\times 2 = \\$6\\)\rat the beginning of the third day. He again invests \\(\\$1\\)\rto obtain the desired amount of \\(\\$7\\)\r.\nSample Input 2\n16\rSample Output 2\n1\rExplanation: Mitansh invests \\(\\$1\\)\ron the first day which doubles four times to obtain \\(\\$16\\)\r.\nSample Input 3\n0\rSample Output 3\n0\rSolution\r#\r#include \u0026lt;stdio.h\u0026gt; int main() { int n, count = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while(n != 0) { count += (n % 2); n /= 2; } printf(\u0026#34;%d\\n\u0026#34;, count); return 0; } Question 2 - \u0026ldquo;Rotate Edges\u0026rdquo;\r#\rProblem Description\r#\rKitansh Mayathwal was thinking of an easy problem which he can apply MOSS on. He came up with this problem.\nYou are given a grid with \\(N\\)\rrows and \\(N\\)\rcolumns. An integer \\(A_{i,j}\\)\ris written on the square at the \\(i\\)\r-th row from the top and \\(j\\)\r-th column from the left. Here, it is guaranteed that \\(A_{i,j}\\)\ris either 0 or 1.\nAn integer \\(D\\)\ris also given as input. It is guaranteed that \\(D\\)\ris either 0 or 1.\nIf \\(D = 0\\)\r, shift the integers written on the outer squares anticlockwise by one square each, and print the resulting grid.\nIf \\(D = 1\\)\r. shift the integers written on the outer squares clockwise by one square each, and print the resulting grid.\nHere, the outer squares are those for which at least one of the following conditions is true:\nThe square is present on the first row The square is present on the \\(N\\)\r-th row The square is present on the first column The square is present on the \\(N\\)\r-th column Link to problem on OJ\nInput Format\r#\rThe first line of input contains a single integer \\(N\\)\rthat denotes the size of the grid. The next \\(N\\)\rlines describe the grid.\nThe \\(i^{th}\\)\rline describes the \\(i^{th}\\)\rrow of the grid, \\(A_{i, 1}, A_{i, 2}, \\dots, A_{i, N}\\)\r.\nThe final line of input contains a single integer \\(D\\)\rwhich denotes the direction of rotation.\nIn other words, the input is in the following format\nN\rA_1,1 A_1,2 ... A_1,N\rA_2,1 A_2,2 ... A_2,N\r...\rA_N,1 A_N,2 ... A_N,N\rD\rInput constraints\r#\r\\(2 \\le N \\le 100\\)\r\\(0 \\le A_{i, j} \\le 1 (1 \\le i, j \\le N)\\)\r\\(0 \\le D \\le 1\\)\rOutput Format\r#\rOutput the appropriately rotated grid \\(B\\)\rin the following format:\nB_1,1 B_1,2 ... B_1,N\rB_2,1 ...\r...\rB_N,1 B_N,2 ... B_N,N\rSample inputs and outputs\r#\rSample Input 1\n3\r1 1 1\r0 1 0\r1 0 1\r1\rSample Output 1\n0 1 1\r1 1 1\r0 1 0\rSample Input 2\n3\r1 1 1\r0 1 0\r1 0 1\r0\rSample Output 2\n1 1 0 1 1 1 0 1 0\rSolution\r#\r#include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int a[n][n]; for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; n; j++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); int d; scanf(\u0026#34;%d\u0026#34;, \u0026amp;d); int b[n][n]; if (d) { for (int j = 1; j \u0026lt; n; j++) b[0][j] = a[0][j - 1]; for (int i = 1; i \u0026lt; n; i++) b[i][n - 1] = a[i - 1][n - 1]; for (int j = 0; j \u0026lt; n - 1; j++) b[n - 1][j] = a[n - 1][j + 1]; for (int i = 0; i \u0026lt; n - 1; i++) b[i][0] = a[i + 1][0]; } else { for (int j = 0; j \u0026lt; n - 1; j++) b[0][j] = a[0][j + 1]; for (int i = 0; i \u0026lt; n - 1; i++) b[i][n - 1] = a[i + 1][n - 1]; for (int j = 1; j \u0026lt; n; j++) b[n - 1][j] = a[n - 1][j - 1]; for (int i = 1; i \u0026lt; n; i++) b[i][0] = a[i - 1][0]; } for (int i = 1; i \u0026lt;= n - 2; i++) for (int j = 1; j \u0026lt;= n - 2; j++) b[i][j] = a[i][j]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) printf(\u0026#34;%d \u0026#34;, b[i][j]); printf(\u0026#34;\\n\u0026#34;); } return 0; } Question 3 - \u0026ldquo;Open Doors\u0026rdquo;\r#\rProblem Description\r#\rMadhav is a very lazy boy. He doesn’t like to do sports. So our PEC instructor has assigned him a task which he should complete in an hour. There are \\(n\\)\rdoors which are all closed initially. Madhav should perform \\(n\\)\riterations. In the \\(i^\\text{th}\\)\riteration he starts from \\(i^\\text{th}\\)\rdoor and goes to each multiple of \\(i\\)\runtill \\(n\\)\ri.e. \\((i, 2*i, 3*i…..)\\)\rand toggles the door. Here toggles means if the door is open, he will close it and if it is closed he will open it.\nAfter all \\(n\\)\riterations he has to tell which all doors are still opened. As Madhav is smart, he tries to solve this task using some program. Can you help him with this task ?\nLink to problem on OJ\nInput Format\r#\rYou will be given only one integer \\(n\\)\rwhich are the number of doors.\nInput constraints\r#\r\\(1 \\leq n \\leq 10^{10}\\)\rSubtask 1 : (45 points)\n\\(1 \\leq n \\leq 10^3\\)\rSubtask 2 : (55 points)\nOriginal Constraints\nOutput Format\r#\rPrint the open door numbers in increasing order.\nSample inputs and outputs\r#\rSample Input 1\n1\rSample Output 1\n1\rSample Input 2\n4\rSample Output 2\n1 4\rSolution\r#\r#include\u0026lt;stdio.h\u0026gt; int main() { long long n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); for(int i = 1; 1ll * i * i \u0026lt;= n; i++) printf(\u0026#34;%lld \u0026#34;, i * i); printf(\u0026#34;\\n\u0026#34;); return 0; } Question 4 - \u0026ldquo;Count Palindromes\u0026rdquo;\r#\rProblem Description\r#\rGiven an array \\(A\\)\rof length \\(N\\)\r, count the number of non-empty subarrays which are palindromes.\nNote that two subarrays are considered to be different if they either start at different indices or end at different indices. The actual elements in the two subarrays do not influence this.\nA subarray is a contiguous segment of the array which can be obtained be deleting one or more elements from the beginning or the end of the array.\nAn array is said to be a palindrome if it reads the same backwards and forwards. For example, \\([1, 2, 2, 1], [1], [1, 2, 1]\\)\rare all palindromic arrays.\nLink to problem on OJ\nInput Format\r#\rThe first line of input contains a single integer \\(N\\)\rthat denotes the size of the array.\nThe second line of input contains \\(N\\)\rspace-separated integers \\(A_1, A_2, \\dots, A_N\\)\rthat describe the array.\nInput constraints\r#\r\\(1 \\le N \\le 100\\)\r\\(0 \\le A_i \\le 10^9\\)\rOutput Format\r#\rOutput a single positive that denotes the count of the non-empty palindromic subarrays\nSample inputs and outputs\r#\rSample Input 1\n4\r1 2 2 1\rSample Output 1\n6\rExplanation: The subarrays satisfying the given conditions are: \\([1], [2], [2], [1], [2, 2], [1, 2, 2, 1]\\)\rSolution\r#\r#include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int a[n]; for (int i = 0; i \u0026lt; n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); int ans = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = i; j \u0026lt; n; j++) { int good = 1; int p = i, q = j; while (p \u0026lt; q) { if (a[p] != a[q]) { good = 0; break; } p++, q--; } ans += good; } } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } Question 5 - \u0026ldquo;PEC woes\u0026rdquo;\r#\rProblem Description\r#\rAs you all know, no student in IIIT likes PEC because they make us do some strange things. Once, they assigned a task to Pratham. They spread some rectangles sheets on the football ground and asked Pratham to calculate the total area covered by the rectangular sheets.\nSo, the task is like you are given some rectangles which are parallel to X or Y axis. Specifically, the i-th sheet covers all points \\((x, y)\\)\rthat satisfy \\(a_i≤x≤b_i\\)\rand \\(c_i≤y≤d_i\\)\r. You have to calculate the total area which is covered by the rectangular sheets.\nYou have to calculate the total area which is covered by the recatngular sheets. For more explanation, read the sample test case.\nLink to problem on OJ\nInput Format\r#\rFirst line contains an integer N which denotes the total number of rectangular sheets.\nThe following N lines contain : \\(a_i\\)\r\\(b_i\\)\r\\(c_i\\)\r\\(d_i\\)\rInput constraints\r#\r\\(1 \\leq N \\leq 100\\)\r\\(0 \\leq a_i \u0026lt; b_i \\leq 100\\)\r\\(0 \\leq c_i \u0026lt; d_i \\leq 100\\)\rOutput Format\r#\rOutput a single integer the area covered by rectangular sheets.\nSample inputs and outputs\r#\rSample Input 1\n3\r0 5 1 3\r1 4 0 5\r2 5 2 4\rSample Output 1\n20\rExplanation: For an explanation of the sample input 1, refer to this link. We can count that the sheets cover 20 squares.\nSample Input 2\n3\r0 1 0 1\r0 3 0 5\r5 10 0 10\rSample Output 2\n65\rSolution\r#\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); const int MAX_N = 101; int g[MAX_N][MAX_N]; memset(g, 0, sizeof(g)); while (n--) { int a, b, c, d; scanf(\u0026#34;%d %d %d %d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d); for (int i = c; i \u0026lt; d; i++) for (int j = a; j \u0026lt; b; j++) g[i][j] = 1; } int ans = 0; for (int i = 0; i \u0026lt;= 100; i++) for (int j = 0; j \u0026lt;= 100; j++) ans += g[i][j]; printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } "},{"id":18,"href":"/c_lib_ref/","title":"C Library Reference","section":"Introduction","content":"\rC Library Reference\r#\rFile I/O\nStrings\nDate Time\nRandom Number Generation\nSorting \u0026amp; Searching\nAnother C Library Reference\n"},{"id":19,"href":"/grading_scheme/","title":"Grading Scheme","section":"Introduction","content":"\rGrading Scheme\r#\rAssignments: 30% Quizzes: 20% (2 Quizzes worth 10% each) Mid-Semester Exam: 15% End-Semester Exam: 25% Labs: 10% Bonus*: 5% Note: Total score for a student would be capped at 100% (if the student\u0026rsquo;s score happens to exceed 100)\r"},{"id":20,"href":"/honor_code/","title":"Honor Code","section":"Introduction","content":"\rHonor Code\r#\rAny form of plagiarism in the Assignments or in the Lab Exams would be heavily penalised and would lead to a 0 score for both students, the student who copied and the one whose code was copied. It is solely your duty to ensure the safety of your code throughout the course .Thus, we will not be entertaining any requests after a student is found guilty of plagiarism.\n"},{"id":21,"href":"/docs/course_material/labs/lab1/","title":"Lab - 1","section":"Labs","content":"\rLab 1 (Week of 14 August)\r#\rQuestion 1 - \u0026ldquo;The Last 3\u0026rdquo;\r#\rProblem Description\r#\rGiven an integer n as input, print the last 3 bits of the number in its binary representation starting with the most significant bit among the three.\nNote: The last three bits are the bits corresponding to the,\n\\( 2^2, 2^1 \\)\rand \\( 2^0 \\)\rpositions (in that order)\rLink to problem on OJ\nInput constraints\r#\r\\(\r0 \\le n \\le 2^{31}\r\\)\rInput format\r#\rThe only line of input contains a single integer n\nOutput Format\r#\rOutput three space-separated bits denoting the last three bits of the given number starting with the most significant bit among the three.\nSample input and output\r#\rSample Input Sample Output 11 0 1 1 12 1 0 0 Solution\r#\r#include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;%d %d %d\\n\u0026#34;, !!(n \u0026amp; 1), !!(n \u0026amp; 2), !!(n \u0026amp; 4)); return 0; } Question 2 - \u0026ldquo;Date Formats\u0026rdquo;\r#\rProblem Description\r#\rGiven a date in DD-MM-YY format, output it in MM-DD-YY format.\nLink to problem on OJ\nInput format\r#\rThe only line of input contains a valid date in DD-MM-YY format.\nOutput Format\r#\rOutput the date in MM-DD-YY format with no space separation.\nSample input and output\r#\rSample Input Sample Output 25-03-04 03-25-04 15-08-23 08-15-23 Solution\r#\r#include \u0026lt;stdio.h\u0026gt; int main(void) { int d, m, y; scanf(\u0026#34;%d-%d-%d\u0026#34;, \u0026amp;d, \u0026amp;m, \u0026amp;y); printf(\u0026#34;%02d-%02d-%02d\\n\u0026#34;, m, d, y); return 0; } "},{"id":22,"href":"/docs/course_material/labs/lab2/","title":"Lab - 2","section":"Labs","content":"\rLab 2 (Week of 21 August)\r#\rQuestion 1 - \u0026ldquo;Divisibility By 3\u0026rdquo;\r#\rProblem Description\r#\rGiven an integer which has n digits, print YES if it is divisible by 3, and NO otherwise.\nNote: The input number will not contain any leading zeroes.\rLink to problem on OJ\nInput constraints\r#\r\\(\r0 \\le n \\le 1000\r\\)\rInput format\r#\rThe first line of input contains a single integer n denoting the number of digits.\nThe second line of input contains the integer which is n digit long.\nOutput Format\r#\rOutput YES if the number is divisible by 3 and NO otherwise.\nSample input and output\r#\rSample Input Sample Output 10 1234567890 YES 2 22 NO Solution\r#\r#include \u0026lt;stdio.h\u0026gt; int main(void) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); char c; scanf(\u0026#34;%c\u0026#34;, \u0026amp;c); //Skips the initial new line character int sum = 0; while (n--) { scanf(\u0026#34;%c\u0026#34;, \u0026amp;c); sum += c - \u0026#39;0\u0026#39;; } if (sum % 3) printf(\u0026#34;NO\\n\u0026#34;); else printf(\u0026#34;YES\\n\u0026#34;); return 0; } Question 2 - \u0026ldquo;K-Swap\u0026rdquo;\r#\rProblem Description\r#\rYou are given three non-negative integers x, y and k where \\(\r0 \\le k \\le 31\\)\r. Replace the first k bits (from the right) of x with the first k bits of y and print the new value of x. In other words, replace the k least significant bits of x with the corresponding bits from y.\nLink to problem on OJ\nInput constraints\r#\r\\(\r0 \\le x,y \\le 2^{31}\r\\)\r\\(\r0 \\le k \\le 31\r\\)\rInput format\r#\rThe only line of input contains 3 space-separated integers x, y and k.\nOutput Format\r#\rOutput a single integer denoting the new value of x\nSample input and output\r#\rSample Input Sample Output 11 22 3 14 Solution\r#\r#include \u0026lt;stdio.h\u0026gt; int main() { int x, y, k; scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;k); x \u0026amp;= (~0 \u0026lt;\u0026lt; k); y \u0026amp;= ~(~0 \u0026lt;\u0026lt; k); printf(\u0026#34;%d\\n\u0026#34;, x | y); return 0; } "},{"id":23,"href":"/docs/course_material/labs/lab3/","title":"Lab - 3","section":"Labs","content":"\rLab 3 (Week of 4 September)\r#\rQuestion 1 - \u0026ldquo;Club Recruitments\u0026rdquo;\r#\rProblem Description\r#\rA new student club is organising a huge event this semester for silver jubilee celebrations. Initially, they don\u0026rsquo;t have enough members. So, they started recruiting new members in groups.\nMeanwhile, tasks keep coming up within the club. Each club member can work on only one task during the semester.\nIf there is no member available (isn\u0026rsquo;t occupied with a task) when a task arises, it will remain unattended regardless of whether new individuals are recruited later on.\nGiven the chronological order of task arrivals and club members’ recruitment, find the number of tasks that will remain unattended.\nIn the input, a -1 denotes the arrival of a task (which may or may not go unattended depending on whether or not there are currently any free members to take up the task). Similarly, a non-neagative number denotes the number of new recruits.\nNote that once an individual is recruited for the club, they\u0026rsquo;ll always be part of the club. When an individual takes up a task, they\u0026rsquo;ll be occupied with it for the rest of the semester.\nLink to problem on OJ\nInput constraints\r#\r\\(\r1 \\le N \\le 2 \\times 10^5\r\\)\r\\(\rA_i \\in [-1, 10]\\)\rInput format\r#\rThe first line of input contains a single integer N that denotes the number of events (either task arrival or new recruitment).\nThe second line of input contains N space-separated integers \\(A_1, A_2, \\dots, A_N\\)\rthat describe the N events as explained in the description.\nOutput Format\r#\rOutput a single integer that denotes the number of unattended tasks.\nSample input and output\r#\rSample Input Sample Output 3 -1 -1 -1 2 11 -1 -1 2 -1 -1 -1 -1 -1 -1 -1 -1 8 Solution\r#\r#include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int pref = 0, ans = 0; for (int i = 0; i \u0026lt; n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); pref += x; if (pref \u0026lt; 0) ans++, pref = 0; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } Question 2 - Current Max\r#\rProblem Description\r#\rYou are given a sequence of N integers \\(A_1,A_2,...,A_N \\)\rand while looking at the sequence in order from left to right (that is, from index 1 to N), you start by crossing the first number, and you cross a subsequent number if it is strictly greater than every number you crossed before. You keep crossing until you reach the end of the sequence.\nOutput all the numbers you have crossed.\nLink to problem on OJ\nInput constraints\r#\r\\(\r1 \\le N \\le 2 \\times 10^5\r\\)\r\\(\r0 \\le A_i \\le 10^9\\)\rInput format\r#\rThe first line of input contains a single integer N that denotes the size of the array.\nThe second line of input contains N space-separated integers \\(A_1,A_2,...,A_N \\)\rthat describe the N elements.\nOutput Format\r#\rOn the first line, output the count of numbers that you cross out, K. Note that this is a positive number since the first number is always crossed.\nOn the second line, output K space-separated integers denoting the numbers crossed out in the order in which they appear in the original array.\nSample input and output\r#\rSample Input Sample Output 7\n1 1 3 2 4 10 9 4\n1 3 4 10 Solution\r#\r#include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int final[n]; int sz = 0; for (int i = 0; i \u0026lt; n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); if (!sz || final[sz - 1] \u0026lt; x) final[sz++] = x; } printf(\u0026#34;%d\\n\u0026#34;, sz); for (int i = 0; i \u0026lt; sz; i++) printf(\u0026#34;%d \u0026#34;, final[i]); printf(\u0026#34;\\n\u0026#34;); return 0; } "},{"id":24,"href":"/docs/course_material/quizzes/midLab1/","title":"Mid-Sem Lab Exam","section":"Quizzes","content":"\rMid-Sem Lab Exam\r#\rQuestion 1 - \u0026ldquo;Voting\u0026rdquo;\r#\rProblem Description\r#\rThe Elections for the new academic year are in full swing!\nThere are \\(N\\)\rstudents in the college and two candidates for the current elections (where \\(N\\)\ris guaranteed to be an odd number). The students cast their votes in the form of \\(0s\\)\ror \\(1s\\)\rwhere the \\(i^{th}\\)\rvote (\r\\(1 \u0026lt;= i \u0026lt;= N\\)\r) being \\(1\\)\rrepresents a vote to candidate A and it being \\(0\\)\rrepresents a vote for candidate B.\nA candidate wins the elections if they have the strict majority. That is, if the number of votes cast for them is strictly greater than the number of votes cast for the other candidate.\nOutput Yes if candidate A wins the elections and No otherwise.\nLink to problem on OJ\nInput constraints\r#\r\\( 1 \\le N \\le 99 \\)\r\\( N \\text{ is an odd number} \\)\r\\( V_i = \\{0, 1\\} \\)\rInput format\r#\rThe first line of input contains \\(N\\)\r, the number of students. Then, \\(N\\)\rline follows.\nThe \\(i^{th}\\)\rline contains a single integer \\(V_i = \\{0, 1\\}\\)\rwhere \\(1\\)\rrepresents a vote for candidate A and \\(0\\)\rrepresents a vote for candidate B.\nOutput Format\r#\rOutput Yes if candidate A wins the elections and No otherwise.\nSample input and output\r#\rSample Input Sample Output 3 1 0 1 Yes Explanation: There are \\(2\\)\rvotes for candidate A and \\(1\\)\rvote for candidate B. Therefore, candidate A has the majority and wins the elections.\nSample Input Sample Output 5 0 0 1 0 1 No Explanation: There are \\(2\\)\rvotes for candidate A and \\(3\\)\rvotes for candidate B. Therefore, candidate B has the majority and wins the elections.\nSolution\r#\r#include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int a = 0, b = 0; for (int i = 0; i \u0026lt; n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); if (x) a++; else b++; } if (a \u0026gt; b) printf(\u0026#34;Yes\\n\u0026#34;); else printf(\u0026#34;No\\n\u0026#34;); return 0; } Question 2 - \u0026ldquo;Jump Back\u0026rdquo;\r#\rProblem Description\r#\rThere are \\(N\\)\rtrees in the forest, numbered Tree 1, Tree 2,\u0026hellip;, Tree \\(N\\)\r.\nTree 1, is a special tree which is home to the entire forest. Each tree \\(i\\)\r(\r\\(2 \\le i \\le N\\)\r), has a parent tree \\(T_i\\)\rfrom which it grew. It is guaranteed that \\(T_i \u0026lt; i\\)\r.\nYou are currently on tree \\(N\\)\rand want to reach tree \\(1\\)\r. However, from a given tree, you can only jump to its parent tree (unless you are already on tree \\(1\\)\r, in which case you have already reached the destination).\nFor example, consider the input \\([1 1 2 4]\\)\rwhich means, \\(T_2 = 1, T_3 = 1, T_4 = 2, T_5 = 4\\)\r(note that tree \\(1\\)\rhas no parent tree). Starting from tree \\(5\\)\r, the only option is to jump to tree 4, its parent. Similarly, from tree 4, you jump to tree 2. Finally, from tree 2 you jump to tree 1, taking a total of 3 jumps to go from tree 5 to tree 1.\nFind the number of jumps that you need to make in order to reach tree \\(1\\)\rstarting from tree \\(N\\)\r. It can be shown that you can reach it in a finite number of jumps.\nLink to problem on OJ\nInput constraints\r#\r\\(2 \\le N \\le 50\\)\r\\(1 \\le T_i \u0026lt; i\\)\r(\r\\(2 \\le i \\le N\\)\r) Input format\r#\rThe first line of input contains a single integer \\(N\\)\r, the number of trees.\nThe following line contains \\(N - 1\\)\rspace separated integers, \\(T_2, T_3, \\dots, T_N\\)\rwhere \\(T_i\\)\rdenotes the parent of the \\(i^{th}\\)\rtree.\nOutput Format\r#\rOutput a single integer denoting the number of jumps required to go from tree \\(N\\)\rto tree \\(1\\)\r.\nSample input and output\r#\rSample Input Sample Output 3 1 2 2 Sample Input Sample Output 5 1 1 2 4 3 Solution\r#\r#include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int a[n]; a[0] = -1; for (int i = 1; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); a[i]--; } int curr = n - 1, ans = 0; while (curr != -1) { ans++; curr = a[curr]; } printf(\u0026#34;%d\\n\u0026#34;, ans - 1); return 0; } Question 3 - \u0026ldquo;Max AND\u0026rdquo;\r#\rProblem Description\r#\rIn this problem, we use the symbol ^ to denote the bitwise AND operation, and the symbol v to denote the bitwise OR operation.\nGiven an array of integers \\(A\\)\rof length \\(N\\)\r, \\(A_1, A_2, \\dots, A_N\\)\r. Define a \u0026ldquo;set operation\u0026rdquo; as the following:\nSelect any index \\(i\\)\rwhere \\(1 \\le i \\le N\\)\rand set the \\(j^{th}\\)\rbit of \\(A_i\\)\rwhere \\(j\\)\ris any integer between \\(0\\)\rand \\(30\\)\rinclusive. In other words, replace \\(A_i\\)\rwith \\(A_i\\)\rv \\(2^j\\)\r. You are also given a non-negative integer \\(K\\)\r. You can perform at most \\(K\\)\roperations on the given array. After doing so, output the maximum possible value of \\(A_1\\)\r^ \\(A_2\\)\r^ \\(\\dots\\)\r^ \\(A_N\\)\r.\nLink to problem on OJ\nInput constraints\r#\r\\(1 \\le N \\le 2 \\times 10^5\\)\r\\(0 \\le K \\le 10^9\\)\r\\(0 \\le A_i \u0026lt; 2^{31}\\)\rInput format\r#\rThe first line of input contains two space separated integers \\(N\\)\rand \\(K\\)\r, denoting the length of the array and the maximum number of operations that can be performed respectively.\nThe second line contains \\(N\\)\rspace separated integers \\(A_1, A_2, \\dots, A_N\\)\rthat denote the initial array.\nOutput Format\r#\rOutput the maximum possible value of the bitwise AND of the entire array after performing at most \\(K\\)\roperations.\nSample input and output\r#\rSample Input Sample Output 3 2 2 1 1 2 Explanation: We set the \\(j = 1\\)\rbit (that is, the bit corresponding to \\(2^1\\)\r) for \\(A_2\\)\rand \\(A_3\\)\r. This requires \\(2 \\le K\\)\roperations. After doing so, the array now looks like \\([2, 3, 3]\\)\r, giving us a bitwise AND value of \\(2\\)\rwhich can be shown is the maximum possible value for the given input.\nSample Input Sample Output 7 0 4 6 6 28 6 6 12 4 Explanation: Here, \\(K = 0\\)\r. So, we cannot perform any operations. Hence, the bitwise AND of the initial array, \\(4\\)\ris our final answer.\nSolution\r#\r#include \u0026lt;stdio.h\u0026gt; int main() { int n, k; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;k); int cnt[31] = {0}; for (int i = 0; i \u0026lt; n; i++) { int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); for (int j = 0; j \u0026lt; 31; j++, x /= 2) { cnt[j] += (x \u0026amp; 1); } } int ans = 0; for (int i = 30; i \u0026gt;= 0; i--) { if (k \u0026gt;= n - cnt[i]) { ans |= (1 \u0026lt;\u0026lt; i); k -= (n - cnt[i]); } } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } "},{"id":25,"href":"/docs/course_material/quizzes/quiz1A/","title":"Quiz - 1 Section A","section":"Quizzes","content":"\rQuiz 1\r#\rSection A\rQuestion 1 - 5 marks\r#\rProblem Description\r#\rWrite a program to find the factorial of a number. Here n can be taken to be an input from the user.\nSolution\r#\r#include \u0026lt;stdio.h\u0026gt; int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); if(n\u0026lt;0){ printf(\u0026#34;Invalid Input!\u0026#34;); }else{ int ans=1; for(int i=1;i\u0026lt;=n;i++){ ans*=i; } printf(\u0026#34;%d\\n\u0026#34;,ans); } return 0; } Grading Scheme\r#\r1 mark: For writing\n#include \u0026lt;stdio.h\u0026gt; 1 mark: For writing\nint main(){\rreturn 0\r} 3 marks: For correct logic, this includes correct initialization of ans=1, writing the correct for-loop and correct formula. Marks have been cut for compilation errors(Between 0.5 to 1 marks have been cut)\nNote: For approaches other than the standard for-loop approach, marks have been awarded according to correctness of the approach.\nFor eg, in case of a recursion based approach, marks have been awarded if the base-case is correct and the recursion works properly.\rQuestion 2 - 5 marks\r#\rProblem Description\r#\rWhat is type-casting? Explain the types of type casting in C.\nSolution\r#\rThe idea of type-casting is to convert one data type into another.\nThere are two types of type conversions/castings:\n1) Implicit conversions: The idea here is to convert the data type of one variable without altering the actual value of the variable. The datatype can be both promoted and demoted by compiler. There can be various implicit conversions:\na) Arithmetic conversions: Happens when operands in arithmetic or logical expressions don’t have same type. Example: Addition of integer and float.\nint a = 10; float b = 20.0; float c = a + b; // type of (a+b) is float, so it is stored back in `float c` b) Conversion during assignment: Happens when type of expression on the right side of an assignment operator doesn’t match the type of the variable on the left side. Example: assigning an int to char.\nchar pi1 = 3; int pi2 = \u0026#39;a\u0026#39;; int pi3 = 3.14; // Results in loss of information float pi4 = 3; // 3 is an int, but assigned to float c) Others: In function argument; in return statement.\n2. Explicit type-casting: In this case, the datatype conversion is user-defined according to the program’s needs. It can be a lower or higher end data type. Example:\nfloat pi = (float)21/7; Grading Scheme\r#\rDefinition of typecasting (1 mark).\nDefinition of implicit conversion (1 mark) and its example (1 mark). (Sub-types of implicit conversion are not required.) Definition of explicit typecasting (1 mark) and its example (1 mark). Writing extra details relevant to the topic can also result in extra marks. For example: Writing hierarchical order of promotion in arithmetic conversion. Marks have been deducted for conceptual or syntax errors.\nQuestion 3 - 5 marks\r#\rProblem Description\r#\rWrite -35 in 2’s complement form (assume 8-bit representation).\nSolution \u0026amp; Grading Scheme\r#\rThe number 35 in binary is given by: 00100011 (2 marks)\nIn 2 complement it is given by: 11011101. (3 marks)\nQuestion 4 - 5 marks\r#\rProblem Description\r#\rState True/False with justification: Given two positive integers x and y, it is not possible to calculate the minimum and maximum of the two numbers without using any conditions or loops.\nSolution\r#\rFalse (1 mark).\n#include\u0026lt;stdio.h\u0026gt; int main() { int x,y, min, max; min = y^((x^y)\u0026amp;-(x\u0026lt;y)); max = x^((x^y)\u0026amp;-(x\u0026lt;y)); printf(\u0026#34;min = %d,max = %d\\n\u0026#34;, min,max); return 0; } (4 marks).\nGrading Scheme\r#\r1 mark for writing False or even if have have wrote True but your Explanation points out to be correct marks have been awarded giving benefit of reading the question wrong . Such cases have been marked Lucky and are instructed to not do it from next time.\n1/2 mark if there’s a contradictory statements for the explanation and answer\n3/2 for writing the formula for minimum number expression here the formula using Absolute value concept and other correct equivalent bitwise expressions have also been taken into account.\nAgain, 3/2 for writing the correct way to find out the maximum value . Note:- Using the terms like maximum can be found out logically, naturally etc. from minimum have been given 0 marks for the same\r1 mark for writing the above expressions with the whole of code structure.\nQuestion 5 - 10 marks\r#\rProblem Description\r#\rWrite a program to print the following pattern of the Pascal’s triangle.\n1\r1 1\r1 2 1\r1 3 3 1 Solution\r#\r#include\u0026lt;stdio.h\u0026gt; int main() { int rows=4, num= 1, space, i, j; for(i=0; i \u0026lt; rows; i++) { for(space=1; space \u0026lt;= rows-i; space++) printf(\u0026#34; \u0026#34;); for(j=0; j \u0026lt;= i; j++) { if (j==0 || i==0) num= 1; else num = num*(i-j+1)/j; printf(\u0026#34; %d\u0026#34;, num); } printf(\u0026#34;\\n\\n\u0026#34;); } return 0; } Grading Scheme\r#\rHeader files: (1 mark - awarded if the syntax is strictly correct) Initialising variables using the right syntax: (1 mark - awarded if the syntax is strictly correct) Using the variables that were declared correctly: (1 mark - awarded with some leniency depending on the mistake) Using printf correctly for printing spaces: 2 marks are awarded if spaces are printed properly with correct generalised logic. 1 mark is awarded if just the syntax is correct. Using for or while loop: 2 marks are awarded if numbers are printed properly with correct generalised logic. 1 mark is awarded if just the syntax is correct Correct logic for generalised output - 2 marks Correct final output (brute or general) - 1 mark Question 6 - 20 marks\r#\rProblem Description\r#\rWhat is output of the following programs with proper justification ?\ni) 5 marks\r#\r#include\u0026lt;stdio.h\u0026gt; int main() { int x = 5, y, z; y = x++; z = x--; printf(\u0026#34;%d %d %d\\n\u0026#34;, x, y, z); return 0; } Solution \u0026amp; Grading Scheme\r#\rOutput: 5 5 6\nJustification:\ny = x++; // y = 5, x = 6\rz = x--; // z = 6, x = 5 x = 5 (post-increment operator) (2 marks) y = 5 (post-increment operator) (2 marks) z = 6 (post-decrement operator) (1 mark) ii) 5 marks\r#\r#include\u0026lt;stdio.h\u0026gt; int main() { int a = 3; a = (a++) + ~ (++a); printf(\u0026#34;%d\u0026#34;, a); return 0; } Solution \u0026amp; Grading Scheme\r#\rOutput: -3 (2 marks)\nJustification:\na = 3;\ra = (a++) + ~ (++a)\ra = 3 + ~(5) [1 marks for post-increment, 1 marks for pre-increment]\na = 3 + (-6) [1 marks for writing ~(5) = -6]\na = -3\niii) 5 marks\r#\r#include\u0026lt;stdio.h\u0026gt; int main() { int i = 21 \u0026gt; 5 \u0026gt; 3 \u0026lt; 4; printf(\u0026#34;%d\u0026#34;, i); return 0; } Solution \u0026amp; Grading Scheme\r#\rOutput: 1 (2 marks, only 1 mark if justification is incorrect)\nJustification: The expression gets evaluated from left to right\nint i = (((21 \u0026gt; 5) \u0026gt; 3) \u0026gt; 4) 21 \u0026gt; 5 is true, so it gets evaluated to 1. (1 mark)\n1 \u0026gt; 3 is false, so it gets evaluated to 0. (1 mark)\n0 \u0026lt; 4 is true, so it gets evaluated to 1. (1 mark)\niv) 5 marks\r#\r#include\u0026lt;stdio.h\u0026gt; int main() { int y; printf(\u0026#34;%d\u0026#34;, scanf(\u0026#34;%d\u0026#34;, \u0026amp;y)); /* Suppose that input value given for above scanf is 2023*/ return 0; } Solution \u0026amp; Grading Scheme\r#\rOutput: 1\nJustification: Scanf returns the number of objects that are input, in this case the number of object is 1 (an integer y) so Scanf will return 1 and it will be printed.\n2 marks for output and 3 marks for justification\n"},{"id":26,"href":"/docs/course_material/quizzes/quiz1B/","title":"Quiz - 1 Section B","section":"Quizzes","content":"\rQuiz 1\r#\rSection B\rQuestion 1 - 5 marks\r#\rProblem Description\r#\rWrite a program to find the sum of first n even numbers. Here n can be taken to be an input from the user.\nSolution\r#\rBoth Codes are considered to be valid.\n#include\u0026lt;stdio.h\u0026gt; int main() { int i, ans = 0,n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(i=0; i \u0026lt; n; i ++) { ans = ans + 2*i; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } #include\u0026lt;stdio.h\u0026gt; int main() { int i, ans = 0,n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int ans = n*(n-1); // n*(n+1) is also given as correct ans. printf(\u0026#34;%d\\n\u0026#34;,ans); return 0; } Grading Scheme\r#\r1 mark: For writing\n#include \u0026lt;stdio.h\u0026gt; 1 mark: For writing\nint main(){\rreturn 0\r} 3 marks: For correctness of the code\nQuestion 2 - 5 marks\r#\rProblem Description\r#\rExplain the control flow between the RAM, Hard disk and the CPU after a program is written.\nSolution \u0026amp; Grading Scheme\r#\rThere are a few different interpretations to the question. The question expects you to explain what happens when a program is run.\nThe OS-kernel loads the program from the Hard disk into the RAM. (1 mark) It is then transmitted to the CPU through the memory bus. (1 mark) The CPU performs the following cycle: (2 marks)\nFetch Decode Execute After this the output is written back to the RAM through the memory bus. (1 mark) Other interpretations include:\nWhat happens when the program is written in the editor and saved? What happens when the program is compiled? Marks have been given to these interpretations if points similar to what we were looking for in the intended solution are given but according to the different interpretations.\nQuestion 3 - 5 marks\r#\rProblem Description\r#\rWrite -15 in 1’s complement form (assume 8-bit representation)\nSolution \u0026amp; Grading Scheme\r#\rThe number 15 in binary is given by: 00001111 (2 marks)\nIn 1\u0026rsquo;s complement it is given by: 11110000. (3 marks)\nQuestion 4 - 5 marks\r#\rProblem Description\r#\rState True/False with justification: Given two numbers x and y, the expression y ^ ((x ^ y)\u0026amp; − (x \u0026lt; y)) calculates the minimum of the two numbers.\nSolution\r#\rTrue, This expression does calculate the minimum of the two numbers (1 Mark)\nJustification:\nIf x \u0026lt; y (2 Marks) (x \u0026lt; y) = 1\r-(x\u0026lt;y) = -1\r-(x\u0026lt;y) = (1111...1) (Due to one’s compliment representation of negative numbers in binary)\r(x ^ y) \u0026amp; (1111...1)_2 = (x ^ y) (As 1 is the identity for AND operation)\ry^(( x ^ y) \u0026amp; - (x \u0026lt; y) = y ^ (x ^ y) = x\ry ^ (x ^ y) = y ^ x ^ y ( ^ (Bitwise xor) is associative )\ry ^ x ^ y = x ^ y ^ y ( ^ (Bitwise xor) is commutative )\rx ^ y ^ y = x ^ 0 ( inverse of a number for bitwise xor is the number itself )\rx ^ 0 = x (0 is the identity for XOR operation)\rHence if x \u0026lt; y, y ^ ((x ^ y) \u0026amp; -(x \u0026lt; y)) = x\rIf x \u0026gt;= y (2 Marks)\r(x \u0026lt; y) = 0\r-(x\u0026lt;y) = 0\r(x ^ y) \u0026amp; 0 = 0 (As any number AND 0 is 0)\ry ^ (( x ^ y) \u0026amp; - (x \u0026lt; y) = y ^ 0\ry ^ (( x ^ y) \u0026amp; - (x \u0026lt; y) = y (0 is the identity for XOR operation) Hence if x \u0026gt;= y, y ^ ((x ^ y) \u0026amp; -(x \u0026lt; y)) = y Therefore, this expression calculates the minimum of the two numbers\nGrading Scheme\r#\r0 marks awarded for wrong option (False) with any justification 1 mark awarded for correct option (True) without correct justification. 1.5 marks awarded for correct option (True) and justifying it by correctly evaluating it for an example, incorrect evaluation of an example have been given 1. 3 marks awarded for correct option (True) and when only one case’s justification is correct. 5 marks awarded for correct option (True) and correct justification by proving for both the cases. Question 5 - 10 marks\r#\rProblem Description\r#\rWrite a program to print the following pattern.\n1\r2 3\r4 5 6\r7 8 9 10 Solution\r#\r#include\u0026lt;stdio.h\u0026gt; int main() { int rows = 4, num = 1, space, i, j; for(i = 1; i \u0026lt;= rows; i++){ for(space = 1; space \u0026lt;= rows - i; space++) printf(\u0026#34; \u0026#34;); for(j = i*(i-1)/2; j \u0026lt; i*(i+1)/2; j++){ num = j + 1; printf(\u0026#34;%d \u0026#34;, num); } printf(\u0026#34;\\n\u0026#34;); } } Grading Scheme\r#\rHeader files: (1 mark - awarded if the syntax is strictly correct) Initialising variables using the right syntax: (1 mark - awarded if the syntax is strictly correct) Using the variables that were declared correctly: (1 mark - awarded with some leniency depending on the mistake) Using printf correctly for printing spaces: 2 marks are awarded if spaces are printed properly with correct generalised logic. 1 mark is awarded if just the syntax is correct. Using for or while loop: 2 marks are awarded if numbers are printed properly with correct generalised logic. 1 mark is awarded if just the syntax is correct Correct logic for generalised output - 2 marks Correct final output (brute or general) - 1 mark Question 6 - 20 marks\r#\rProblem Description\r#\rWhat is output of the following programs with proper justification ?\ni) 5 marks\r#\r#include\u0026lt;stdio.h\u0026gt; int main() { int x = 7, y, z; y = --x; z = x++; printf(\u0026#34;%d %d %d\\n\u0026#34;, x, y, z); return 0; } Solution \u0026amp; Grading Scheme\r#\rOutput: 7 6 6\nJustification:\ny = --x; // y = 6, x = 6\rz = x++; // z = 6, x = 7 x = 7 (post-increment operator) (2 marks) y = 6 (pre-decrement operator) (2 marks) z = 6 (post-increment operator) (1 mark) ii) 5 marks\r#\r#include\u0026lt;stdio.h\u0026gt; int main() { int i; for(i = 9 ; i != 0 ; i--) printf(\u0026#34;%d\\n\u0026#34;, i--); return 0; } Solution \u0026amp; Grading Scheme\r#\rOutput: Infinite loop of odd numbers starting from 9, 7, 5, .... (2 marks) i-- happens twice: once in the printf statement and once in the for loop. The condition i != 0 is never reached. So there is infinite loop. (3 marks)\niii) 5 marks\r#\r#include\u0026lt;stdio.h\u0026gt; int main() { int x = 4, y = 4, z = 4; if (x == y == z) { printf(\u0026#34;YES\u0026#34;); } else { printf(\u0026#34;NO\u0026#34;); } return 0; } Solution \u0026amp; Grading Scheme\r#\rOutput: NO (2 marks, only 1 mark if justification is incorrect)\nExpression gets evaluated from left to right ((x==y)==z)\nx == y is true, so it gets evaluated to 1. (1 mark)\n1 == z is false, so it gets evaluated to 0. (1 mark)\nTherefore “NO” is printed. (1 mark)\niv) 5 marks\r#\r#include\u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;%d\u0026#34;, printf(\u0026#34;Hello World\u0026#34;)); return 0; } Solution \u0026amp; Grading Scheme\r#\rOutput: Hello World11\nJustification: printf outputs the text Hello World. Printf with %d returns the number of characters in the word (11). Therefore, the output is Hello World11\n2 marks for output and 3 marks for justification\n"},{"id":27,"href":"/docs/course_material/quizzes/quiz2/","title":"Quiz - 2","section":"Quizzes","content":"\rQuiz 2\r#\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; typedef enum RelStatus { NotMentioned, Single, Engaged, Married } RelStatus; typedef struct Node Node; typedef Node* LinkedList; typedef struct Person { char name[100]; int age; RelStatus relstatus; LinkedList friends; } Person; struct Node { struct Person* data; struct Node* next; }; typedef struct SocialNet { LinkedList members; } SocialNet; LinkedList append(Person* p, LinkedList l) { if (l == NULL) { Node* D = (Node *) malloc(sizeof(Node)); D-\u0026gt;data = p; D-\u0026gt;next = NULL; return D; } else { l-\u0026gt;next = append(p, l-\u0026gt;next); } return l; } void print_person(Person* p) { char status_string[][15] = { \u0026#34;Not Mentioned\u0026#34;,\u0026#34;Single\u0026#34;, \u0026#34;Married\u0026#34;, \u0026#34;Engaged\u0026#34; }; printf(\u0026#34;%s\\t\\t%d\\t%s\\t\\t\\t\u0026#34;, p-\u0026gt;name, p-\u0026gt;age, status_string[p-\u0026gt;relstatus]); LinkedList f = p-\u0026gt;friends; while (f != NULL) { printf(\u0026#34;%s, \u0026#34;, f-\u0026gt;data-\u0026gt;name); f = f-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); } void print_network(LinkedList m) { printf( \u0026#34;------------------------------------------------------\\n\u0026#34; \u0026#34;Name\\t\\tAge\\tStatus\\t\\t\\tFriends\\n\u0026#34; \u0026#34;------------------------------------------------------\\n\u0026#34;); while (m != NULL) { print_person(m-\u0026gt;data); m = m-\u0026gt;next; } printf(\u0026#34;------------------------------------------------------\\n\u0026#34;); } Person* find_person(char* name, LinkedList l) { // Either find the person with a particular name // if not found return NULL while(l!= NULL) { if (strcmp(l-\u0026gt;data-\u0026gt;name, name) == 0) { return l-\u0026gt;data; } l = l-\u0026gt;next; } return NULL; } int size(LinkedList l) { return l == NULL? 0: 1+size(l-\u0026gt;next); } char* person_with_most_friends(LinkedList l) { // Q A1: Return the name of the person with most friends // (3 marks) int d = 0; Node* n = NULL; while(l != NULL) { int e = size(l-\u0026gt;data-\u0026gt;friends); if (e \u0026gt; d) { d = e; n = l; } l = l-\u0026gt;next; } return n==NULL? \u0026#34;\u0026#34; : n-\u0026gt;data-\u0026gt;name; } int popularity(char* name, LinkedList l) { // Q B1: Return the number of people who has the person // named `name` amoung their friends. (3 marks) int count = 0; while ( l!= NULL) { if (find_person(name, l-\u0026gt;data-\u0026gt;friends) != NULL) { count++; } } return count; } LinkedList delete_by_name(char* name, LinkedList l) { // Q A2: Delete the person named `name` from l (3 marks) if (l == NULL) { return NULL; } else if (strcmp(name, l-\u0026gt;data-\u0026gt;name) == 0) { Node* tail = l-\u0026gt;next; free(l); return tail; } else { l-\u0026gt;next = delete_by_name(name, l-\u0026gt;next); return l;z } } LinkedList filterby_age(LinkedList l, int lower, int upper) { // Q B2: Return the link list of people in l with age // between lower and upper (3 marks) LinkedList l2 = NULL; while(l != NULL) { if (l-\u0026gt;data-\u0026gt;age \u0026gt;= lower \u0026amp;\u0026amp; l-\u0026gt;data-\u0026gt;age \u0026lt;= upper) { l2 = append(l-\u0026gt;data, l2); } l = l-\u0026gt;next; } return l2; } bool friends_triangle(LinkedList members) { // Q A3: Check if there is a triangle of friends // ie there exists X, Y, Z such that // Y is a friend of X, Z is a friend of Y, X is a friend of Z // ALso print all such triplets (4 marks) LinkedList f = members; printf( \u0026#34;-----------------------------\\n\u0026#34; \u0026#34;Friend Triangles\\n\u0026#34; \u0026#34;-----------------------------\\n\u0026#34;); bool found = false; while(f != NULL) { LinkedList s = f-\u0026gt;data-\u0026gt;friends; while (s != NULL) { LinkedList t = s-\u0026gt;data-\u0026gt;friends; while (t != NULL) { LinkedList l = t-\u0026gt;data-\u0026gt;friends; while (l != NULL) { if (strcmp(l-\u0026gt;data-\u0026gt;name, f-\u0026gt;data-\u0026gt;name)==0) { printf(\u0026#34;%s-\u0026gt;%s-\u0026gt;%s-\u0026gt;%s\\n\u0026#34;, f-\u0026gt;data-\u0026gt;name, s-\u0026gt;data-\u0026gt;name, t-\u0026gt;data-\u0026gt;name, f-\u0026gt;data-\u0026gt;name); found = true; } l = l-\u0026gt;next; } t = t-\u0026gt;next; } s = s-\u0026gt;next; } f = f-\u0026gt;next; } printf(\u0026#34;-------------------------\\n\u0026#34;); return found; } bool transitive_friendship(LinkedList members) { // Q B3: check if the friendship relation is transitive // ie for any X,Y, Z, if Y is a friend of X and // Z is a friend of Y then Z is a friend of X // Also print all the links that violates transitivity // (4 marks) LinkedList f = members; printf( \u0026#34;-----------------------------\\n\u0026#34; \u0026#34;Links that are not Transitive\\n\u0026#34; \u0026#34;-----------------------------\\n\u0026#34;); bool found = false; while(f != NULL) { LinkedList s = f-\u0026gt;data-\u0026gt;friends; while (s != NULL) { LinkedList t = s-\u0026gt;data-\u0026gt;friends; while (t != NULL) { if (find_person(t-\u0026gt;data-\u0026gt;name, f-\u0026gt;data-\u0026gt;friends) == NULL) { printf(\u0026#34;%s-\u0026gt;%s-\u0026gt;%s, but there is no %s-\u0026gt;%s\\n\u0026#34;, f-\u0026gt;data-\u0026gt;name, s-\u0026gt;data-\u0026gt;name, t-\u0026gt;data-\u0026gt;name, f-\u0026gt;data-\u0026gt;name,t-\u0026gt;data-\u0026gt;name); found = true; } t = t-\u0026gt;next; } s = s-\u0026gt;next; } f = f-\u0026gt;next; } printf(\u0026#34;-------------------------\\n\u0026#34;); return !found; } int main() { SocialNet s = { NULL }; Person A = {\u0026#34;Alice\u0026#34;, 23, Single, NULL}; Person B ={\u0026#34;Bob\u0026#34;, 26, Engaged, NULL}; Person C = {\u0026#34;Charlie\u0026#34;, 21, NotMentioned, NULL}; Person D ={\u0026#34;Don\u0026#34;, 28, Married, NULL}; s.members = append(\u0026amp;A, s.members); s.members = append(\u0026amp;B, s.members); s.members = append(\u0026amp;C, s.members); s.members = append(\u0026amp;D, s.members); A.friends = append(\u0026amp;B, A.friends); A.friends = append(\u0026amp;C, A.friends); B.friends = append(\u0026amp;D, B.friends); C.friends = append(\u0026amp;D, C.friends); D.friends = append(\u0026amp;A, D.friends); printf(\u0026#34;List of people between ages 24 to 28:\\n\u0026#34;); print_network(filterby_age(s.members, 24, 28)); printf(\u0026#34;The person with most friends is %s.\\n\u0026#34;,person_with_most_friends(s.members)); // For above social network, `friends_triangle(s.members)` // returns `true` and prints // ----------------------------- // Friend Triangles // ----------------------------- // Alice-\u0026gt;Bob-\u0026gt;Don-\u0026gt;Alice // Alice-\u0026gt;Charlie-\u0026gt;Don-\u0026gt;Alice // Bob-\u0026gt;Don-\u0026gt;Alice-\u0026gt;Bob // Charlie-\u0026gt;Don-\u0026gt;Alice-\u0026gt;Charlie // Don-\u0026gt;Alice-\u0026gt;Bob-\u0026gt;Don // Don-\u0026gt;Alice-\u0026gt;Charlie-\u0026gt;Don // ------------------------- friends_triangle(s.members); // For the above social network, `transitive_friendship(s.members)` // returns false and prints // ----------------------------- // Links that are not Transitive // ----------------------------- // Alice-\u0026gt;Bob-\u0026gt;Don, but there is no Alice-\u0026gt;Don // Alice-\u0026gt;Charlie-\u0026gt;Don, but there is no Alice-\u0026gt;Don // Bob-\u0026gt;Don-\u0026gt;Alice, but there is no Bob-\u0026gt;Alice // Charlie-\u0026gt;Don-\u0026gt;Alice, but there is no Charlie-\u0026gt;Alice // Don-\u0026gt;Alice-\u0026gt;Bob, but there is no Don-\u0026gt;Bob // Don-\u0026gt;Alice-\u0026gt;Charlie, but there is no Don-\u0026gt;Charlie // ------------------------- transitive_friendship(s.members); return 0; } "},{"id":28,"href":"/references/","title":"References","section":"Introduction","content":"\rReferences from the web\r#\rDive into C Textbook\nC Programing Textbook\nC Programming Wikibook\nVariables, functions, arrays, strings\nC Structs and Pointers\nThe C Book by Banahan, Brady, Doran\nPractical Programming in C (MIT OCW)\nObject-Oriented Programming With ANSI-C\nC and Unix Documentation from the Stanford CS Education Library\nC Primer from Brown: Part 1 Part 2 Part 3: Debugging\nA C programming course by Steve Summit, online course material\nProgramming in C by A.D. Marshall, notes and examples\nRecursive and Loopy GCD in C\nSieve of Eratosthenes in C\n"},{"id":29,"href":"/tas/","title":"Teaching Assistants","section":"Introduction","content":"\rTeaching Assistants\r#\rPramod Rao | pramod.b@research.iiit.ac.in Shreeya Singh | shreeya.singh@students.iiit.ac.in Aditya Malhotra | aditya.malhotra@students.iiit.ac.in Anushka Agrawal | anushka.agrawal@students.iiit.ac.in Ayan Datta | ayan.datta@research.iiit.ac.in Bhargav Srinivas | bhargav.srinivas@students.iiit.ac.in Dheeraja Rajreddygari | dheeraja.rajreddygari@students.iiit.ac.in Harshvardhan | harshvardhan.sv@research.iiit.ac.in Keval Jain | keval.jain@research.iiit.ac.in Kriti Gupta | kriti.gupta@research.iiit.ac.in Kushagra Kharbanda | kushagra.kharbanda@students.iiit.ac.in Kyrylo Shyvam Kumar | kyrylo.shyvam@students.iiit.ac.in Manav Shah | shah.devendrakumar@students.iiit.ac.in Mihika Sanghi | mihika.sanghi@research.iiit.ac.in Mitansh Kayathwal | mitansh.kayathwal@students.iiit.ac.in Sriteja Pashya | sriteja.pashya@research.iiit.ac.in Ujjwal Shekhar | ujjwal.shekhar@research.iiit.ac.in "},{"id":30,"href":"/docs/course_material/template/","title":"Template","section":"Course Material","content":"\rCourse material template\r#\rQuestion 1\r#\rThe question body would go here\nText\r#\rLinked list can be defined as either a node structure doing nothing or one that is pointing to another linked list\nLinks\r#\rSee linked: Recursion\nButton\r#\rGet Home\rContribute\rColumns\r#\rLeft Content Lorem markdownum insigne\u0026hellip;\rMid Content Lorem markdownum insigne\u0026hellip;\rRight Content Lorem markdownum insigne\u0026hellip;\rExpand\r#\rExpand\r↕\rMarkdown content\r#\rLorem markdownum insigne\u0026hellip;\rHint\r#\rWarning: Make sure to always free up memory!\rKaTeX\r#\r\\(\rf(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\r\\)\rTabs\r#\rMacOS\rMacOS Content\r#\rLinux\rLinux Content\r#\rWindows\rWindows Content\r#\rCode\r#\rtypedef struct node { struct node* nxt; // will point to the next node in the linked list if any int val; // store whatever else you might need } Node; int main() { // Code here } "},{"id":31,"href":"/docs/course_material/tutorials/week1/","title":"Tutorial - 1","section":"Tutorials","content":"\rTutorial 1 (Week of 14 August)\r#\rTheory\r#\rIntroduction to how compilation works in C\r#\rWe all know that computer is incapable of reading and understanding the code we write in its native form. This means that the code needs to be converted in a form which the machine can understand. The machine only understands Binary code. Thus, there should be a process by which the code we write can be converted to Binary form. This process is known as compilation. You can think of compilation to be similar to translation (For eg: Let’s say you know English but you are with someone who only understands French. This situation would require a translator! This is exactly what a compiler does. It acts as a translator!).\nThere are various stages in which the code is converted from C-language into binary for the computer to understand it:\nPreprocessing: All headers files starting with “#include” are processed in this phase. (Several other forms of processing including the removal of comments also happen at this stage). This generates a .i file Compiling: For now, assume it to be an intermediate process of conversion from .i to .s file. The .s file (known as an assembly file) is a set of commands which our machine knows to execute. Assembly: Code is converted into machine-understandable code by the assembler. The file output is a .o or .obj file. Linking: links library files(eg: stdio.h, math.h etc) to the object file to produce the a.out file, which is a binary executable of the program that was supplied as input. Finally, we execute the a.out file to get the desired output.\nNote: At this stage of the course, it is fine if the process is not entirely clear. It would become more clear in future courses (CSO for CXX students for example). The previous section just acts as a glimpse into compilation as a process being a series of smaller sub-processes.\rReturn values of scanf and printf function\r#\rscanf() and printf() are both part of the standard I/O library in C. They are used for taking input from the user, printing output etc. It\u0026rsquo;s important to notice that these functions have a certain return value.\nscanf() function returns the number of inputs that have been read.\nExample:\nint a; int rval = scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); printf(\u0026#34;%d\u0026#34;, rval); The above snippet of code would print 1 as its output. This is because it\u0026rsquo;s reading only 1 argument. If the number of arguments increases, then the return value would change similarly.\nSimilarly, printf() function returns the number of characters written.\nint rval = printf(\u0026#34;Hello world!\u0026#34;); printf(\u0026#34;%d\u0026#34;, rval); The above snippet would print 12 as its output.\n"},{"id":32,"href":"/docs/course_material/practice_problems/week1/","title":"Week - 1","section":"Practice Problems","content":"\rPractice problems for week - 1 (Week of 14 August)\r#\rNone of the following problems require a knowledge of loops, conditional statements etc.\nQuestion 1\r#\rProblem Description\r#\rKeval has forgotten the password to his I-Pad. The password is a 4-digit number where each digit takes a value from 0 to 9. The good thing is that Keval remembers that his password had exactly two unique digits, and each of these digits appeared exactly twice in the password. Keval also remembers that n digits (where, \\( 0 \\le n \\le 10 \\)\r) from 0-9 were definitely not used in the password.\nFind the number of different possible passwords Keval could have.\nNote that the password can start with the digit 0\rInput constraints\r#\r\\(\r0 \\le n \\le 10\r\\)\rInput format\r#\rThe only line of input contains a single integer n, the number of digits which were not used in the password\nOutput Format\r#\rOutput a single integer that denotes the number of possible password sequences.\nSample input and output\r#\rSample Input Sample Output 1 216 Solution\r#\r#include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int ans = ((10-n)*(10-n-1))/2 * 6; // (10-n)C2 * 4C2 printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } Question 2\r#\rProblem Description\r#\rYou are given two integers x and y. Output the minimum integer z, such that x | z = y. Here, \u0026ldquo;|\u0026rdquo; denotes the bitwise-OR operator\nInput constraints\r#\r\\(\r1 \\le x, y \\le 10^9\r\\)\rInput format\r#\rThe only line of input contains two space-separated integers x and y\nOutput Format\r#\rOutput a single integer that denotes z as described in the problem statement\nSample input and output\r#\rSample Input Sample Output 1 3 2 Solution\r#\r#include \u0026lt;stdio.h\u0026gt; int main() { int x, y; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;x, \u0026amp;y); int z = x ^ y; printf(\u0026#34;%d\u0026#34;, z); return 0; } Question 3\r#\rProblem Description\r#\rReverse a 4-digit number using the modulo operator.\nInput constraints\r#\rThe input would be a valid 4-digit number (i.e. no leading zeroes would be present)\nInput format\r#\rThe only line of input contains a single integer n\nOutput Format\r#\rOutput a single integer which denotes the reverse of the n. Note that the output may have leading zeroes.\nSample input and output\r#\rSample Input Sample Output 3214 4123 5600 0065 Solution\r#\r#include \u0026lt;stdio.h\u0026gt; int main() { int n, reversed = 0; // Input a 4-digit number printf(\u0026#34;Enter a 4-digit number: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); // Reverse the number using modulo operator reversed = (n % 10) * 1000 + ((n / 10) % 10) * 100 + ((n / 100) % 10) * 10 + (n / 1000); // Output the reversed number printf(\u0026#34;Reversed number: %d\\n\u0026#34;, reversed); return 0; } Question 4\r#\rProblem Description\r#\rGiven a time as input in hh:mm:ss format, print the total number of minutes which have passed in the day.\nInput format\r#\rThe only line of input would contain the time in hh:mm:ss format (24-hour clock)\nOutput Format\r#\rOutput the total number of minutes that have passed. Note that this may not be an integer.\nSample input and output\r#\rSample Input Sample Output 13:40:30 820.5 Solution\r#\r#include \u0026lt;stdio.h\u0026gt; int main() { // Declare three variables that will be used to store the hours, minutes, // and seconds, respectively int h, m, s; // Take input in the specified format scanf(\u0026#34;%d:%d:%d\u0026#34;, \u0026amp;h, \u0026amp;m, \u0026amp;s); /** * Calculate the total minutes * Total minutes = hours * 60 + minutes + seconds / 60 * However, to ensure that float division is done, we typecast the seconds * to float */ float minutes = 60 * h + m + (float)s / 60; // Output the total minutes as a floating point number printf(\u0026#34;%f\u0026#34;, minutes); } Question 5\r#\rProblem Description\r#\rKishore is a very strange boy. He keeps solving weird problems and is now stuck on one such question. Please help him solve it.\nGiven an integer n, you need to find the number of ordered pairs of integers (a, b) such that, \\( 1 \\le a \\le b \\le n \\)\rand\n\\(\r\\frac{lcm(a, b)}{gcd(a, b)} \\le 3\r\\)\rIn this problem, gcd(a, b) denotes the greatest common divisor of the numbers a and b, and lcm(a, b) denotes their lowest common multiple.\nInput constraints\r#\r\\(\r1 \\le n \\le 10^8\r\\)\rInput format\r#\rThe only line of input contains a single integer n\nOutput Format\r#\rOutput a single integer that denotes the number of pairs (a, b) that satisfy the given constraints\nSample input and output\r#\rSample Input Sample Output 5 11 Solution\r#\r#include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int ans = n + 2 * ((n / 2) + (n / 3)); printf(\u0026#34;%d\u0026#34;, n); return 0; } "},{"id":33,"href":"/docs/course_material/practice_problems/week2/","title":"Week - 2","section":"Practice Problems","content":"\rPractice problems for week - 2 (Week of 21 August)\r#\rQuestion 1\r#\rProblem Description\r#\rYou are given a 3 x 3 grid filled with integers 1 to 9, in the following way:\n1 2 3 4 5 6 7 8 9 You will be given two natural numbers A and B, both between 1 and 9. Your task is to find out if the two small squares with A and B written on them are horizontally adjacent.\nInput constraints\r#\rA and B are natural numbers and \\(\r1 \\le A,B \\le 9\r\\)\r\\(\rA \\le B\r\\)\rInput format\r#\rThe only line of input contains two space-separated natural numbers A and B\nOutput Format\r#\rPrint YES if the two squares are horizontally adjacent, and NO otherwise.\nSample input and output\r#\rSample Input Sample Output 5 6 YES 6 7 NO Solution\r#\r#include \u0026lt;stdio.h\u0026gt; int main() { int A, B; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;A, \u0026amp;B); if ((A - 1) % 3 == (B - 1) % 3) printf(\u0026#34;YES\\n\u0026#34;); else printf(\u0026#34;NO\\n\u0026#34;); return 0; } Question 2\r#\rProblem Description\r#\rShiven was given a problem to solve as assignment. In the problem, he was given two numbers n and s. He was asked to create a sequence of n non-negative integers such that the median of the sequence is as large as possible and that sum of all numbers of the sequence is s. Can you help Shiven find the maximum possible median of such a sequence?\nNote: The definition of the median is the \\( \\left\\lceil \\frac{n}{2}\\right\\rceil^{th} \\)\relement of a sequence noted in the ascending order\nInput constraints\r#\r\\(\r1 \\le n \\le 10^{8}\r\\)\rInput format\r#\rThe only line of input contains two space-separated integers n and s\nOutput Format\r#\rOutput a single integer that is the maximum median of such a sequence.\nSample input and output\r#\rSample Input Sample Output 7 17 4 Solution\r#\r#include \u0026lt;stdio.h\u0026gt; int main() { int n, s; printf(\u0026#34;Enter two numbers: \u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;s); int m = n / 2 + 1; int ans = s / m; printf(\u0026#34;The maximum value of median is: %d\\n\u0026#34;, ans); return 0; } "},{"id":34,"href":"/docs/course_material/practice_problems/week4/","title":"Week - 4","section":"Practice Problems","content":"\rPractice problems for week 4\r#\rQuestion 1 - \u0026ldquo;Divisibility by 11\u0026rdquo;\r#\rProblem Description\r#\rGiven an integer which has \\(n\\)\rdigits, print YES if it is divisible by \\(11\\)\rand NO otherwise.\nNote that the input number may contain leading zeroes.\nNote that a number is divisible by \\(11\\)\rif and only if the difference of the sum of digits at odd positions and sum of digits at even positions in a number is divisible by 11.\nLink to problem on OJ\nInput Format\r#\rThe first line of input contains a single integer \\(n\\)\rdenoting the number of digits.\nThe second line of input contains a positive integer which is \\(n\\)\rdigit long.\nInput constraints\r#\r\\(1 \\le n \\le 10000\\)\rOutput Format\r#\rOutput YES if the number is divisible by 11 and NO otherwise.\nSample inputs and outputs\r#\rSample Input 1\n4\r2548\rSample Output 1\nNO\rSample Input 2\n2\r22\rSample Output 2\nYES\rSolution\r#\r#include \u0026lt;stdio.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\\n\u0026#34;, \u0026amp;n); int cnt[] = {0, 0}; for (int i = 0; i \u0026lt; n; i++) { char c; scanf(\u0026#34;%c\u0026#34;, \u0026amp;c); cnt[i % 2] += (c - \u0026#39;0\u0026#39;); } cnt[0] %= 11, cnt[1] %= 11; if ((cnt[0] - cnt[1] + 11) % 11) printf(\u0026#34;NO\\n\u0026#34;); else printf(\u0026#34;YES\\n\u0026#34;); return 0; } Question 2 - \u0026ldquo;Reversed\u0026rdquo; (Modified)\r#\rProblem Description\r#\rGiven an integer input, print the number obtained by reversing its digits. If the reverse contains leading zeroes, do not output them\nInput Format\r#\rThe first and only line of input contains a positive integer \\(N\\)\r.\nInput constraints\r#\r\\(1 \\le N \\le 10^{18}\\)\rOutput Format\r#\rOutput a single integer which denotes the integer obtained by reversing the digits of \\(N\\)\r, without any leading zeroes.\nSample inputs and outputs\r#\rSample Input 1\n348\rSample Output 1\n843\rSample Input 2\n23813900\rSample Output 2\n931832\rSolution\r#\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(void) { long long int n; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n); const int MAX_DIGITS = 20; int final[MAX_DIGITS]; memset(final, 0, sizeof(final)); int end = 0; while (n) { final[end++] = (n % 10); n /= 10; } int st = 0; while (!final[st]) st++; //would break if n = 0 was part of the input for (; st \u0026lt; end; st++) printf(\u0026#34;%d\u0026#34;, final[st]); printf(\u0026#34;\\n\u0026#34;); return 0; } "},{"id":35,"href":"/docs/course_material/practice_problems/week6/","title":"Week - 6","section":"Practice Problems","content":"\rPractice problems for week 6\r#\rQuestion 1 - \u0026ldquo;Non-Fancy Trains\u0026rdquo;\r#\rProblem Description\r#\rThere are \\(n\\)\rstations numbered \\(1, 2, ... n\\)\r. Stations \\(i\\)\rand \\(j\\)\rare connected via a train (\r\\(1 \\le i, j \\le n\\)\r) iff \\(|i - j| \\le 2\\)\r. The price of such a train would be \\(|a_i - a_{j}|\\)\rwhere \\(a_i\\)\ris an input array denoting the ratings of stations. If you travel optimally, find the minimum cost to travel form station \\(1\\)\rto station \\(n\\)\r.\nInput Format\r#\rThe first line of input contains a single integer \\(n\\)\rdenoting the number of stations.\nThe second line contains \\(n\\)\rspace-seperated integers, \\(a_i\\)\r.\nInput constraints\r#\r\\(2 \\le n \\le 10^5\\)\r\\(1 \\le a_i \\le 10^4\\)\rOutput Format\r#\rPrint one integer, the minimum cost to travel from station \\(1\\)\rto station \\(n\\)\r.\nSample Input 1\r#\r4\r10 30 40 20\rSample Output 1\r#\r30\rSample Explanation\r#\rOne valid path is to go through the stations \\(1 \\rightarrow 2 \\rightarrow 4\\)\r, which incurs the cost \\(|10 - 30| \u0026#43; |30 - 20| = 30\\)\r**Sample Input 2 **\n2\r10 10\rSample Output 2\n0\rQuestion 2 - \u0026ldquo;String Palindrome Check\u0026rdquo;\r#\rProblem Description\r#\rGiven a string \\(S\\)\r, check if it is a palindrome using recursion.\nInput Format\r#\rThe first line of input contains a single integer \\(2T\\)\rthat denotes the number of test-cases. Then, \\(2T\\)\rlines follow. The first line of each test-case contains a single integer \\(N\\)\rdenoting the length of the string. The second line of each test-case contains a string \\(S\\)\rof length \\(N\\)\r.\nInput constraints\r#\r\\(1 \\le T \\le 2 \\times 10^5\\)\r\\(1 \\le N \\le 2 \\times 10^5\\)\r\\(|S| = N\\)\r\\(S\\)\rconsists of only lowercase English alphabets The sum of \\(N\\)\rover all test-cases does not exceed \\(2 \\times 10^5\\)\rOutput Format\r#\rFor each test-case, on a single line, output YES if the string is a palindrome and NO if not\nSample inputs and outputs\r#\rSample Input 1\n2\raddd\rsss\rSample Output 1\nNO\rYES\rSample Input 2\n3\raddfdfdda\ra\raddfdffdda\rSample Output 2\nYES\rYES\rNO\r"}]